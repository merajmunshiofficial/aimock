[
  {
    "question": "What are the main strategies for handling inter-service communication in a microservices architecture using Spring Boot?",
    "answer": "The main strategies include: 1) RESTful APIs using Spring Web with REST controllers, 2) Spring Cloud Feign for declarative web service clients, 3) Spring Cloud OpenFeign with enhanced capabilities, 4) Message Brokers (RabbitMQ, Kafka, ActiveMQ) for asynchronous communication, 5) gRPC for high-performance RPC, 6) Service Discovery using Eureka or Consul, and 7) API Gateway for centralized routing and cross-cutting concerns."
  },
  {
    "question": "What are the pros and cons of using RESTful APIs for inter-service communication?",
    "answer": "Pros: Simple to implement, widely used, and easy to understand. Cons: Synchronous communication can lead to tight coupling and latency issues."
  },
  {
    "question": "How does Spring Cloud Feign simplify web service client development?",
    "answer": "Spring Cloud Feign is a declarative web service client that reduces boilerplate code for REST clients. You use the @FeignClient annotation to define a client for another service, and it integrates well with Spring Cloud. However, it still relies on HTTP and shares the same drawbacks as REST."
  },
  {
    "question": "What additional features does Spring Cloud OpenFeign provide over regular Feign?",
    "answer": "Spring Cloud OpenFeign is an extension of Feign that integrates with Spring Cloud, providing additional features like load balancing and circuit breakers. It offers enhanced capabilities for resilience and service discovery, but adds complexity and requires additional configuration."
  },
  {
    "question": "What are the advantages and disadvantages of using message brokers for inter-service communication?",
    "answer": "Advantages: Decouples services, improves resilience, and allows for event-driven architectures. Disadvantages: More complex to implement and manage, requires handling message delivery guarantees."
  },
  {
    "question": "What makes gRPC suitable for microservices communication?",
    "answer": "gRPC is a high-performance RPC framework that uses HTTP/2 for transport and Protocol Buffers for serialization. Pros include efficient binary serialization, streaming support, and language-agnostic capabilities. Cons include more complex setup and requiring knowledge of Protocol Buffers."
  },
  {
    "question": "How does service discovery work in Spring Boot microservices?",
    "answer": "Service discovery uses tools like Eureka or Consul to manage service instances and their locations. Services register with Eureka and use the @LoadBalanced annotation with RestTemplate or Feign clients. It automatically handles service instance management and load balancing but adds complexity and requires additional infrastructure."
  },
  {
    "question": "What role does an API Gateway play in microservices architecture?",
    "answer": "An API Gateway (like Spring Cloud Gateway or Zuul) acts as a single entry point for clients, routing requests to appropriate microservices. It centralizes cross-cutting concerns like authentication, logging, and rate limiting. However, it can become a single point of failure if not designed for high availability."
  },
  {
    "question": "What are the key caching mechanisms available in Spring Boot?",
    "answer": "Spring Boot provides: 1) Spring Cache Abstraction with annotations like @EnableCaching, @Cacheable, @CachePut, and @CacheEvict, 2) Various cache providers including ConcurrentHashMap, Ehcache, Hazelcast, Redis, and Caffeine, 3) Configuration through application properties, 4) Custom cache managers, and 5) Cache statistics support."
  },
  {
    "question": "What do the main Spring caching annotations do?",
    "answer": "@EnableCaching enables caching in a Spring Boot application. @Cacheable indicates that method results should be cached. @CachePut always executes the method and updates the cache. @CacheEvict removes entries from the cache when certain conditions are met."
  },
  {
    "question": "What are the characteristics of different cache providers in Spring Boot?",
    "answer": "ConcurrentHashMap: Simple in-memory cache for small applications. Ehcache: Robust caching with time-based expiration and eviction policies. Hazelcast: In-memory data grid for distributed caching in clustered applications. Redis: In-memory data structure store known for performance and scalability. Caffeine: High-performance caching library with advanced features like automatic eviction."
  },
  {
    "question": "How do you configure Ehcache in Spring Boot?",
    "answer": "Configure Ehcache in application.properties with 'spring.cache.type=ehcache' or in application.yml with 'spring: cache: type: ehcache'. You can also create an ehcache.xml file to define cache configurations including expiration policies and eviction strategies."
  },
  {
    "question": "What are the steps to implement caching in a Spring Boot application?",
    "answer": "Steps include: 1) Add dependencies (spring-boot-starter-cache and specific cache provider), 2) Enable caching with @EnableCaching annotation, 3) Configure cache properties in application.properties/yml, 4) Use caching annotations (@Cacheable, @CachePut, @CacheEvict) in service methods, 5) Test the caching functionality, and 6) Optionally monitor cache statistics."
  },
  {
    "question": "How do you add Spring Boot caching dependencies for Maven and Gradle?",
    "answer": "For Maven: Add spring-boot-starter-cache and specific provider like ehcache dependencies. For Gradle: Use 'implementation org.springframework.boot:spring-boot-starter-cache' and 'implementation org.ehcache:ehcache'."
  },
  {
    "question": "How do you enable caching in a Spring Boot application?",
    "answer": "Enable caching by adding the @EnableCaching annotation to one of your configuration classes, typically the main application class or a dedicated cache configuration class."
  },
  {
    "question": "How do you use the @Cacheable annotation in Spring Boot?",
    "answer": "@Cacheable is used on methods to cache their results. Example: @Cacheable(value = \"users\", key = \"#id\") caches the method result using the specified cache name and key. Subsequent calls with the same parameters return the cached result."
  },
  {
    "question": "What is the difference between @CachePut and @Cacheable?",
    "answer": "@Cacheable returns cached results if available, skipping method execution. @CachePut always executes the method and updates the cache with the result, useful for updating cached data after modifications."
  },
  {
    "question": "How do you remove entries from cache using @CacheEvict?",
    "answer": "@CacheEvict removes entries from the cache. Example: @CacheEvict(value = \"users\", key = \"#id\") removes a specific user from cache when called, typically used after delete operations."
  },
  {
    "question": "How do you configure Redis as a cache provider in Spring Boot?",
    "answer": "Add spring-session-data-redis dependency, configure Redis connection in application.properties (spring.redis.host, spring.redis.port), and set spring.session.store-type=redis. Spring Boot will auto-configure Redis as the cache provider."
  },
  {
    "question": "What is an example of a complete caching implementation in Spring Boot?",
    "answer": "A complete implementation includes: 1) UserService with @Cacheable(\"users\") annotation, 2) Cache configuration class with @EnableCaching, 3) Method that simulates slow operations, 4) Proper cache key management, and 5) Testing to verify first call is slow while subsequent calls return cached results immediately."
  },
  {
    "question": "How do you identify performance issues in a Spring Boot application under high load?",
    "answer": "Steps include: 1) Performance monitoring using tools like YourKit or VisualVM, 2) Profiling to pinpoint bottlenecks like slow queries or memory leaks, 3) Analyzing metrics for CPU usage, memory consumption, response times, and error rates, 4) Database optimization through query analysis and indexing, and 5) Implementing caching strategies and optimizing configurations."
  },
  {
    "question": "What are the key steps for performance monitoring in Spring Boot?",
    "answer": "Key steps include: 1) Utilize monitoring tools like Spring Boot Actuator, Prometheus, and Grafana for real-time metrics, 2) Analyze metrics focusing on CPU usage, memory consumption, response times, and error rates, 3) Identify potential bottlenecks through systematic monitoring."
  },
  {
    "question": "How do you profile a Spring Boot application for performance issues?",
    "answer": "Use profiling tools such as YourKit, JProfiler, or VisualVM to analyze CPU and memory usage. Look for methods or components that consume excessive resources or have long execution times (hotspots)."
  },
  {
    "question": "What database optimization techniques help with Spring Boot performance?",
    "answer": "Database optimization includes: 1) Analyzing queries using execution plan tools, 2) Implementing appropriate indexing to improve query performance, 3) Avoiding N+1 queries by optimizing ORM usage, 4) Using connection pooling, and 5) Implementing read replicas and database sharding."
  },
  {
    "question": "How do caching strategies improve Spring Boot application performance?",
    "answer": "Caching strategies include: 1) Implementing Spring's caching abstraction or third-party solutions like Redis, 2) Configuring cache properties including cache sizes and eviction policies, 3) Caching frequently accessed data to balance memory usage and performance."
  },
  {
    "question": "How does concurrency management help with performance in Spring Boot?",
    "answer": "Concurrency management involves: 1) Optimizing thread pools by reviewing and adjusting configurations to handle concurrent requests effectively, 2) Utilizing asynchronous methods to prevent blocking and improve responsiveness."
  },
  {
    "question": "What code optimization techniques improve Spring Boot performance?",
    "answer": "Code optimization includes: 1) Reviewing and refactoring performance-critical sections to eliminate unnecessary computations, 2) Implementing batch processing for database operations to reduce the number of calls, 3) Optimizing critical code paths."
  },
  {
    "question": "How do you optimize external service calls in Spring Boot applications?",
    "answer": "Optimize external service calls by: 1) Analyzing and reducing latency in external service calls, 2) Implementing retries and circuit breakers as needed, 3) Monitoring external dependencies to ensure they don't become bottlenecks."
  },
  {
    "question": "What role does load testing play in Spring Boot performance optimization?",
    "answer": "Load testing involves: 1) Using tools like Apache JMeter or Gatling to simulate high traffic, 2) Identifying performance issues under load, 3) Analyzing load testing results to pinpoint areas requiring optimization."
  },
  {
    "question": "What are the best practices for versioning REST APIs in Spring Boot?",
    "answer": "Best practices include: 1) Choose a versioning strategy (URI, query parameter, header, or content negotiation), 2) Follow semantic versioning (MAJOR.MINOR.PATCH), 3) Maintain backward compatibility, 4) Provide clear documentation, 5) Implement deprecation policy, 6) Organize controllers by version, 7) Implement automated tests for each version."
  },
  {
    "question": "What are the different versioning strategies for REST APIs?",
    "answer": "Versioning strategies include: 1) URI Versioning (/api/v1/users), 2) Query Parameter Versioning (/api/users?version=1), 3) Header Versioning (Accept: application/vnd.yourapi.v1+json), 4) Content Negotiation using Accept header for media types."
  },
  {
    "question": "How should you apply semantic versioning principles to REST APIs?",
    "answer": "Follow semantic versioning (MAJOR.MINOR.PATCH) where: MAJOR indicates breaking changes, MINOR indicates new features that are backward-compatible, and PATCH indicates backward-compatible bug fixes."
  },
  {
    "question": "How do you maintain backward compatibility in API versioning?",
    "answer": "Maintain backward compatibility by ensuring new versions don't break existing clients. This involves deprecating features gradually rather than removing them outright, and using HTTP status codes like 410 Gone to indicate deprecated endpoints."
  },
  {
    "question": "How should you organize controllers for API versioning in Spring Boot?",
    "answer": "Organize controllers by version using separate packages or classes for each version. Example: @RestController @RequestMapping(\"/api/v1/users\") for version 1 and @RestController @RequestMapping(\"/api/v2/users\") for version 2."
  },
  {
    "question": "How does Spring Boot simplify data access layer implementation?",
    "answer": "Spring Boot simplifies data access through: 1) Spring Data JPA with automatic repository implementation, 2) Simplified configuration via application.properties, 3) Easy entity mapping with JPA annotations, 4) Built-in query methods using naming conventions, 5) Pagination and sorting support, 6) Auditing support, 7) Database independence, and 8) Integration with Spring ecosystem."
  },
  {
    "question": "How does Spring Data JPA provide automatic repository implementation?",
    "answer": "Spring Data JPA automatically generates implementations for repository interfaces, allowing developers to perform CRUD operations without writing boilerplate code. Example: 'public interface UserRepository extends JpaRepository<User, Long> { List<User> findByName(String name); }'"
  },
  {
    "question": "How does Spring Boot simplify database configuration?",
    "answer": "Spring Boot provides streamlined database configuration through application.properties file, reducing complexity of setting up data sources. Example configuration includes datasource URL, username, password, and JPA database platform settings."
  },
  {
    "question": "How do JPA entities work in Spring Boot?",
    "answer": "JPA entities are easily defined using annotations like @Entity, @Table, @Id, and @GeneratedValue, which map Java classes to database tables, simplifying data model representation."
  },
  {
    "question": "What are query methods in Spring Data JPA?",
    "answer": "Query methods allow developers to define query methods in repository interfaces using naming conventions, enabling Spring Data JPA to generate necessary SQL queries automatically. Example: 'List<User> findByNameStartingWith(String namePrefix);'"
  },
  {
    "question": "How does Spring Boot support pagination and sorting?",
    "answer": "Spring Boot provides built-in support for pagination and sorting, allowing developers to manage large datasets without additional coding. Example: 'Page<User> findByNameStartingWith(String namePrefix, Pageable pageable);'"
  },
  {
    "question": "What auditing support does Spring Data JPA provide?",
    "answer": "Spring Data JPA includes auditing features for automatic tracking of entity changes, such as creation and modification timestamps. Example: @CreatedDate private LocalDateTime createdAt;"
  },
  {
    "question": "What are conditional annotations in Spring Boot and what is their purpose?",
    "answer": "Conditional annotations allow developers to conditionally include or exclude beans from the application context based on certain conditions. Their purpose includes: 1) Environment-specific configuration, 2) Feature toggles, 3) Modularization, 4) Dependency management, and 5) Testing support."
  },
  {
    "question": "What are the common conditional annotations in Spring Boot?",
    "answer": "Common conditional annotations include: @Conditional (general-purpose), @ConditionalOnProperty (based on property values), @ConditionalOnClass (class presence), @ConditionalOnMissingClass (class absence), @ConditionalOnBean (bean presence), @ConditionalOnMissingBean (bean absence), @ConditionalOnResource (resource presence), and @ConditionalOnExpression (SpEL expressions)."
  },
  {
    "question": "How does @ConditionalOnProperty work in Spring Boot?",
    "answer": "@ConditionalOnProperty allows a bean to be created only if a specific property is present and has a specific value. Example: @ConditionalOnProperty(name = \"feature.enabled\", havingValue = \"true\") creates the bean only when the property is set to true."
  },
  {
    "question": "What is the difference between @ConditionalOnClass and @ConditionalOnMissingClass?",
    "answer": "@ConditionalOnClass checks if a specific class is present on the classpath and creates the bean if found. @ConditionalOnMissingClass is the opposite - it creates a bean only if a specific class is not present on the classpath."
  },
  {
    "question": "How do @ConditionalOnBean and @ConditionalOnMissingBean work?",
    "answer": "@ConditionalOnBean allows a bean to be created only if a specific bean is already defined in the application context. @ConditionalOnMissingBean is the opposite - it creates a bean only if a specific bean is not already defined in the context."
  },
  {
    "question": "What is the role of @EnableAutoConfiguration in Spring Boot?",
    "answer": "@EnableAutoConfiguration is a core feature that enables Spring Boot's auto-configuration mechanism. It automatically configures Spring beans based on dependencies present on the classpath and properties defined in the application, embodying 'convention over configuration' principles."
  },
  {
    "question": "How does Spring Boot achieve auto-configuration internally?",
    "answer": "Spring Boot achieves auto-configuration through: 1) spring.factories file listing auto-configuration classes, 2) Conditional annotations determining when configurations apply, 3) Auto-configuration classes containing actual configuration logic, 4) Application context scanning and applying configurations, 5) AutoConfigurationImportSelector managing the process, and 6) Exclusion capabilities for fine-tuning."
  },
  {
    "question": "What is the spring.factories file and how is it used in auto-configuration?",
    "answer": "The spring.factories file is located in META-INF directory of Spring Boot JAR files and lists all auto-configuration classes that should be loaded. When @EnableAutoConfiguration is used, Spring Boot reads this file to find available auto-configuration classes."
  },
  {
    "question": "How do conditional annotations work in auto-configuration?",
    "answer": "Each auto-configuration class uses conditional annotations (like @ConditionalOnClass, @ConditionalOnMissingBean) to determine whether the configuration should be applied. For example, if a certain class is present on the classpath, the corresponding configuration will be applied."
  },
  {
    "question": "What are auto-configuration classes in Spring Boot?",
    "answer": "Auto-configuration classes contain the actual configuration logic and define beans and their dependencies based on specified conditions. For instance, if a DataSource class is present, the auto-configuration class for database support will create a DataSource bean."
  },
  {
    "question": "How do you access Spring Initializr and what are the steps to create a project?",
    "answer": "You can access Spring Initializr at https://start.spring.io/. Steps: 1) Choose project type (Maven/Gradle), 2) Select language (Java/Kotlin/Groovy), 3) Choose Spring Boot version, 4) Enter project metadata (Group, Artifact, Name, Description), 5) Select packaging (Jar/War), 6) Choose Java version, 7) Add dependencies by searching and selecting them, 8) Click 'Generate' to download the project ZIP file, 9) Extract and import into your IDE."
  },
  {
    "question": "What are the alternatives to using Spring Initializr for creating Spring Boot projects?",
    "answer": "Alternatives include: 1) IDE plugins like Spring Tools Suite (STS), IntelliJ IDEA's Spring Initializr integration, or Eclipse Spring Boot project wizard, 2) Spring Boot CLI command line tool, 3) Manual project setup by creating the directory structure and configuration files yourself, 4) Using Maven archetypes or Gradle templates, 5) Cloning existing Spring Boot project templates from repositories."
  },
  {
    "question": "How does Spring Boot's application.properties file work and what can you configure with it?",
    "answer": "The application.properties file is used for externalized configuration in Spring Boot. You can configure: 1) Server settings (server.port, server.servlet.context-path), 2) Database connections (spring.datasource.url, username, password), 3) Logging levels (logging.level.com.example=DEBUG), 4) Spring profiles (spring.profiles.active), 5) JPA/Hibernate settings (spring.jpa.hibernate.ddl-auto), 6) Security configurations, 7) Actuator endpoints, 8) Custom application properties that can be injected using @Value or @ConfigurationProperties."
  },
  {
    "question": "What is the difference between application.properties and application.yml files in Spring Boot?",
    "answer": "Both serve the same purpose but use different formats: application.properties uses key-value pairs (server.port=8080), while application.yml uses YAML hierarchical structure. YAML advantages: more readable for complex configurations, supports lists and nested objects naturally, less verbose. Properties advantages: simpler syntax, wider tool support, less sensitive to indentation. You can use either format, and Spring Boot will automatically detect and load the appropriate file."
  },
  {
    "question": "How do you use @ConfigurationProperties to bind properties to Java objects?",
    "answer": "@ConfigurationProperties allows type-safe binding of properties to POJOs. Example: @ConfigurationProperties(prefix = \"app.mail\") creates a class with fields like host, port, username that bind to app.mail.host, app.mail.port, app.mail.username properties. You need to enable it with @EnableConfigurationProperties or @ConfigurationPropertiesScan. Benefits include type safety, validation support, IDE auto-completion, and organized configuration management."
  },
  {
    "question": "What is property precedence in Spring Boot and how does it work?",
    "answer": "Spring Boot follows a specific order when loading properties (highest to lowest precedence): 1) Command line arguments, 2) Java system properties, 3) OS environment variables, 4) Profile-specific properties (application-{profile}.properties), 5) Application properties (application.properties), 6) @PropertySource annotations, 7) Default properties. This allows for flexible configuration management across different environments and deployment scenarios."
  },
  {
    "question": "How do you enable and configure different logging levels in Spring Boot?",
    "answer": "Configure logging levels in application.properties: logging.level.com.example=DEBUG sets package-level logging, logging.level.org.springframework=INFO sets framework logging, logging.level.root=WARN sets global logging. You can also configure log file output with logging.file.name=myapp.log or logging.file.path=/var/log/. Spring Boot uses Logback by default but supports Log4j2 and Java Util Logging."
  },
  {
    "question": "What are the different ways to run a Spring Boot application?",
    "answer": "Multiple ways to run Spring Boot applications: 1) From IDE by running the main method, 2) Command line using 'java -jar app.jar', 3) Maven with 'mvn spring-boot:run', 4) Gradle with './gradlew bootRun', 5) Spring Boot CLI with 'spring run app.groovy', 6) As a service on Linux systems, 7) In containers using Docker, 8) Cloud deployment platforms like Heroku, AWS, etc."
  },
  {
    "question": "How does Spring Boot handle error pages and exception handling?",
    "answer": "Spring Boot provides default error handling with a white-label error page. You can customize by: 1) Creating custom error pages (error/404.html, error/500.html) in templates directory, 2) Implementing ErrorController interface, 3) Using @ControllerAdvice for global exception handling, 4) Configuring server.error properties (server.error.path, server.error.include-stacktrace), 5) Creating custom error attributes, 6) Using @ExceptionHandler for specific controller exceptions."
  },
  {
    "question": "What is Spring Boot DevTools and what development features does it provide?",
    "answer": "Spring Boot DevTools enhances development experience with: 1) Automatic restart when classpath changes (faster than cold starts), 2) LiveReload integration for browser refresh, 3) Remote debugging capabilities, 4) Property defaults optimized for development (template caching disabled), 5) H2 console auto-configuration, 6) Exclusion from production builds, 7) Remote update capabilities for deployed applications. Add spring-boot-devtools dependency to enable these features."
  },
  {
    "question": "How do automatic restarts work in Spring Boot DevTools?",
    "answer": "DevTools monitors classpath changes and triggers automatic restarts using two classloaders: 1) Base classloader for third-party JARs (doesn't change), 2) Restart classloader for application classes (reloaded when changes detected). This approach is faster than full JVM restart. You can exclude certain paths from monitoring using spring.devtools.restart.exclude property or disable restart entirely with spring.devtools.restart.enabled=false."
  },
  {
    "question": "What is LiveReload and how do you use it with Spring Boot DevTools?",
    "answer": "LiveReload automatically refreshes browsers when resources change. Spring Boot DevTools includes a LiveReload server that triggers browser refresh when static resources or templates are modified. To use: 1) Ensure DevTools is in classpath, 2) Install LiveReload browser extension, 3) Enable the extension on your page, 4) Changes to CSS, JavaScript, or templates automatically refresh the browser. Can be disabled with spring.devtools.livereload.enabled=false."
  },
  {
    "question": "How do you configure custom properties for remote development with DevTools?",
    "answer": "For remote development, DevTools allows: 1) Remote restart capabilities by including devtools in the deployed application, 2) Set spring.devtools.remote.secret property for security, 3) Use RemoteSpringApplication to connect to remote instance, 4) Configure remote debugging with spring.devtools.remote.debug.enabled=true, 5) Tunnel connections through spring.devtools.remote.proxy settings. This enables hot-swapping of classes in remote environments."
  },
  {
    "question": "What is Spring Boot Actuator and what production-ready features does it provide?",
    "answer": "Spring Boot Actuator provides production-ready monitoring and management features: 1) Health checks (/actuator/health), 2) Application metrics (/actuator/metrics), 3) Environment information (/actuator/env), 4) Configuration properties (/actuator/configprops), 5) HTTP request mappings (/actuator/mappings), 6) JVM and system information, 7) Custom health indicators, 8) Application events and audit trails, 9) Graceful shutdown capabilities, 10) Integration with monitoring systems."
  },
  {
    "question": "How do you enable and configure Actuator endpoints?",
    "answer": "Enable Actuator by adding spring-boot-starter-actuator dependency. Configure endpoints: 1) Expose endpoints via management.endpoints.web.exposure.include=health,info,metrics, 2) Change base path with management.endpoints.web.base-path=/manage, 3) Change port with management.server.port=9090, 4) Secure endpoints with management.endpoints.web.exposure.exclude=shutdown, 5) Enable sensitive endpoints like shutdown with management.endpoint.shutdown.enabled=true."
  },
  {
    "question": "What information does the /actuator/health endpoint provide?",
    "answer": "The health endpoint provides application health status: 1) Overall status (UP/DOWN/OUT_OF_SERVICE/UNKNOWN), 2) Component health checks (database, disk space, mail, etc.), 3) Custom health indicators, 4) Detailed health information (when management.endpoint.health.show-details=always), 5) Health groups for different audiences, 6) Reactive health indicators for WebFlux applications. You can create custom health indicators by implementing HealthIndicator interface."
  },
  {
    "question": "How do you create custom health indicators in Spring Boot Actuator?",
    "answer": "Create custom health indicators by implementing HealthIndicator interface: @Component public class CustomHealthIndicator implements HealthIndicator { @Override public Health health() { // Check your custom component boolean isHealthy = checkCustomComponent(); if (isHealthy) { return Health.up().withDetail(\"custom\", \"Service is running\").build(); } return Health.down().withDetail(\"custom\", \"Service is down\").build(); } }. The indicator automatically appears in /actuator/health endpoint."
  },
  {
    "question": "What metrics are available through the /actuator/metrics endpoint?",
    "answer": "Actuator provides numerous metrics: 1) JVM metrics (jvm.memory.used, jvm.gc.count), 2) CPU metrics (system.cpu.usage, process.cpu.usage), 3) HTTP metrics (http.server.requests), 4) Database connection pool metrics, 5) Cache metrics, 6) Custom application metrics, 7) Micrometer integration metrics, 8) Thread and classloader metrics. Access specific metrics with /actuator/metrics/{metric.name} and add tags for filtering."
  },
  {
    "question": "How do you create custom metrics with Micrometer in Spring Boot?",
    "answer": "Create custom metrics using Micrometer: 1) Inject MeterRegistry, 2) Create counters: Counter.builder(\"custom.counter\").register(registry), 3) Create timers: Timer.builder(\"custom.timer\").register(registry), 4) Create gauges: Gauge.builder(\"custom.gauge\").register(registry, this, obj -> getValue()), 5) Use @Timed annotation for method timing, 6) Add tags for dimensionality: .tag(\"type\", \"business\"). Custom metrics appear in /actuator/metrics endpoint."
  },
  {
    "question": "How do you integrate Spring Boot Actuator with external monitoring systems?",
    "answer": "Integrate with external monitoring: 1) Prometheus: Add micrometer-registry-prometheus dependency, expose /actuator/prometheus endpoint, 2) Grafana: Configure Prometheus as data source, create dashboards, 3) StatsD: Add micrometer-registry-statsd dependency, 4) New Relic: Add micrometer-registry-new-relic, 5) CloudWatch: Add micrometer-registry-cloudwatch, 6) Custom exporters: Implement MeterRegistry for proprietary systems, 7) Configure registry properties in application.properties."
  },
  {
    "question": "What is the purpose of the /actuator/info endpoint and how do you customize it?",
    "answer": "The info endpoint provides application information. Customize by: 1) Adding properties with info.* prefix (info.app.name=MyApp), 2) Git information (automatically included with git-commit-id-plugin), 3) Build information (from META-INF/build-info.properties), 4) Custom InfoContributor beans: @Component public class CustomInfoContributor implements InfoContributor { public void contribute(Info.Builder builder) { builder.withDetail(\"custom\", \"value\"); } }, 5) Environment variables with INFO_ prefix."
  },
  {
    "question": "How do you secure Actuator endpoints in production?",
    "answer": "Secure Actuator endpoints: 1) Use different port: management.server.port=9090, 2) Enable security: include spring-boot-starter-security, 3) Configure access: management.endpoints.web.exposure.include=health,info, exclude sensitive ones, 4) Set up authentication: configure WebSecurityConfigurerAdapter, 5) Use HTTPS: management.server.ssl.enabled=true, 6) Network restrictions: bind to internal interface only, 7) Role-based access: @PreAuthorize(\"hasRole('ACTUATOR')\"), 8) Disable endpoints in production: management.endpoints.enabled-by-default=false."
  },
  {
    "question": "What testing support does Spring Boot provide?",
    "answer": "Spring Boot provides comprehensive testing support: 1) @SpringBootTest for integration tests, 2) @WebMvcTest for web layer testing, 3) @DataJpaTest for JPA repository testing, 4) @JsonTest for JSON serialization testing, 5) @MockBean for mocking beans, 6) TestRestTemplate for REST API testing, 7) @TestPropertySource for test-specific properties, 8) @ActiveProfiles for test profiles, 9) @Sql for test data setup, 10) WebTestClient for WebFlux testing, 11) Testcontainers integration for external dependencies."
  },
  {
    "question": "What is the difference between @SpringBootTest and other test annotations?",
    "answer": "@SpringBootTest loads complete application context for integration testing. Other annotations are more focused: @WebMvcTest loads only web layer (controllers, filters), @DataJpaTest loads only JPA components, @JsonTest for JSON marshalling/unmarshalling, @WebFluxTest for reactive web layer. Use specific annotations for faster, focused tests, and @SpringBootTest for full integration testing. Each annotation auto-configures only relevant components."
  },
  {
    "question": "How do you use @MockBean for mocking dependencies in Spring Boot tests?",
    "answer": "@MockBean replaces beans in application context with Mockito mocks: @SpringBootTest class MyServiceTest { @MockBean private MyRepository repository; @Autowired private MyService service; @Test void testService() { when(repository.findById(1L)).thenReturn(Optional.of(new Entity())); Entity result = service.getById(1L); assertThat(result).isNotNull(); } }. @MockBean creates mocks and injects them into the Spring context, automatically resetting between tests."
  },
  {
    "question": "How do you test web layers with @WebMvcTest?",
    "answer": "@WebMvcTest provides focused testing for MVC controllers: @WebMvcTest(MyController.class) class MyControllerTest { @Autowired private MockMvc mockMvc; @MockBean private MyService service; @Test void testEndpoint() throws Exception { when(service.getData()).thenReturn(\"test data\"); mockMvc.perform(get(\"/api/data\")) .andExpect(status().isOk()) .andExpect(content().string(\"test data\")); } }. It auto-configures MockMvc, security, and only loads web layer components."
  },
  {
    "question": "How do you test JPA repositories with @DataJpaTest?",
    "answer": "@DataJpaTest provides focused JPA testing: @DataJpaTest class MyRepositoryTest { @Autowired private TestEntityManager entityManager; @Autowired private MyRepository repository; @Test void testFindByName() { MyEntity entity = new MyEntity(\"test\"); entityManager.persistAndFlush(entity); Optional<MyEntity> found = repository.findByName(\"test\"); assertThat(found).isPresent(); } }. It configures in-memory database, loads only JPA components, and provides TestEntityManager for test data management."
  },
  {
    "question": "How do you write integration tests with TestRestTemplate?",
    "answer": "TestRestTemplate enables full integration testing: @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) class IntegrationTest { @Autowired private TestRestTemplate restTemplate; @Test void testGetEndpoint() { ResponseEntity<String> response = restTemplate.getForEntity(\"/api/data\", String.class); assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK); assertThat(response.getBody()).contains(\"expected data\"); } }. It starts full application context with embedded server on random port."
  },
  {
    "question": "How do you test JSON serialization and deserialization with @JsonTest?",
    "answer": "@JsonTest focuses on JSON processing: @JsonTest class MyJsonTest { @Autowired private JacksonTester<MyObject> json; @Test void testSerialize() throws Exception { MyObject object = new MyObject(\"test\", 123); assertThat(json.write(object)).isEqualToJson(\"expected.json\"); } @Test void testDeserialize() throws Exception { String content = \"{\\\"name\\\":\\\"test\\\",\\\"value\\\":123}\"; assertThat(json.parse(content)).isEqualTo(new MyObject(\"test\", 123)); } }. It provides JacksonTester and other JSON testing utilities."
  },
  {
    "question": "How do you set up test-specific configuration and properties?",
    "answer": "Configure test-specific settings: 1) @TestPropertySource(properties = {\"spring.datasource.url=jdbc:h2:mem:testdb\"}) for inline properties, 2) @TestPropertySource(locations = \"classpath:application-test.properties\") for property files, 3) @ActiveProfiles(\"test\") to activate test profile, 4) application-test.properties in test/resources, 5) @DynamicPropertySource for dynamic properties, 6) @MockBean for replacing beans, 7) Test configuration classes with @TestConfiguration, 8) Environment variables in test execution."
  },
  {
    "question": "How do you test reactive applications with WebTestClient?",
    "answer": "WebTestClient tests reactive web applications: @WebFluxTest(MyController.class) class MyControllerTest { @Autowired private WebTestClient webTestClient; @MockBean private MyService service; @Test void testReactiveEndpoint() { when(service.getData()).thenReturn(Flux.just(\"data1\", \"data2\")); webTestClient.get().uri(\"/api/data\") .exchange() .expectStatus().isOk() .expectBodyList(String.class) .hasSize(2); } }. It's designed for testing WebFlux applications and supports reactive streams."
  },
  {
    "question": "What is Spring Boot's logging framework and how do you configure it?",
    "answer": "Spring Boot uses Logback as default logging framework with Commons Logging API. Configuration options: 1) application.properties: logging.level.com.example=DEBUG, logging.file.name=app.log, 2) logback-spring.xml for advanced configuration, 3) Profile-specific logging: <springProfile name=\"dev\">, 4) Pattern customization: logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} - %msg%n, 5) Log rotation: logging.logback.rollingpolicy.max-file-size=10MB, 6) Async logging, 7) Custom appenders and loggers."
  },
  {
    "question": "How do you configure different log levels for different packages?",
    "answer": "Configure package-specific log levels in application.properties: logging.level.com.example.service=DEBUG sets service package to DEBUG, logging.level.org.springframework=INFO sets Spring framework to INFO, logging.level.org.hibernate=WARN sets Hibernate to WARN, logging.level.root=ERROR sets global level to ERROR. More specific package names override general ones. You can also use logback-spring.xml for complex configurations with conditions and profiles."
  },
  {
    "question": "How do you configure file logging in Spring Boot?",
    "answer": "Configure file logging: 1) logging.file.name=myapp.log writes to specific file, 2) logging.file.path=/var/logs/ writes to directory with default name, 3) logging.logback.rollingpolicy.file-name-pattern for rotation, 4) logging.logback.rollingpolicy.max-file-size=10MB for size-based rotation, 5) logging.logback.rollingpolicy.max-history=30 for retention days, 6) logging.pattern.file for file-specific patterns, 7) Custom logback-spring.xml for advanced file configurations including compression and cleanup policies."
  },
  {
    "question": "How do you use structured logging and JSON formatting in Spring Boot?",
    "answer": "Implement structured logging: 1) Add logstash-logback-encoder dependency, 2) Configure JSON encoder in logback-spring.xml: <encoder class=\"net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder\">, 3) Use structured logging with MDC (Mapped Diagnostic Context): MDC.put(\"userId\", \"123\"), 4) Custom JSON patterns, 5) Include request ID for tracing, 6) ELK stack integration (Elasticsearch, Logstash, Kibana), 7) Centralized logging with correlation IDs for microservices."
  },
  {
    "question": "How do you implement correlation IDs for distributed tracing in logs?",
    "answer": "Implement correlation IDs: 1) Create filter to generate/extract correlation ID from headers, 2) Store in MDC: MDC.put(\"correlationId\", correlationId), 3) Include in log pattern: logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%X{correlationId}] %level %logger - %msg%n, 4) Pass correlation ID to downstream services via HTTP headers, 5) Use Spring Cloud Sleuth for automatic correlation ID management, 6) Clear MDC after request: MDC.clear(), 7) Custom interceptors for automatic correlation ID propagation."
  },
  {
    "question": "How do you configure logging for different profiles (dev, prod)?",
    "answer": "Configure profile-specific logging: 1) In application.properties: logging.config=classpath:logback-${spring.profiles.active}.xml, 2) Use logback-spring.xml with profile conditions: <springProfile name=\"dev\"> <appender>...</appender> </springProfile>, 3) Different log levels per profile: logging.level.com.example=${LOG_LEVEL:INFO}, 4) Conditional appenders, 5) Profile-specific log files, 6) Development: console logging with colors, Production: file logging with JSON format, 7) Environment variables for dynamic configuration."
  },
  {
    "question": "How do you integrate Spring Boot with external logging systems like ELK stack?",
    "answer": "Integrate with ELK stack: 1) Use JSON formatting with logstash-logback-encoder, 2) Configure Filebeat to ship logs to Logstash, 3) Logstash processes and forwards to Elasticsearch, 4) Kibana for visualization and dashboards, 5) TCP appender for direct Logstash connection, 6) Structured logging with fields for filtering, 7) Log correlation IDs for request tracing, 8) Configure index patterns and retention policies, 9) Use Logback's async appenders for performance, 10) Monitor log shipping and processing."
  },
  {
    "question": "What are the best practices for logging in Spring Boot applications?",
    "answer": "Logging best practices: 1) Use appropriate log levels (ERROR for errors, WARN for warnings, INFO for important events, DEBUG for debugging), 2) Include context information (user ID, request ID, method parameters), 3) Use structured logging for production, 4) Avoid logging sensitive information (passwords, tokens), 5) Use correlation IDs for distributed tracing, 6) Configure log rotation and retention, 7) Use async logging for high-throughput applications, 8) Log exceptions with stack traces, 9) Use meaningful log messages, 10) Monitor log volume and performance impact."
  },
  {
    "question": "How do you handle sensitive data in logs and implement log sanitization?",
    "answer": "Handle sensitive data: 1) Use custom log filters to mask sensitive fields, 2) Implement custom JSON encoder with field masking, 3) Configure logback pattern to exclude sensitive request parameters, 4) Use @JsonIgnore or @JsonView for object serialization, 5) Create custom toString() methods that exclude sensitive fields, 6) Environment-specific logging (mask in prod, show in dev), 7) Regular expressions for pattern-based sanitization, 8) Audit logs separate from application logs, 9) Use structured logging with controlled field exposure, 10) Implement log data classification."
  },
  {
    "question": "How do you configure and use async logging in Spring Boot?",
    "answer": "Configure async logging: 1) Add AsyncAppender in logback-spring.xml: <appender name=\"ASYNC\" class=\"ch.qos.logback.classic.AsyncAppender\"> <appender-ref ref=\"FILE\"/> </appender>, 2) Configure queue size: <queueSize>256</queueSize>, 3) Set discard threshold: <discardingThreshold>20</discardingThreshold>, 4) Include caller data: <includeCallerData>false</includeCallerData> for performance, 5) Configure worker thread count, 6) Monitor queue utilization, 7) Use for high-throughput applications, 8) Balance between performance and log completeness."
  },
  {
    "question": "How do you implement custom log appenders in Spring Boot?",
    "answer": "Create custom appenders: 1) Extend AppenderBase<ILoggingEvent>, 2) Implement append() method for log processing, 3) Configure in logback-spring.xml: <appender name=\"CUSTOM\" class=\"com.example.CustomAppender\">, 4) Add properties and lifecycle methods (start(), stop()), 5) Handle threading and buffering, 6) Implement custom formatters and filters, 7) Examples: database appender, webhook appender, custom file rotation, 8) Use for specialized logging requirements like audit trails, notifications, or custom destinations."
  },
  {
    "question": "What is the role of Spring Boot's embedded servlet containers?",
    "answer": "Embedded servlet containers in Spring Boot: 1) Eliminate need for external server deployment, 2) Enable standalone JAR execution with java -jar, 3) Simplify development and testing with immediate startup, 4) Support Tomcat (default), Jetty, and Undertow, 5) Auto-configuration based on classpath dependencies, 6) Customizable through properties (server.port, server.servlet.context-path), 7) Production-ready with proper configuration, 8) Enable microservices architecture with self-contained services, 9) Support SSL, compression, and other enterprise features, 10) Facilitate cloud deployment and containerization."
  },
  {
    "question": "How do you customize embedded Tomcat configuration in Spring Boot?",
    "answer": "Customize embedded Tomcat: 1) Application properties: server.tomcat.max-threads=200, server.tomcat.connection-timeout=20s, 2) TomcatServletWebServerFactory bean customization, 3) WebServerFactoryCustomizer implementation, 4) Custom connectors for multiple ports, 5) SSL configuration: server.ssl.key-store, server.ssl.key-store-password, 6) Access logs: server.tomcat.accesslog.enabled=true, 7) Compression: server.compression.enabled=true, 8) Custom valves and filters, 9) JMX management, 10) Performance tuning parameters."
  },
  {
    "question": "How do you switch between different embedded servers (Tomcat, Jetty, Undertow)?",
    "answer": "Switch embedded servers: 1) Exclude default Tomcat: <exclusions><exclusion><groupId>org.springframework.boot</groupId><artifactId>spring-boot-starter-tomcat</artifactId></exclusion></exclusions>, 2) Add desired server: spring-boot-starter-jetty or spring-boot-starter-undertow, 3) Server-specific configuration properties, 4) For Jetty: server.jetty.* properties, 5) For Undertow: server.undertow.* properties, 6) Custom server factory beans if needed, 7) Consider performance characteristics and feature requirements when choosing, 8) Test thoroughly as servers have different behaviors and capabilities."
  },
  {
    "question": "How do you programmatically set active profiles in a Spring Boot application?",
    "answer": "You can programmatically set active profiles using SpringApplication.setAdditionalProfiles() or ConfigurableEnvironment.setActiveProfiles() in your main application class. Example: SpringApplication app = new SpringApplication(MyApplication.class); app.setAdditionalProfiles(\"dev\"); app.run(args);"
  },
  {
    "question": "What are the different ways to check which profiles are currently active in Spring?",
    "answer": "You can check active profiles using: 1) Environment.getActiveProfiles() method, 2) @Value(\"${spring.profiles.active}\") annotation to inject active profiles, 3) ApplicationContext.getEnvironment().getActiveProfiles(), 4) Spring Boot Actuator's /actuator/env endpoint to view environment properties including active profiles."
  },
  {
    "question": "How do you create profile-specific property files in Spring Boot?",
    "answer": "Create profile-specific property files by naming them application-{profile}.properties or application-{profile}.yml. Examples: application-dev.properties for development, application-prod.properties for production. Spring Boot automatically loads the appropriate file based on the active profile, with profile-specific properties overriding default ones."
  },
  {
    "question": "What is the difference between @Profile and @ConditionalOnProfile annotations?",
    "answer": "@Profile is a Spring Framework annotation used to conditionally register beans based on active profiles, while @ConditionalOnProfile is a Spring Boot annotation that provides more flexible profile-based conditional registration. @ConditionalOnProfile allows for more complex expressions and can check for the absence of profiles using the 'value' and 'missing' attributes."
  },
  {
    "question": "How do you handle default profiles in Spring applications?",
    "answer": "Default profiles are activated when no other profiles are explicitly set. Configure default profiles using: 1) spring.profiles.default property in application.properties, 2) SpringApplication.setDefaultProperties(), 3) @Profile(\"default\") annotation on beans. If no profiles are active, beans marked with 'default' profile will be loaded."
  },
  {
    "question": "What is the Spring Expression Language (SpEL) and what are its main features?",
    "answer": "Spring Expression Language (SpEL) is a powerful expression language that supports querying and manipulating objects at runtime. Main features include: 1) Method invocation and property access, 2) Operators (arithmetic, logical, relational), 3) Collection manipulation and projection, 4) Bean reference using @beanName, 5) Type operations and constructors, 6) Template expressions with #{}."
  },
  {
    "question": "How do you use SpEL expressions in Spring annotations?",
    "answer": "SpEL expressions are used in annotations with #{} syntax. Examples: @Value(\"#{systemProperties['user.name']}\") for system properties, @PreAuthorize(\"hasRole('ADMIN')\") for security, @Cacheable(key = \"#id\") for caching, @Scheduled(cron = \"#{cronExpression}\") for scheduling. SpEL can access method parameters, bean properties, and system variables."
  },
  {
    "question": "What operators are available in Spring Expression Language?",
    "answer": "SpEL supports various operators: 1) Arithmetic: +, -, *, /, %, ^, 2) Relational: ==, !=, <, >, <=, >=, 3) Logical: and, or, not, 4) Conditional: ?: (ternary), 5) Assignment: =, 6) Type: instanceof, matches (regex), 7) Collection: in, 8) Safe navigation: ?., 9) Elvis: ?:. These enable complex expression evaluation."
  },
  {
    "question": "How do you access bean properties and methods using SpEL?",
    "answer": "Access bean properties and methods in SpEL using: 1) @beanName.property for bean properties, 2) @beanName.method() for method calls, 3) Direct property access: #{person.name}, 4) Nested property access: #{person.address.street}, 5) Method chaining: #{person.getName().toUpperCase()}, 6) Safe navigation: #{person?.address?.street} to avoid null pointer exceptions."
  },
  {
    "question": "What is collection manipulation in SpEL and how is it used?",
    "answer": "SpEL provides powerful collection manipulation features: 1) Selection: #{list.?[property > 5]} filters collections, 2) Projection: #{list.![property]} extracts specific properties, 3) First/Last: #{list.^[condition]} and #{list.$[condition]}, 4) Map access: #{map['key']} or #{map.key}, 5) Collection operators: in, size(), isEmpty(). These enable complex collection processing within expressions."
  },
  {
    "question": "How do you use SpEL with configuration properties in Spring Boot?",
    "answer": "Use SpEL with configuration properties by: 1) @Value(\"#{${property.name}}\") for property references, 2) Combining properties: @Value(\"#{${base.url} + ${endpoint.path}}\"), 3) Default values: @Value(\"#{${optional.property:defaultValue}}\"), 4) Mathematical operations: @Value(\"#{${timeout.seconds} * 1000}\"), 5) Conditional expressions: @Value(\"#{${environment} == 'prod' ? ${prod.value} : ${dev.value}}\")."
  },
  {
    "question": "What is the bean lifecycle in Spring and what are its phases?",
    "answer": "The Spring bean lifecycle consists of several phases: 1) Instantiation: Bean constructor is called, 2) Dependency Injection: Properties and dependencies are set, 3) BeanNameAware.setBeanName() if implemented, 4) BeanFactoryAware.setBeanFactory() if implemented, 5) ApplicationContextAware.setApplicationContext() if implemented, 6) @PostConstruct or InitializingBean.afterPropertiesSet(), 7) Custom init-method, 8) Bean is ready for use, 9) @PreDestroy or DisposableBean.destroy(), 10) Custom destroy-method."
  },
  {
    "question": "How do you implement custom initialization logic for Spring beans?",
    "answer": "Implement custom initialization logic using: 1) @PostConstruct annotation on a method, 2) Implementing InitializingBean interface and overriding afterPropertiesSet(), 3) Using init-method attribute in XML configuration, 4) @Bean(initMethod = \"customInit\") in Java configuration, 5) ApplicationListener for ContextRefreshedEvent. @PostConstruct is preferred as it's annotation-based and more explicit."
  },
  {
    "question": "What are the different ways to implement bean destruction callbacks in Spring?",
    "answer": "Implement bean destruction callbacks using: 1) @PreDestroy annotation on a method, 2) Implementing DisposableBean interface and overriding destroy(), 3) Using destroy-method attribute in XML configuration, 4) @Bean(destroyMethod = \"customDestroy\") in Java configuration, 5) Runtime.getRuntime().addShutdownHook() for JVM shutdown hooks. @PreDestroy is recommended for its clarity and standardization."
  },
  {
    "question": "How do you use BeanPostProcessor to customize bean initialization?",
    "answer": "BeanPostProcessor allows customizing bean initialization by implementing the BeanPostProcessor interface with methods: 1) postProcessBeforeInitialization() - called before init methods, 2) postProcessAfterInitialization() - called after init methods. Register as a bean in configuration. Use cases include: adding proxies, modifying bean properties, validating beans, or adding cross-cutting concerns before/after initialization."
  },
  {
    "question": "What is the difference between BeanFactory and ApplicationContext in Spring?",
    "answer": "BeanFactory is the basic IoC container providing dependency injection, while ApplicationContext extends BeanFactory with additional features: 1) Event publication and listening, 2) Internationalization (i18n), 3) Resource loading, 4) Environment abstraction, 5) Annotation-based configuration, 6) AOP integration, 7) Web application support. ApplicationContext is preferred for most applications due to its rich feature set."
  },
  {
    "question": "How does lazy initialization work in Spring and when should you use it?",
    "answer": "Lazy initialization delays bean creation until first request using @Lazy annotation or lazy-init=\"true\" in XML. Benefits: 1) Faster startup time, 2) Reduced memory usage, 3) Avoiding circular dependencies. Use cases: 1) Heavy initialization beans, 2) Conditional beans not always needed, 3) Prototype beans. Drawbacks: 1) Configuration errors discovered late, 2) Potential performance impact on first access."
  },
  {
    "question": "What is Spring Data and what problem does it solve?",
    "answer": "Spring Data is a high-level project that simplifies data access across different data stores. It solves problems like: 1) Boilerplate repository code, 2) Inconsistent data access patterns, 3) Complex query implementations, 4) Multiple data store integration. Features include: automatic repository implementation, query method generation, pagination support, auditing, and consistent API across SQL and NoSQL databases."
  },
  {
    "question": "How do you create repository interfaces in Spring Data JPA?",
    "answer": "Create repository interfaces by extending Spring Data repository interfaces: 1) Repository<Entity, ID> - marker interface, 2) CrudRepository<Entity, ID> - basic CRUD operations, 3) PagingAndSortingRepository<Entity, ID> - adds pagination and sorting, 4) JpaRepository<Entity, ID> - JPA-specific methods. Example: public interface UserRepository extends JpaRepository<User, Long> { List<User> findByName(String name); }"
  },
  {
    "question": "What are query methods in Spring Data and how do they work?",
    "answer": "Query methods are repository interface methods that Spring Data automatically implements based on method names. Naming patterns include: 1) findBy + PropertyName, 2) countBy + PropertyName, 3) deleteBy + PropertyName, 4) existsBy + PropertyName. Keywords: And, Or, Between, LessThan, GreaterThan, Like, IgnoreCase, OrderBy. Example: List<User> findByAgeGreaterThanAndNameIgnoreCase(int age, String name)."
  },
  {
    "question": "How do you implement custom queries in Spring Data JPA?",
    "answer": "Implement custom queries using: 1) @Query annotation with JPQL: @Query(\"SELECT u FROM User u WHERE u.age > ?1\"), 2) Native SQL queries: @Query(value = \"SELECT * FROM users WHERE age > ?1\", nativeQuery = true), 3) Named queries defined in entity, 4) Criteria API for dynamic queries, 5) Custom repository implementations extending base repository interfaces for complex logic."
  },
  {
    "question": "What is pagination and sorting support in Spring Data?",
    "answer": "Spring Data provides built-in pagination and sorting through: 1) Pageable parameter in repository methods, 2) Page<T> return type containing content and metadata, 3) Sort parameter for ordering, 4) PageRequest.of(page, size, sort) for creating Pageable instances. Example: Page<User> findByAge(int age, Pageable pageable). Features include total elements, total pages, current page info, and navigation helpers."
  },
  {
    "question": "How do you implement auditing in Spring Data JPA?",
    "answer": "Enable auditing using @EnableJpaAuditing and: 1) @CreatedDate, @LastModifiedDate for timestamps, 2) @CreatedBy, @LastModifiedBy for user tracking, 3) Extend AbstractAuditable or implement Auditable interface, 4) Provide AuditorAware bean for current user resolution, 5) @EntityListeners(AuditingEntityListener.class) on entities. Automatically tracks creation/modification times and users without manual intervention."
  },
  {
    "question": "What are Spring Data specifications and how do you use them?",
    "answer": "Specifications provide a way to create dynamic queries using JPA Criteria API. Use JpaSpecificationExecutor interface and implement Specification<T>: 1) Create Specification objects for query conditions, 2) Combine specifications using and(), or(), not(), 3) Use with repository methods like findAll(Specification), 4) Build complex dynamic queries programmatically. Example: Specification<User> spec = (root, query, cb) -> cb.equal(root.get(\"name\"), name)."
  },
  {
    "question": "How do you work with multiple databases in Spring Data?",
    "answer": "Configure multiple databases by: 1) Define multiple DataSource beans with @Primary and @Qualifier, 2) Create separate @Configuration classes for each database, 3) Use @EnableJpaRepositories with basePackages and entityManagerFactoryRef, 4) Separate repository interfaces by package, 5) Configure transaction managers for each database. Each database requires its own EntityManagerFactory and repositories."
  },
  {
    "question": "What is Spring MVC and what are its core components?",
    "answer": "Spring MVC is a web framework implementing the Model-View-Controller pattern. Core components: 1) DispatcherServlet - front controller handling all requests, 2) Controller - handles specific requests and returns ModelAndView, 3) Model - data container passed to views, 4) View - renders model data (JSP, Thymeleaf), 5) ViewResolver - maps logical view names to actual views, 6) HandlerMapping - maps requests to controllers."
  },
  {
    "question": "How does the DispatcherServlet work in Spring MVC?",
    "answer": "DispatcherServlet acts as front controller in Spring MVC request processing: 1) Receives HTTP requests, 2) Consults HandlerMapping to find appropriate controller, 3) Invokes controller method through HandlerAdapter, 4) Controller returns ModelAndView, 5) ViewResolver resolves logical view name to actual view, 6) View renders model data, 7) Returns response to client. It orchestrates the entire request-response cycle."
  },
  {
    "question": "What are the different types of controllers in Spring MVC?",
    "answer": "Spring MVC supports various controller types: 1) @Controller - traditional MVC controllers returning view names, 2) @RestController - REST API controllers returning data directly, 3) @RequestMapping methods with different HTTP methods, 4) @GetMapping, @PostMapping, @PutMapping, @DeleteMapping for specific HTTP methods, 5) Functional controllers using RouterFunction (WebFlux style), 6) Implementing Controller interface (legacy approach)."
  },
  {
    "question": "How do you handle request parameters and path variables in Spring MVC?",
    "answer": "Handle request data using annotations: 1) @RequestParam for query parameters: @RequestParam String name, 2) @PathVariable for URL path variables: @PathVariable Long id, 3) @RequestBody for request body content, 4) @RequestHeader for HTTP headers, 5) @CookieValue for cookie values, 6) @ModelAttribute for form data binding, 7) HttpServletRequest for direct access. Use optional and default values: @RequestParam(defaultValue = \"default\")."
  },
  {
    "question": "What is data binding in Spring MVC and how does it work?",
    "answer": "Data binding automatically maps request parameters to Java objects using: 1) @ModelAttribute to bind form data to objects, 2) WebDataBinder for type conversion and validation, 3) PropertyEditors or Converters for custom type conversion, 4) @InitBinder for custom binding configuration, 5) Validation using @Valid or @Validated annotations. Spring automatically handles primitive types, collections, and complex objects."
  },
  {
    "question": "How do you implement validation in Spring MVC?",
    "answer": "Implement validation using: 1) JSR-303/380 Bean Validation annotations (@NotNull, @Size, @Email), 2) @Valid or @Validated on controller method parameters, 3) BindingResult to capture validation errors, 4) Custom validators implementing Validator interface, 5) @InitBinder with WebDataBinder.addValidators(), 6) Global validation configuration, 7) Client-side validation integration. Validation errors are available in BindingResult parameter."
  },
  {
    "question": "What are Spring MVC interceptors and how do you implement them?",
    "answer": "Interceptors provide cross-cutting functionality for web requests by implementing HandlerInterceptor interface: 1) preHandle() - before controller execution, 2) postHandle() - after controller but before view rendering, 3) afterCompletion() - after complete request processing. Register interceptors in WebMvcConfigurer.addInterceptors(). Use cases: authentication, logging, performance monitoring, request/response modification."
  },
  {
    "question": "How do you handle exceptions globally in Spring MVC?",
    "answer": "Handle exceptions globally using: 1) @ControllerAdvice with @ExceptionHandler methods for application-wide exception handling, 2) @ResponseStatus for mapping exceptions to HTTP status codes, 3) HandlerExceptionResolver implementations, 4) @ExceptionHandler in specific controllers for local handling, 5) Custom error pages with error.html templates, 6) ResponseEntityExceptionHandler for REST APIs with proper error responses."
  },
  {
    "question": "What is content negotiation in Spring MVC?",
    "answer": "Content negotiation determines response format based on client preferences using: 1) Accept header (application/json, application/xml), 2) URL path extension (.json, .xml), 3) Request parameter (?format=json), 4) ContentNegotiationConfigurer for configuration, 5) @RequestMapping(produces) to specify supported media types, 6) HttpMessageConverters for serialization/deserialization, 7) Multiple @RequestMapping methods for different content types."
  },
  {
    "question": "How do you configure view resolvers in Spring MVC?",
    "answer": "Configure view resolvers to map logical view names to actual views: 1) InternalResourceViewResolver for JSP: resolver.setPrefix(\"/WEB-INF/views/\"); resolver.setSuffix(\".jsp\"), 2) ThymeleafViewResolver for Thymeleaf templates, 3) FreeMarkerViewResolver for FreeMarker, 4) Multiple view resolvers with order priority, 5) BeanNameViewResolver for view beans, 6) ViewResolverRegistry in WebMvcConfigurer for Java configuration."
  },
  {
    "question": "What is the difference between @Controller and @RestController in Spring MVC?",
    "answer": "@Controller is used for traditional MVC applications returning view names, while @RestController combines @Controller and @ResponseBody for REST APIs. Key differences: 1) @Controller methods return view names (String) or ModelAndView, 2) @RestController methods return data directly (serialized to JSON/XML), 3) @RestController eliminates need for @ResponseBody on each method, 4) @Controller typically works with view technologies, 5) @RestController is designed for API endpoints."
  },
  {
    "question": "How do you implement file upload functionality in Spring MVC?",
    "answer": "Implement file upload using: 1) MultipartFile parameter in controller methods, 2) @RequestParam(\"file\") MultipartFile file, 3) Configure MultipartResolver bean (usually automatic in Spring Boot), 4) Set maximum file size limits in properties, 5) Use MultipartHttpServletRequest for multiple files, 6) Store files using file.transferTo() or process streams, 7) Validate file types and sizes, 8) Handle upload errors gracefully."
  },
  {
    "question": "What are Spring MVC themes and how do you implement them?",
    "answer": "Spring MVC themes allow customizable UI styling through: 1) ThemeResolver to determine current theme (cookies, sessions, fixed), 2) Theme properties files defining CSS/image resources, 3) ThemeChangeInterceptor for runtime theme switching, 4) ResourceBundleThemeSource for theme resource loading, 5) Theme-specific CSS and resource files, 6) <spring:theme> tag in JSP or equivalent in template engines. Enables user-selectable or dynamic UI themes."
  },
  {
    "question": "How do you implement internationalization (i18n) in Spring MVC?",
    "answer": "Implement i18n using: 1) LocaleResolver to determine user locale (AcceptHeaderLocaleResolver, SessionLocaleResolver), 2) Message properties files for different locales (messages_en.properties, messages_fr.properties), 3) MessageSource bean for loading messages, 4) LocaleChangeInterceptor for runtime locale switching, 5) <spring:message> tags in views, 6) @RequestParam(\"lang\") for locale switching, 7) CookieLocaleResolver for persistent locale storage."
  },
  {
    "question": "What are HTTP message converters in Spring MVC and how do they work?",
    "answer": "HTTP message converters handle serialization/deserialization between HTTP requests/responses and Java objects: 1) MappingJackson2HttpMessageConverter for JSON, 2) Jaxb2RootElementHttpMessageConverter for XML, 3) StringHttpMessageConverter for text, 4) FormHttpMessageConverter for form data, 5) Automatic selection based on Content-Type and Accept headers, 6) Custom converters implementing HttpMessageConverter, 7) Configuration through WebMvcConfigurer.configureMessageConverters()."
  },
  {
    "question": "How do you implement async processing in Spring MVC?",
    "answer": "Implement async processing using: 1) Return Callable<T> from controller methods for background processing, 2) DeferredResult<T> for async result setting from other threads, 3) @Async methods with CompletableFuture, 4) ResponseBodyEmitter for streaming responses, 5) SseEmitter for Server-Sent Events, 6) StreamingResponseBody for large file streaming, 7) Configure async support with AsyncConfigurer, 8) Set timeouts and exception handlers for async operations."
  },
  {
    "question": "What is CORS support in Spring MVC and how do you configure it?",
    "answer": "CORS (Cross-Origin Resource Sharing) allows cross-domain requests. Configure using: 1) @CrossOrigin annotation on controllers/methods, 2) WebMvcConfigurer.addCorsMappings() for global configuration, 3) CorsRegistry for mapping patterns and allowed origins, 4) Specify allowed headers, methods, and credentials, 5) Set max age for preflight requests, 6) Handle preflight OPTIONS requests, 7) Integration with Spring Security for secured endpoints."
  },
  {
    "question": "How do you test Spring MVC controllers?",
    "answer": "Test controllers using: 1) @WebMvcTest for slice testing with MockMvc, 2) MockMvc.perform() to simulate HTTP requests, 3) @MockBean to mock service dependencies, 4) TestRestTemplate for integration testing, 5) @SpringBootTest for full context testing, 6) Hamcrest matchers for assertions, 7) JSON path expressions for response validation, 8) @AutoConfigureMockMvc for MockMvc auto-configuration, 9) @WithMockUser for security testing."
  },
  {
    "question": "What are some best practices for Spring MVC application development?",
    "answer": "Best practices include: 1) Keep controllers thin with business logic in services, 2) Use proper HTTP status codes and methods, 3) Implement proper exception handling with @ControllerAdvice, 4) Validate input using Bean Validation, 5) Use DTOs for data transfer, 6) Implement pagination for large datasets, 7) Configure proper security with Spring Security, 8) Use caching for performance, 9) Write comprehensive tests, 10) Follow RESTful design principles, 11) Document APIs with Swagger/OpenAPI."
  },
  {
    "question": "How does Spring Boot differ from the traditional Spring Framework in terms of configuration?",
    "answer": "Spring Boot provides auto-configuration and convention over configuration, eliminating the need for extensive XML configuration files. It automatically configures components based on classpath dependencies, while traditional Spring requires manual configuration of beans, data sources, and other components through XML or Java configuration classes."
  },
  {
    "question": "What are the main advantages of using Spring Boot over traditional Spring Framework?",
    "answer": "Spring Boot offers rapid application development through auto-configuration, embedded servers (Tomcat, Jetty), starter dependencies that bundle related libraries, production-ready features via Actuator, and simplified deployment as executable JARs. It reduces boilerplate configuration and enables developers to focus on business logic rather than infrastructure setup."
  },
  {
    "question": "How does dependency injection work in the Spring Framework?",
    "answer": "Dependency injection in Spring works through the IoC container, which manages object creation and wiring. Dependencies can be injected via constructor injection (@Autowired on constructors), setter injection (@Autowired on setter methods), or field injection (@Autowired on fields). The container resolves dependencies at runtime and injects the appropriate beans."
  },
  {
    "question": "What are the different types of dependency injection supported by Spring?",
    "answer": "Spring supports three types of dependency injection: 1) Constructor injection - dependencies injected through class constructors (recommended), 2) Setter injection - dependencies injected through setter methods, 3) Field injection - dependencies injected directly into fields using @Autowired. Constructor injection is preferred for mandatory dependencies as it ensures immutability and fail-fast behavior."
  },
  {
    "question": "What is the difference between @Component, @Service, @Repository, and @Controller annotations?",
    "answer": "@Component is a generic stereotype annotation for any Spring-managed component. @Service is a specialization of @Component used for service layer classes containing business logic. @Repository is used for data access layer classes and provides exception translation. @Controller is used for web layer classes that handle HTTP requests. All are functionally equivalent but provide semantic meaning."
  },
  {
    "question": "How do you handle circular dependencies in Spring?",
    "answer": "Circular dependencies can be resolved by: 1) Using setter injection instead of constructor injection, 2) Using @Lazy annotation to delay bean initialization, 3) Redesigning the architecture to eliminate circular dependencies, 4) Using @PostConstruct for initialization logic, 5) Implementing ApplicationContextAware to manually resolve dependencies. Spring can handle circular dependencies with setter injection but not with constructor injection."
  },
  {
    "question": "What is the difference between singleton and prototype bean scopes in Spring?",
    "answer": "Singleton scope (default) creates one instance per Spring container and returns the same instance for all requests. Prototype scope creates a new instance every time the bean is requested. Singleton beans are eagerly initialized by default, while prototype beans are lazily initialized. Singleton is suitable for stateless beans, while prototype is used for stateful beans."
  },
  {
    "question": "How do you configure a Spring application using Java-based configuration?",
    "answer": "Java-based configuration uses @Configuration classes with @Bean methods: @Configuration public class AppConfig { @Bean public UserService userService() { return new UserServiceImpl(); } }. Enable component scanning with @ComponentScan, import other configurations with @Import, and use @PropertySource for external properties. This approach provides type safety and IDE support compared to XML configuration."
  },
  {
    "question": "What is the purpose of the @Qualifier annotation in Spring?",
    "answer": "@Qualifier is used to resolve ambiguity when multiple beans of the same type exist. It specifies which bean to inject by name: @Autowired @Qualifier(\"primaryDatabase\") DataSource dataSource. It can be used with @Autowired on fields, constructors, or methods. Custom qualifiers can be created using meta-annotations for more sophisticated bean selection."
  },
  {
    "question": "How does Spring's ApplicationContext differ from BeanFactory?",
    "answer": "ApplicationContext extends BeanFactory and provides additional features: 1) Automatic bean post-processor registration, 2) Message resource handling for i18n, 3) Event publication and listening, 4) Environment abstraction, 5) Application layer specific contexts (WebApplicationContext). BeanFactory provides basic IoC functionality, while ApplicationContext is the preferred container for most applications."
  },
  {
    "question": "What are Spring profiles and how do you use them for environment-specific configuration?",
    "answer": "Spring profiles allow environment-specific bean definitions and configurations. Use @Profile(\"dev\") on beans or configuration classes, activate profiles via spring.profiles.active property, command line arguments, or environment variables. Profile-specific property files (application-{profile}.properties) provide environment-specific settings. Profiles help manage different configurations for development, testing, and production environments."
  },
  {
    "question": "How do you implement custom validation in Spring using Bean Validation?",
    "answer": "Implement custom validation by: 1) Creating a custom annotation with @Constraint, 2) Implementing ConstraintValidator interface, 3) Using @Valid or @Validated on method parameters or class fields. Example: @NotEmpty, @Email, @Size. Custom validators can access other Spring beans through dependency injection for complex validation logic involving database checks or external services."
  },
  {
    "question": "What is Spring's Environment abstraction and how is it used?",
    "answer": "Environment abstraction provides access to profiles and properties from various sources including system properties, environment variables, and property files. Access via @Autowired Environment env or @Value annotations. It unifies property resolution and profile management, allowing applications to adapt behavior based on runtime environment without code changes."
  },
  {
    "question": "How do you implement internationalization (i18n) in Spring applications?",
    "answer": "Implement i18n using MessageSource bean with ResourceBundleMessageSource, property files for each locale (messages_en.properties, messages_fr.properties), LocaleResolver to determine user locale, and LocaleChangeInterceptor for runtime locale switching. Use MessageSource.getMessage() or <spring:message> tags in views to display localized messages."
  },
  {
    "question": "What is the purpose of @PostConstruct and @PreDestroy annotations?",
    "answer": "@PostConstruct marks a method to be executed after dependency injection is complete, useful for initialization logic that requires dependencies. @PreDestroy marks a method to be executed before bean destruction, useful for cleanup operations like closing connections or releasing resources. These annotations provide standard JSR-250 lifecycle callbacks independent of Spring APIs."
  },
  {
    "question": "How do you configure and use Spring's task execution and scheduling?",
    "answer": "Configure task execution with @EnableAsync and @Async annotations for asynchronous method execution. Use @EnableScheduling and @Scheduled for scheduled tasks with cron expressions, fixed delays, or fixed rates. Configure custom TaskExecutor beans for thread pool management. Example: @Scheduled(cron = \"0 0 12 * * ?\") for daily noon execution."
  },
  {
    "question": "What are the different ways to handle exceptions in Spring applications?",
    "answer": "Handle exceptions using: 1) @ExceptionHandler methods in controllers for controller-specific handling, 2) @ControllerAdvice for global exception handling across controllers, 3) HandlerExceptionResolver implementations for custom resolution logic, 4) @ResponseStatus for mapping exceptions to HTTP status codes, 5) ResponseEntityExceptionHandler for REST API error responses with proper HTTP status codes and error details."
  },
  {
    "question": "How does Spring's resource abstraction work?",
    "answer": "Spring's Resource abstraction provides a unified way to access resources from various locations using ResourceLoader interface. Resources can be loaded from classpath (classpath:), file system (file:), URLs (http:), or ServletContext. Use @Value(\"classpath:config.properties\") Resource resource or ResourceLoader.getResource() to access resources programmatically."
  },
  {
    "question": "What is the difference between @ImportResource and @Import annotations?",
    "answer": "@ImportResource imports XML configuration files into Java configuration classes: @ImportResource(\"classpath:beans.xml\"). @Import imports other @Configuration classes: @Import(DatabaseConfig.class). @ImportResource bridges XML and Java configuration, while @Import enables modular Java configuration by composing multiple configuration classes."
  },
  {
    "question": "How do you implement custom property editors in Spring?",
    "answer": "Implement custom property editors by extending PropertyEditorSupport and overriding setAsText() and getAsText() methods. Register using @InitBinder in controllers or CustomEditorConfigurer globally. Property editors convert string values to custom objects during data binding. Modern Spring applications prefer using Converter or Formatter interfaces with ConversionService for type conversion."
  },
  {
    "question": "What is Spring's FactoryBean interface and when would you use it?",
    "answer": "FactoryBean is a specialized bean that creates other beans. Implement FactoryBean<T> interface with getObject(), getObjectType(), and isSingleton() methods. Use when bean creation logic is complex, requires additional configuration, or when integrating third-party libraries. Spring creates the factory bean and uses it to create the actual target bean instances."
  },
  {
    "question": "How do you configure Spring to work with multiple data sources?",
    "answer": "Configure multiple data sources by: 1) Defining multiple DataSource beans with @Primary and @Qualifier annotations, 2) Creating separate configuration classes for each database, 3) Using @EnableJpaRepositories with basePackages and entityManagerFactoryRef, 4) Configuring separate transaction managers for each data source, 5) Using @Transactional with appropriate transaction manager names."
  },
  {
    "question": "What are Spring Boot starters and how do they simplify dependency management?",
    "answer": "Spring Boot starters are dependency descriptors that bundle commonly used libraries for specific functionality. Examples include spring-boot-starter-web (web applications), spring-boot-starter-data-jpa (JPA data access), spring-boot-starter-security (security). They provide curated, tested, and compatible dependency versions, reducing configuration overhead and dependency conflicts."
  },
  {
    "question": "How does Spring Boot's auto-configuration work internally?",
    "answer": "Auto-configuration uses @EnableAutoConfiguration to trigger AutoConfigurationImportSelector, which loads configuration classes listed in META-INF/spring.factories. Each auto-configuration class uses conditional annotations (@ConditionalOnClass, @ConditionalOnMissingBean) to determine applicability. Auto-configuration applies sensible defaults based on classpath contents and existing beans, providing convention-over-configuration benefits."
  },
  {
    "question": "What is the purpose of Spring Boot's @ConfigurationProperties annotation?",
    "answer": "@ConfigurationProperties enables type-safe configuration properties binding. It maps external configuration (properties files, environment variables) to POJOs with validation support. Example: @ConfigurationProperties(prefix = \"app.datasource\") maps app.datasource.* properties to class fields. Provides IDE auto-completion, validation, and centralized configuration management compared to individual @Value annotations."
  },
  {
    "question": "How do you create custom Spring Boot starters?",
    "answer": "Create custom starters by: 1) Creating auto-configuration classes with @Configuration and conditional annotations, 2) Listing them in META-INF/spring.factories, 3) Creating a starter module with dependencies, 4) Providing @ConfigurationProperties for customization, 5) Including spring-boot-autoconfigure dependency. Follow naming convention: {company}-spring-boot-starter-{name} for third-party starters."
  },
  {
    "question": "What is the difference between @SpringBootApplication and its constituent annotations?",
    "answer": "@SpringBootApplication is a convenience annotation combining @Configuration (marks class as configuration source), @EnableAutoConfiguration (enables auto-configuration), and @ComponentScan (enables component scanning). It provides sensible defaults for most applications but can be replaced with individual annotations for more control over configuration and scanning behavior."
  },
  {
    "question": "How do you implement health checks in Spring Boot applications?",
    "answer": "Implement health checks using Spring Boot Actuator with built-in indicators (database, disk space, JMS) exposed via /actuator/health endpoint. Create custom health indicators by implementing HealthIndicator interface or extending AbstractHealthIndicator. Configure health endpoint exposure and details visibility through management.endpoint.health properties. Health checks help monitor application status and dependencies."
  },
  {
    "question": "What are Spring Boot configuration classes and how do they differ from traditional Spring configuration?",
    "answer": "Spring Boot configuration classes use @Configuration with @Bean methods, similar to traditional Spring. However, Spring Boot provides auto-configuration that reduces manual configuration needs. Boot configuration classes often customize auto-configured beans rather than defining everything from scratch. @ConditionalOnMissingBean allows Boot's auto-configuration to be overridden selectively by user-defined beans."
  },
  {
    "question": "How do you implement custom metrics in Spring Boot applications?",
    "answer": "Implement custom metrics using Micrometer API with MeterRegistry. Create counters (Counter.builder(\"requests\").register(registry)), timers (@Timed annotation), and gauges (Gauge.builder(\"queue.size\").register(registry)). Metrics are exposed via /actuator/metrics endpoint and can be exported to monitoring systems like Prometheus, Grafana, or CloudWatch through Micrometer registry implementations."
  },
  {
    "question": "What is the purpose of Spring Boot's CommandLineRunner and ApplicationRunner interfaces?",
    "answer": "CommandLineRunner and ApplicationRunner provide hooks to execute code after the Spring Boot application context is loaded. CommandLineRunner.run(String... args) receives raw command-line arguments, while ApplicationRunner.run(ApplicationArguments args) provides structured access to arguments. Use for initialization tasks, data loading, or startup validations that require the full application context to be available."
  },
  {
    "question": "How do you configure logging in Spring Boot applications?",
    "answer": "Configure logging using application.properties with logging.level.* for log levels, logging.file.name for file output, and logging.pattern.* for custom patterns. Spring Boot uses Logback by default but supports Log4j2 and Java Util Logging. Create logback-spring.xml for advanced configuration with profile-specific settings and custom appenders. Use @Slf4j annotation with Lombok for easy logger injection."
  },
  {
    "question": "What are the different testing annotations available in Spring Boot?",
    "answer": "Spring Boot provides specialized testing annotations: @SpringBootTest (full integration tests), @WebMvcTest (web layer only), @DataJpaTest (JPA repositories), @JsonTest (JSON serialization), @WebFluxTest (reactive web layer), @MockBean (mock beans in context), @TestConfiguration (test-specific configuration), @ActiveProfiles (activate test profiles), and @DirtiesContext (reload context between tests)."
  },
  {
    "question": "How do you implement integration testing in Spring Boot?",
    "answer": "Implement integration tests using @SpringBootTest with webEnvironment options (MOCK, RANDOM_PORT, DEFINED_PORT). Use TestRestTemplate for testing REST APIs, @AutoConfigureMockMvc for MockMvc testing, @Testcontainers for real database testing, and @MockBean to mock external dependencies. Configure test-specific properties with @TestPropertySource and use profiles for test environments."
  },
  {
    "question": "What is the purpose of @MockBean vs @Mock in Spring Boot tests?",
    "answer": "@MockBean creates mocks and adds them to the Spring application context, replacing any existing beans of the same type. @Mock (from Mockito) creates standalone mocks outside the Spring context. Use @MockBean when you need to mock Spring-managed beans that are injected into other beans, and @Mock for unit testing individual classes without Spring context."
  },
  {
    "question": "How do you test Spring Boot applications with external dependencies?",
    "answer": "Test external dependencies using: 1) @MockBean to mock service clients, 2) WireMock for HTTP service simulation, 3) Testcontainers for real database/message broker testing, 4) @TestConfiguration for test-specific bean definitions, 5) Profiles to switch between real and mock implementations, 6) @ConditionalOnProperty to enable test implementations. This approach provides isolation while ensuring realistic testing scenarios."
  },
  {
    "question": "What are sliced tests in Spring Boot and when should you use them?",
    "answer": "Sliced tests load only specific parts of the application context for faster, focused testing. Examples include @WebMvcTest (web layer), @DataJpaTest (JPA layer), @JsonTest (JSON processing). Use sliced tests for unit testing specific layers without loading the entire application context, reducing test execution time and focusing on specific functionality while maintaining Spring features like dependency injection."
  },
  {
    "question": "How do you implement test data management in Spring Boot tests?",
    "answer": "Manage test data using: 1) @Sql for executing SQL scripts before/after tests, 2) @Transactional with @Rollback for automatic test data cleanup, 3) TestEntityManager for JPA entity manipulation in @DataJpaTest, 4) @DirtiesContext to reset application context between tests, 5) Test fixtures with @BeforeEach/@AfterEach, 6) Database migration tools like Flyway for consistent test database state."
  },
  {
    "question": "What is the difference between @SpringBootTest and @ExtendWith(SpringExtension.class)?",
    "answer": "@SpringBootTest includes @ExtendWith(SpringExtension.class) automatically and provides Spring Boot-specific testing features like auto-configuration and web environment setup. @ExtendWith(SpringExtension.class) is the basic JUnit 5 extension for Spring testing without Boot-specific features. Use @SpringBootTest for Boot applications and @ExtendWith(SpringExtension.class) for traditional Spring applications."
  },
  {
    "question": "How do you test Spring Boot auto-configuration?",
    "answer": "Test auto-configuration using @EnableAutoConfiguration in test configuration classes, ApplicationContextRunner for testing configuration behavior, @ConditionalOnProperty with test properties, @MockBean for dependencies, and custom @TestConfiguration classes. Verify that auto-configuration creates expected beans, respects conditional annotations, and can be overridden by user-defined beans."
  },
  {
    "question": "What are the best practices for Spring Boot application testing?",
    "answer": "Best practices include: 1) Use sliced tests for faster execution, 2) Mock external dependencies with @MockBean, 3) Use @TestPropertySource for test-specific configuration, 4) Implement both unit and integration tests, 5) Use Testcontainers for external service testing, 6) Keep tests independent and idempotent, 7) Use meaningful test names and organize tests logically, 8) Test error scenarios and edge cases, 9) Use @DirtiesContext sparingly for performance."
  },
  {
    "question": "How do you implement performance testing for Spring Boot applications?",
    "answer": "Implement performance testing using: 1) JMeter or Gatling for load testing, 2) Spring Boot Actuator metrics for monitoring, 3) @Timed annotations for method-level timing, 4) Micrometer Timer for custom measurements, 5) Profile-based configuration for performance test environments, 6) Database connection pool monitoring, 7) JVM profiling tools (JProfiler, YourKit), 8) Continuous performance testing in CI/CD pipelines."
  },
  {
    "question": "What is Spring Boot's approach to dependency management and version compatibility?",
    "answer": "Spring Boot uses a Bill of Materials (BOM) approach with spring-boot-dependencies to manage transitive dependency versions. The BOM ensures compatible versions across the entire dependency graph. Spring Boot starters inherit these managed versions, reducing version conflicts. Override managed versions carefully using properties like slf4j.version or explicit version declarations in dependencies."
  },
  {
    "question": "How do you troubleshoot Spring Boot application startup issues?",
    "answer": "Troubleshoot startup issues by: 1) Enabling debug logging (--debug flag or debug=true property), 2) Checking auto-configuration report for failed conditions, 3) Using @ConditionalOnBean/@ConditionalOnMissingBean debugging, 4) Reviewing dependency conflicts with mvn dependency:tree, 5) Checking classpath scanning and component registration, 6) Validating configuration properties binding, 7) Using Spring Boot Actuator's conditions endpoint."
  },
  {
    "question": "What are the memory and performance considerations when using Spring Framework?",
    "answer": "Memory and performance considerations include: 1) Singleton vs prototype bean scopes (singletons share memory), 2) Lazy initialization to reduce startup time, 3) Connection pooling for database access, 4) Caching strategies to reduce repeated computations, 5) Asynchronous processing for non-blocking operations, 6) Proper transaction management scope, 7) JVM tuning (heap size, GC settings), 8) Profile-specific resource allocation."
  },
  {
    "question": "How do you implement graceful shutdown in Spring Boot applications?",
    "answer": "Implement graceful shutdown using: 1) server.shutdown=graceful property, 2) spring.lifecycle.timeout-per-shutdown-phase for timeout configuration, 3) @PreDestroy methods for cleanup logic, 4) DisposableBean interface implementation, 5) Custom shutdown hooks with Runtime.addShutdownHook(), 6) Connection pool shutdown configuration, 7) Message broker connection cleanup, 8) In-flight request completion before shutdown."
  },
  {
    "question": "What are the security considerations specific to Spring Boot applications?",
    "answer": "Spring Boot security considerations include: 1) Securing Actuator endpoints in production, 2) Using HTTPS with proper SSL configuration, 3) Implementing proper authentication and authorization, 4) Securing configuration properties with encryption, 5) Regular dependency updates for security patches, 6) Proper CORS configuration, 7) Input validation and sanitization, 8) Secure session management, 9) Protection against common vulnerabilities (XSS, CSRF, SQL injection)."
  },
  {
    "question": "How do you monitor Spring Boot applications in production?",
    "answer": "Monitor production applications using: 1) Spring Boot Actuator endpoints for health and metrics, 2) Micrometer integration with monitoring systems (Prometheus, Grafana), 3) Application Performance Monitoring tools (New Relic, Dynatrace), 4) Centralized logging with ELK stack, 5) Custom health indicators for business metrics, 6) JVM monitoring (heap, GC, threads), 7) Database connection pool monitoring, 8) Alert configuration for critical metrics."
  },
  {
    "question": "What are the common pitfalls and anti-patterns in Spring Boot development?",
    "answer": "Common pitfalls include: 1) Overusing @Autowired field injection instead of constructor injection, 2) Creating circular dependencies, 3) Not using appropriate bean scopes, 4) Ignoring transaction boundaries, 5) Over-configuration instead of relying on auto-configuration, 6) Not securing Actuator endpoints, 7) Improper exception handling, 8) Not using profiles for environment-specific configuration, 9) Blocking operations in async methods, 10) Not implementing proper health checks."
  },
  {
    "question": "How do you implement dynamic access-control policies in Spring Security based on user attributes?",
    "answer": "Implement dynamic access control by creating custom AccessDecisionVoter or PermissionEvaluator implementations. Use @PreAuthorize with SpEL expressions that evaluate user attributes, roles, and contextual information. Define permission evaluators that check database-stored permissions and integrate with AttributeBasedAccessControl (ABAC) systems for complex policy evaluation."
  },
  {
    "question": "What are the steps to create a custom AccessDecisionVoter in Spring Security?",
    "answer": "Create a custom AccessDecisionVoter by implementing the AccessDecisionVoter interface with methods: supports(), vote(), and canHandle(). Override vote() to return ACCESS_GRANTED, ACCESS_DENIED, or ACCESS_ABSTAIN based on your custom logic. Register the voter in your security configuration using AccessDecisionManager and combine it with other voters using UnanimousBased, ConsensusBased, or AffirmativeBased strategies."
  },
  {
    "question": "How do you implement role hierarchy in Spring Security?",
    "answer": "Implement role hierarchy using RoleHierarchy interface. Create a RoleHierarchyImpl bean and define relationships like 'ROLE_ADMIN > ROLE_USER > ROLE_GUEST'. Configure it in your security setup so higher roles automatically inherit permissions of lower roles. This allows admins to access user resources without explicitly granting both roles, simplifying permission management."
  },
  {
    "question": "What is the difference between hasRole() and hasAuthority() in Spring Security?",
    "answer": "hasRole() checks for roles with 'ROLE_' prefix automatically added (hasRole('ADMIN') checks for 'ROLE_ADMIN'). hasAuthority() checks for exact authority strings without prefix manipulation. Use hasRole() for traditional role-based security and hasAuthority() for fine-grained permissions or when using custom authority naming conventions that don't follow the ROLE_ pattern."
  },
  {
    "question": "How do you configure Spring Security for stateless JWT authentication?",
    "answer": "Configure stateless JWT authentication by: 1) Disabling session creation with sessionCreationPolicy(STATELESS), 2) Creating JwtAuthenticationFilter to validate tokens, 3) Implementing JwtUtil for token generation/validation, 4) Configuring security to use JWT filter before UsernamePasswordAuthenticationFilter, 5) Storing user authorities in JWT claims for authorization decisions."
  },
  {
    "question": "What are the best practices for implementing multi-factor authentication (MFA) in Spring Security?",
    "answer": "Implement MFA by: 1) Creating custom authentication providers for each factor, 2) Using authentication success handlers to redirect to additional factor verification, 3) Storing partial authentication state securely, 4) Implementing time-based (TOTP) or SMS-based second factors, 5) Creating custom authentication tokens for multi-step processes, 6) Ensuring proper session management during MFA flow, 7) Providing fallback mechanisms for factor unavailability."
  },
  {
    "question": "How do you implement custom password policies in Spring Security?",
    "answer": "Implement custom password policies by: 1) Creating PasswordEncoder with validation logic, 2) Using Bean Validation annotations with custom validators, 3) Implementing PasswordPolicyEnforcer service for complexity rules, 4) Creating password history tracking to prevent reuse, 5) Setting up password expiration mechanisms, 6) Providing password strength meters in UI, 7) Configuring account lockout after failed attempts."
  },
  {
    "question": "What is the purpose of SecurityContextPersistenceFilter in Spring Security?",
    "answer": "SecurityContextPersistenceFilter manages the SecurityContext lifecycle across HTTP requests. It loads the SecurityContext from storage (usually HTTP session) at the beginning of request processing and saves it back after processing. This filter ensures authentication state persists between requests in stateful applications and properly cleans up the SecurityContext to prevent information leakage between users."
  },
  {
    "question": "How do you implement custom authentication providers in Spring Security?",
    "answer": "Create custom authentication providers by implementing AuthenticationProvider interface with authenticate() and supports() methods. Override authenticate() to perform custom authentication logic and return Authentication object on success. Register the provider using AuthenticationManagerBuilder.authenticationProvider(). Use for integrating with external authentication systems, LDAP, or custom authentication mechanisms."
  },
  {
    "question": "What are the security considerations when implementing remember-me functionality?",
    "answer": "Security considerations for remember-me include: 1) Using secure, HttpOnly cookies, 2) Implementing token-based approach instead of persistent login, 3) Setting appropriate cookie expiration times, 4) Using strong token generation with sufficient entropy, 5) Storing tokens securely with proper hashing, 6) Implementing token rotation on each use, 7) Providing logout functionality that clears remember-me tokens, 8) Monitoring for suspicious remember-me token usage."
  },
  {
    "question": "How do you configure Spring Security for LDAP authentication?",
    "answer": "Configure LDAP authentication by: 1) Adding spring-security-ldap dependency, 2) Configuring LDAP context source with server URL and credentials, 3) Setting up LDAP authentication provider with user search filters, 4) Configuring group search for role mapping, 5) Implementing custom UserDetailsContextMapper for attribute mapping, 6) Setting up connection pooling and timeout configurations, 7) Handling LDAP exceptions and fallback mechanisms."
  },
  {
    "question": "What is Spring Security's AuthenticationManager and how does it work?",
    "answer": "AuthenticationManager is the main interface for authentication in Spring Security. It coordinates multiple AuthenticationProvider instances to authenticate users. The ProviderManager implementation tries each provider in sequence until one successfully authenticates or all fail. It supports parent AuthenticationManager for delegation and provides authentication caching. Configure providers for different authentication mechanisms like database, LDAP, or custom authentication."
  },
  {
    "question": "How do you implement custom security expressions in Spring Security?",
    "answer": "Implement custom security expressions by: 1) Creating MethodSecurityExpressionHandler bean, 2) Extending SecurityExpressionRoot for custom expression methods, 3) Implementing PermissionEvaluator for hasPermission() expressions, 4) Registering custom expression evaluator in security configuration, 5) Using @PreAuthorize with custom expressions like @PreAuthorize('hasCustomPermission(#id)'), 6) Creating expression-based access control for complex business rules."
  },
  {
    "question": "What are the different ways to handle authentication failures in Spring Security?",
    "answer": "Handle authentication failures using: 1) AuthenticationFailureHandler for custom failure processing, 2) AuthenticationEntryPoint for unauthenticated requests, 3) AccessDeniedHandler for authorization failures, 4) Custom exception handling with @ControllerAdvice, 5) Failure URL configuration for form login, 6) Account lockout mechanisms after multiple failures, 7) Security event listeners for logging and monitoring, 8) Custom authentication success/failure handlers for different authentication types."
  },
  {
    "question": "How do you secure REST APIs with Spring Security using API keys?",
    "answer": "Secure REST APIs with API keys by: 1) Creating custom authentication filter to extract API keys from headers, 2) Implementing ApiKeyAuthenticationProvider to validate keys, 3) Storing API keys securely with proper hashing, 4) Configuring stateless security with sessionCreationPolicy(STATELESS), 5) Adding rate limiting and throttling per API key, 6) Implementing API key rotation mechanisms, 7) Providing different permission levels per API key, 8) Monitoring API key usage and suspicious activity."
  },
  {
    "question": "What is the role of GrantedAuthority in Spring Security?",
    "answer": "GrantedAuthority represents permissions granted to a user in Spring Security. It's a simple interface with getAuthority() method returning authority string. Authorities are used in access control decisions by voters and expressions. Common implementations include SimpleGrantedAuthority for basic string authorities and custom implementations for complex permission systems. Authorities are typically loaded by UserDetailsService and stored in Authentication object."
  },
  {
    "question": "How do you implement custom logout functionality in Spring Security?",
    "answer": "Implement custom logout by: 1) Creating LogoutSuccessHandler for custom logout processing, 2) Configuring LogoutFilter with custom logout URLs, 3) Implementing custom LogoutHandler for cleanup operations, 4) Setting up CSRF token handling for logout requests, 5) Clearing custom authentication tokens or sessions, 6) Invalidating remember-me tokens, 7) Redirecting to appropriate pages after logout, 8) Logging logout events for security monitoring."
  },
  {
    "question": "What are the security implications of using @AuthenticationPrincipal annotation?",
    "answer": "@AuthenticationPrincipal provides direct access to the authenticated user object in controller methods. Security implications include: 1) Potential information leakage if principal contains sensitive data, 2) Need to validate principal state before use, 3) Risk of modification if principal is mutable, 4) Serialization issues in distributed systems, 5) Ensure principal implementation follows security best practices, 6) Consider using DTOs instead of direct domain objects as principals."
  },
  {
    "question": "How do you configure Spring Security for integration with external OAuth2 providers?",
    "answer": "Configure OAuth2 integration by: 1) Adding spring-boot-starter-oauth2-client dependency, 2) Configuring client registrations in application.yml with client-id, client-secret, and provider details, 3) Setting up OAuth2LoginConfigurer in security configuration, 4) Implementing custom OAuth2UserService for user attribute mapping, 5) Configuring custom success/failure handlers, 6) Setting up proper redirect URIs, 7) Handling token refresh and storage, 8) Implementing logout with provider logout endpoints."
  },
  {
    "question": "What is the difference between authentication and authorization in Spring Security context?",
    "answer": "Authentication verifies user identity ('who you are') through credentials like username/password, tokens, or certificates. Authorization determines access permissions ('what you can do') based on authenticated user's roles and authorities. Authentication happens first and establishes security context, then authorization checks occur for each resource access. Spring Security handles both through separate but integrated mechanisms - AuthenticationManager for authentication and AccessDecisionManager for authorization."
  },
  {
    "question": "How do you implement database-backed user management in Spring Security?",
    "answer": "Implement database-backed user management by: 1) Creating User and Role entities with JPA annotations, 2) Implementing UserDetailsService to load users from database, 3) Creating UserRepository with custom query methods, 4) Implementing PasswordEncoder for secure password storage, 5) Setting up proper database schema with user-role relationships, 6) Creating user management controllers for CRUD operations, 7) Implementing user registration and password reset functionality, 8) Adding user audit trails and account status management."
  },
  {
    "question": "What are the best practices for handling sensitive data in Spring Security applications?",
    "answer": "Best practices include: 1) Never log sensitive data like passwords or tokens, 2) Use proper password hashing with BCrypt or Argon2, 3) Implement field-level encryption for sensitive database columns, 4) Use HTTPS for all communications, 5) Clear sensitive data from memory after use, 6) Implement proper session management and timeout, 7) Use secure random number generation for tokens, 8) Follow principle of least privilege for data access, 9) Implement proper audit logging without sensitive data exposure, 10) Regular security assessments and penetration testing."
  },
  {
    "question": "How do you configure Spring Security for WebSocket authentication?",
    "answer": "Configure WebSocket security by: 1) Enabling WebSocket message broker security with @EnableWebSocketSecurity, 2) Configuring message security with authorizeRequests() for different destinations, 3) Implementing custom authentication in WebSocket handshake, 4) Using SimpMessagingTemplate with security context, 5) Configuring CSRF protection for WebSocket connections, 6) Implementing custom security interceptors for WebSocket channels, 7) Handling authentication tokens in WebSocket headers, 8) Setting up proper CORS configuration for WebSocket connections."
  },
  {
    "question": "What is the purpose of DelegatingFilterProxy in Spring Security?",
    "answer": "DelegatingFilterProxy bridges servlet container and Spring application context by delegating filter calls to Spring-managed beans. It allows Spring Security filters to be registered as servlet filters while maintaining Spring dependency injection and lifecycle management. The proxy looks up target filter bean by name and delegates all filter operations to it, enabling integration of Spring Security filter chain with servlet container's filter mechanism."
  },
  {
    "question": "How do you implement custom password reset functionality with Spring Security?",
    "answer": "Implement password reset by: 1) Creating password reset token entity with expiration, 2) Generating secure random tokens for reset requests, 3) Sending reset emails with tokenized links, 4) Implementing token validation and expiration checking, 5) Creating reset password form with token verification, 6) Using proper password encoding for new passwords, 7) Invalidating used tokens after successful reset, 8) Implementing rate limiting for reset requests, 9) Logging password reset activities for security monitoring."
  },
  {
    "question": "What are the security considerations for implementing social login with Spring Security?",
    "answer": "Security considerations include: 1) Validating OAuth2 state parameter to prevent CSRF, 2) Properly handling OAuth2 error responses, 3) Implementing account linking for existing users, 4) Securing OAuth2 client credentials, 5) Handling user profile updates from social providers, 6) Implementing proper logout that includes social provider logout, 7) Managing token refresh and expiration, 8) Protecting against account enumeration attacks, 9) Implementing proper user consent and privacy controls, 10) Regular security updates for OAuth2 dependencies."
  },
  {
    "question": "How do you configure Spring Security for GraphQL endpoint security?",
    "answer": "Configure GraphQL security by: 1) Integrating Spring Security with GraphQL data fetchers, 2) Using @PreAuthorize annotations on GraphQL resolver methods, 3) Implementing custom GraphQL authentication mechanisms, 4) Configuring field-level security with custom directives, 5) Handling authentication context in GraphQL execution, 6) Implementing query complexity analysis to prevent DoS attacks, 7) Setting up proper CORS configuration for GraphQL endpoints, 8) Implementing rate limiting per query type, 9) Securing GraphQL schema introspection in production."
  },
  {
    "question": "What is the role of SecurityMetadataSource in Spring Security?",
    "answer": "SecurityMetadataSource provides security metadata (ConfigAttributes) for secured resources. It defines what security attributes are required to access specific resources like URLs or methods. FilterSecurityInterceptor uses SecurityMetadataSource to determine required authorities for access decisions. Common implementations include DefaultFilterInvocationSecurityMetadataSource for URL patterns and PrePostAnnotationSecurityMetadataSource for method annotations."
  },
  {
    "question": "How do you implement custom authentication tokens in Spring Security?",
    "answer": "Implement custom authentication tokens by: 1) Extending AbstractAuthenticationToken class, 2) Implementing getCredentials() and getPrincipal() methods, 3) Creating custom AuthenticationProvider to handle token validation, 4) Implementing custom authentication filter to extract tokens from requests, 5) Configuring security filter chain to use custom filter, 6) Handling token serialization for session storage if needed, 7) Implementing proper token validation and expiration logic."
  },
  {
    "question": "What are the different session creation policies in Spring Security?",
    "answer": "Session creation policies include: 1) ALWAYS - always create HTTP session, 2) IF_REQUIRED - create session if needed (default), 3) NEVER - never create session but use existing one, 4) STATELESS - no session management, suitable for REST APIs with token authentication. Configure using sessionCreationPolicy() in HttpSecurity. STATELESS is recommended for REST APIs, while IF_REQUIRED works for traditional web applications with form authentication."
  },
  {
    "question": "How do you implement account lockout mechanisms in Spring Security?",
    "answer": "Implement account lockout by: 1) Creating failed login attempt tracking in database, 2) Implementing custom AuthenticationFailureHandler to count failures, 3) Modifying UserDetailsService to check account lockout status, 4) Creating scheduled tasks to automatically unlock accounts after time period, 5) Implementing manual unlock functionality for administrators, 6) Adding lockout notifications to users, 7) Configuring different lockout thresholds for different user types, 8) Logging lockout events for security monitoring."
  },
  {
    "question": "What is the purpose of AuthenticationSuccessHandler in Spring Security?",
    "answer": "AuthenticationSuccessHandler defines custom behavior after successful authentication. It allows customization of redirect logic, session management, security event logging, and user experience. Common use cases include redirecting users to different pages based on roles, updating last login timestamps, clearing failed login attempts, setting up user sessions with additional attributes, and triggering business logic after login. Implement onAuthenticationSuccess() method for custom logic."
  },
  {
    "question": "How do you configure Spring Security for microservices with service-to-service authentication?",
    "answer": "Configure service-to-service authentication by: 1) Using JWT tokens for stateless authentication between services, 2) Implementing OAuth2 client credentials flow for service authentication, 3) Using mutual TLS (mTLS) for service identity verification, 4) Creating service-specific API keys with proper scoping, 5) Implementing service discovery integration with security, 6) Using API gateways for centralized authentication, 7) Configuring different security contexts for user vs service requests, 8) Implementing proper token propagation between services."
  },
  {
    "question": "What are the security best practices for Spring Security in production environments?",
    "answer": "Production security best practices include: 1) Use HTTPS everywhere with proper SSL configuration, 2) Implement proper session management with secure cookies, 3) Configure security headers (HSTS, CSP, X-Frame-Options), 4) Use strong password policies and multi-factor authentication, 5) Implement proper logging and monitoring without exposing sensitive data, 6) Regular security updates and dependency scanning, 7) Implement rate limiting and DDoS protection, 8) Use secrets management systems for credentials, 9) Configure proper CORS policies, 10) Regular security assessments and penetration testing."
  },
  {
    "question": "How do you implement custom security event listeners in Spring Security?",
    "answer": "Implement security event listeners by: 1) Creating classes implementing ApplicationListener<AbstractAuthenticationEvent>, 2) Using @EventListener annotation on methods, 3) Listening for specific events like AuthenticationSuccessEvent, AuthenticationFailureEvent, 4) Implementing custom security events by extending AbstractAuthenticationEvent, 5) Publishing custom events using ApplicationEventPublisher, 6) Configuring async event processing for performance, 7) Implementing proper error handling in event listeners, 8) Using events for security monitoring, audit logging, and alerting."
  },
  {
    "question": "What is the difference between @Secured and @PreAuthorize annotations?",
    "answer": "@Secured supports only role-based security with simple string comparisons and uses RoleVoter for access decisions. @PreAuthorize supports SpEL expressions, method parameter access, complex authorization logic, and custom permission evaluators. @PreAuthorize is more flexible and powerful, allowing expressions like @PreAuthorize('hasRole(\"ADMIN\") and #id == authentication.name'). Use @Secured for simple role checks and @PreAuthorize for complex authorization requirements."
  },
  {
    "question": "How do you configure Spring Security for handling different authentication mechanisms in the same application?",
    "answer": "Handle multiple authentication mechanisms by: 1) Configuring multiple authentication providers in AuthenticationManager, 2) Using different security filter chains for different URL patterns, 3) Implementing custom authentication filters for each mechanism, 4) Using AuthenticationManagerResolver for dynamic provider selection, 5) Configuring different entry points for different authentication types, 6) Implementing proper authentication converter chains, 7) Using composite authentication providers, 8) Handling authentication precedence and fallback mechanisms."
  },
  {
    "question": "What is the role of AccessDecisionManager in Spring Security authorization?",
    "answer": "AccessDecisionManager makes final authorization decisions by coordinating multiple AccessDecisionVoter instances. It supports three strategies: AffirmativeBased (grants access if any voter approves), ConsensusBased (majority vote), and UnanimousBased (requires all voters to approve or abstain). Each voter examines the secured resource, authentication, and configuration attributes to cast ACCESS_GRANTED, ACCESS_DENIED, or ACCESS_ABSTAIN votes. Customize by implementing custom voters for business-specific authorization logic."
  },
  {
    "question": "How do you implement custom security annotations in Spring Security?",
    "answer": "Create custom security annotations by: 1) Defining annotation with @Target and @Retention, 2) Creating custom MethodSecurityMetadataSource to parse annotations, 3) Implementing custom AccessDecisionVoter or PermissionEvaluator for annotation logic, 4) Registering custom metadata source in security configuration, 5) Using @PreAuthorize with custom SpEL functions, 6) Creating annotation processors for compile-time validation, 7) Implementing proper error handling for annotation processing, 8) Documentation and testing of custom security annotations."
  },
  {
    "question": "What are the considerations for implementing security in Spring Boot reactive applications?",
    "answer": "Reactive security considerations include: 1) Using WebFluxSecurity instead of WebSecurity, 2) Implementing ReactiveUserDetailsService for user loading, 3) Using ServerHttpSecurity for configuration, 4) Handling security context propagation in reactive streams, 5) Implementing custom reactive authentication managers, 6) Using ServerAccessDeniedHandler and ServerAuthenticationEntryPoint, 7) Configuring CORS for reactive endpoints, 8) Implementing reactive JWT authentication filters, 9) Handling backpressure in security filters, 10) Testing reactive security with WebTestClient."
  },
  {
    "question": "How do you configure Spring Security for handling API versioning with different security requirements?",
    "answer": "Handle API versioning security by: 1) Using multiple SecurityFilterChain beans with different URL patterns (/api/v1/**, /api/v2/**), 2) Implementing version-specific authentication providers, 3) Configuring different security requirements per API version, 4) Using custom authentication converters for version-specific token formats, 5) Implementing backward compatibility for deprecated authentication methods, 6) Setting up proper deprecation warnings and migration guides, 7) Using feature flags for gradual security migration, 8) Implementing version-specific rate limiting and monitoring."
  },
  {
    "question": "What is the purpose of SecurityContextRepository in Spring Security?",
    "answer": "SecurityContextRepository manages SecurityContext persistence across requests. HttpSessionSecurityContextRepository stores context in HTTP session, while NullSecurityContextRepository provides stateless behavior. Custom implementations can store context in databases, caches, or custom storage systems. It handles context loading at request start and saving at request end, enabling different storage strategies for various application architectures like microservices or distributed systems."
  },
  {
    "question": "How do you implement custom authentication entry points in Spring Security?",
    "answer": "Implement custom authentication entry points by: 1) Creating class implementing AuthenticationEntryPoint interface, 2) Overriding commence() method to handle unauthenticated requests, 3) Implementing different responses for AJAX vs regular requests, 4) Configuring entry point in HttpSecurity configuration, 5) Handling different content types (JSON, HTML, XML), 6) Implementing proper error responses with security headers, 7) Adding logging and monitoring for authentication attempts, 8) Providing user-friendly error messages without information disclosure."
  },
  {
    "question": "What are the security implications of using method-level caching with Spring Security?",
    "answer": "Method-level caching security implications include: 1) Cached results may bypass authorization checks on subsequent calls, 2) Security context changes might not invalidate cached results, 3) Cached data might contain sensitive information accessible to unauthorized users, 4) Cache keys should not expose sensitive information, 5) Implement cache eviction on user role/permission changes, 6) Use security-aware cache key generation, 7) Consider per-user caching for sensitive operations, 8) Monitor cache access patterns for security anomalies, 9) Implement proper cache isolation between users."
  },
  {
    "question": "How do you configure Spring Security for handling time-based access control?",
    "answer": "Implement time-based access control by: 1) Creating custom AccessDecisionVoter that checks current time, 2) Using @PreAuthorize with time-based SpEL expressions, 3) Implementing PermissionEvaluator with temporal logic, 4) Creating time-based security metadata source, 5) Using custom authentication providers with time validation, 6) Implementing session timeout based on time-of-day policies, 7) Creating scheduled tasks to update user permissions, 8) Using cron expressions in security annotations for recurring time patterns, 9) Implementing proper timezone handling for global applications."
  },
  {
    "question": "What is the role of FilterChainProxy in Spring Security?",
    "answer": "FilterChainProxy is the main filter that delegates to SecurityFilterChain instances based on request matching. It manages multiple filter chains, handles filter ordering, provides debug logging, and ensures proper security context handling. Each SecurityFilterChain contains ordered security filters for specific URL patterns. FilterChainProxy enables having different security configurations for different parts of the application and is registered as 'springSecurityFilterChain' bean."
  },
  {
    "question": "How do you implement custom password validation in Spring Security?",
    "answer": "Implement custom password validation by: 1) Creating custom PasswordEncoder with validation logic, 2) Using Bean Validation annotations (@ValidPassword) with custom validators, 3) Implementing PasswordPolicyService for complex rules, 4) Creating password strength evaluators, 5) Implementing password history checking to prevent reuse, 6) Using regular expressions for complexity requirements, 7) Implementing dictionary-based password checking, 8) Creating user-friendly validation messages, 9) Implementing client-side password strength meters, 10) Regular updates to password policies based on security best practices."
  },
  {
    "question": "What are the best practices for implementing security testing in Spring Security applications?",
    "answer": "Security testing best practices include: 1) Using @WithMockUser and @WithUserDetails for authentication testing, 2) Testing authorization with different user roles and permissions, 3) Using MockMvc with Spring Security test support, 4) Implementing integration tests for complete authentication flows, 5) Testing security configurations with @SpringBootTest, 6) Using security-focused test slices like @WebMvcTest with security, 7) Testing CSRF protection and security headers, 8) Implementing penetration testing for security vulnerabilities, 9) Using automated security scanning tools, 10) Regular security assessments and code reviews."
  },
  {
    "question": "How do you handle security in Spring Boot applications with multiple data sources?",
    "answer": "Handle multi-datasource security by: 1) Configuring separate UserDetailsService for each data source, 2) Using custom authentication providers for different user stores, 3) Implementing datasource-specific authorization logic, 4) Using @Transactional with specific transaction managers for security operations, 5) Configuring separate security contexts for different application modules, 6) Implementing proper user migration between data sources, 7) Using federated authentication for unified user experience, 8) Implementing proper audit logging across data sources, 9) Ensuring consistent security policies across all data sources."
  },
  {
    "question": "How do you implement custom authentication success and failure handlers in Spring Security?",
    "answer": "Create custom handlers by implementing AuthenticationSuccessHandler and AuthenticationFailureHandler interfaces. Success handlers can redirect users based on roles, update login timestamps, or trigger business logic. Failure handlers can log attempts, implement account lockout, or provide custom error responses. Configure them in HttpSecurity using successHandler() and failureHandler() methods."
  },
  {
    "question": "What is the purpose of Spring Security's UserDetailsService and how do you implement a custom one?",
    "answer": "UserDetailsService loads user-specific data during authentication. Implement by creating a class that implements UserDetailsService interface with loadUserByUsername() method. This method should query your user repository, create UserDetails object with username, password, and authorities. It's the bridge between Spring Security and your user data storage, enabling custom user authentication logic."
  },
  {
    "question": "How do you implement custom password policies and validation in Spring Security?",
    "answer": "Implement custom password policies by creating PasswordEncoder implementations with validation logic, using Bean Validation annotations with custom validators, implementing PasswordPolicyEnforcer service for complexity rules, creating password history tracking, setting up password expiration mechanisms, and providing password strength meters in UI. Configure different policies for different user types."
  },
  {
    "question": "What are Spring Security's authentication providers and how do you create custom ones?",
    "answer": "Authentication providers handle specific authentication mechanisms. Create custom providers by implementing AuthenticationProvider interface with authenticate() and supports() methods. Examples include LDAP providers, database providers, or external API providers. Register providers using AuthenticationManagerBuilder.authenticationProvider(). Multiple providers can be chained for different authentication methods."
  },
  {
    "question": "How do you implement multi-factor authentication (MFA) using Spring Security?",
    "answer": "Implement MFA by creating custom authentication providers for each factor, using authentication success handlers to redirect to additional verification steps, storing partial authentication state securely, implementing TOTP or SMS-based second factors, creating custom authentication tokens for multi-step processes, ensuring proper session management during MFA flow, and providing fallback mechanisms for factor unavailability."
  },
  {
    "question": "What is Spring Security's AccessDecisionManager and how does it work with voters?",
    "answer": "AccessDecisionManager makes final authorization decisions by coordinating AccessDecisionVoter instances. Voters examine secured resources, authentication, and configuration attributes to cast ACCESS_GRANTED, ACCESS_DENIED, or ACCESS_ABSTAIN votes. Three strategies exist: AffirmativeBased (any approval grants access), ConsensusBased (majority vote), and UnanimousBased (all must approve or abstain)."
  },
  {
    "question": "How do you implement custom security expressions and permission evaluators in Spring Security?",
    "answer": "Create custom security expressions by implementing MethodSecurityExpressionHandler, extending SecurityExpressionRoot for custom methods, implementing PermissionEvaluator for hasPermission() expressions, registering custom evaluator in security configuration, and using @PreAuthorize with custom expressions. This enables complex business rule-based authorization beyond simple role checking."
  },
  {
    "question": "What are the different session management strategies in Spring Security?",
    "answer": "Session management strategies include: sessionCreationPolicy(ALWAYS) - always create sessions, IF_REQUIRED - create if needed (default), NEVER - don't create but use existing, STATELESS - no session management. Configure session fixation protection, concurrent session control with maximumSessions(), and session timeout. STATELESS is preferred for REST APIs with token authentication."
  },
  {
    "question": "How do you implement custom security filters in Spring Security filter chain?",
    "answer": "Create custom filters by extending GenericFilterBean or OncePerRequestFilter, implementing doFilter() or doFilterInternal() methods. Add filters using HttpSecurity.addFilterBefore(), addFilterAfter(), or addFilterAt() methods. Custom filters can handle authentication, authorization, logging, or request modification. Ensure proper filter ordering and exception handling."
  },
  {
    "question": "What is Spring Security's SecurityMetadataSource and how is it used?",
    "answer": "SecurityMetadataSource provides security metadata (ConfigAttributes) for secured resources, defining required authorities for access decisions. FilterSecurityInterceptor uses it to determine access requirements. Implementations include DefaultFilterInvocationSecurityMetadataSource for URL patterns and PrePostAnnotationSecurityMetadataSource for method annotations. Custom implementations enable dynamic security metadata resolution."
  },
  {
    "question": "How do you implement account lockout mechanisms in Spring Security?",
    "answer": "Implement account lockout by tracking failed login attempts in database, creating custom AuthenticationFailureHandler to count failures, modifying UserDetailsService to check lockout status, creating scheduled tasks for automatic unlock, implementing manual unlock for administrators, adding lockout notifications, configuring different thresholds for user types, and logging lockout events for security monitoring."
  },
  {
    "question": "What are Spring Security events and how do you implement custom event listeners?",
    "answer": "Spring Security publishes authentication events like AuthenticationSuccessEvent and AuthenticationFailureEvent. Implement listeners using @EventListener annotation or ApplicationListener interface. Custom events can extend AbstractAuthenticationEvent. Use ApplicationEventPublisher to publish custom events. Events enable security monitoring, audit logging, and triggering business logic on authentication state changes."
  },
  {
    "question": "How do you implement role hierarchy in Spring Security?",
    "answer": "Implement role hierarchy using RoleHierarchy interface with RoleHierarchyImpl. Define relationships like 'ROLE_ADMIN > ROLE_USER > ROLE_GUEST' where higher roles inherit lower role permissions. Configure RoleHierarchyVoter or use with method security. This allows administrators to access user resources without explicitly granting multiple roles, simplifying permission management."
  },
  {
    "question": "What is Spring Security's remember-me functionality and how do you implement it securely?",
    "answer": "Remember-me functionality allows persistent authentication across browser sessions. Implement using token-based or persistent login approaches. Security considerations include using secure HttpOnly cookies, implementing token rotation, setting appropriate expiration times, using strong token generation, storing tokens securely with hashing, providing logout functionality that clears tokens, and monitoring for suspicious usage patterns."
  },
  {
    "question": "How do you integrate Spring Security with external authentication providers like LDAP or Active Directory?",
    "answer": "Integrate with LDAP by adding spring-security-ldap dependency, configuring LDAP context source with server details, setting up LDAP authentication provider with user search filters, configuring group search for role mapping, implementing custom UserDetailsContextMapper for attribute mapping, setting up connection pooling and timeout configurations, and handling LDAP exceptions with fallback mechanisms."
  },
  {
    "question": "What are the security considerations for implementing WebSocket authentication in Spring Boot?",
    "answer": "WebSocket security challenges include unauthorized access (no Same Origin Policy enforcement), CSRF attacks, data interception, DoS attacks, message authorization, session management, and legacy protocol handling. Implement authentication in handshake, use WSS for encryption, configure CSRF protection, implement connection limits, validate message permissions, and maintain session integrity across long connections."
  },
  {
    "question": "How do you implement API key authentication in Spring Security?",
    "answer": "Implement API key authentication by creating custom authentication filter to extract keys from headers, implementing ApiKeyAuthenticationProvider for validation, storing keys securely with hashing, configuring stateless security, adding rate limiting per key, implementing key rotation mechanisms, providing different permission levels per key, and monitoring key usage for suspicious activity."
  },
  {
    "question": "What is the difference between @Secured and @PreAuthorize annotations in method security?",
    "answer": "@Secured supports only role-based security with simple string comparisons using RoleVoter. @PreAuthorize supports SpEL expressions, method parameter access, complex authorization logic, and custom permission evaluators. @PreAuthorize is more flexible, allowing expressions like @PreAuthorize('hasRole(\"ADMIN\") and #id == authentication.name'). Use @Secured for simple role checks and @PreAuthorize for complex requirements."
  },
  {
    "question": "How do you implement time-based access control in Spring Security?",
    "answer": "Implement time-based access control by creating custom AccessDecisionVoter that checks current time, using @PreAuthorize with time-based SpEL expressions, implementing PermissionEvaluator with temporal logic, creating time-based security metadata source, using custom authentication providers with time validation, implementing session timeout based on time-of-day policies, and creating scheduled tasks to update permissions."
  },
  {
    "question": "What are the best practices for Spring Security configuration in production environments?",
    "answer": "Production best practices include: using HTTPS everywhere, implementing proper session management with secure cookies, configuring security headers (HSTS, CSP, X-Frame-Options), using strong password policies and MFA, implementing proper logging without exposing sensitive data, regular security updates and dependency scanning, implementing rate limiting and DDoS protection, using secrets management systems, configuring proper CORS policies, and conducting regular security assessments."
  },
  {
    "question": "How do you configure Spring Boot DevTools for optimal development experience?",
    "answer": "Configure DevTools by adding spring-boot-devtools dependency, enabling automatic restart on classpath changes, configuring LiveReload for browser refresh, setting custom restart triggers, excluding certain paths from monitoring using spring.devtools.restart.exclude, configuring remote debugging capabilities, setting up remote update for deployed applications, and disabling DevTools in production builds automatically."
  },
  {
    "question": "What are the performance implications of using Spring Boot DevTools?",
    "answer": "DevTools uses two classloaders: base classloader for third-party JARs (unchanged) and restart classloader for application classes (reloaded on changes). This is faster than full JVM restart but slower than no restart. Memory usage increases due to dual classloaders. LiveReload adds slight overhead. DevTools automatically disables in production, so performance impact is development-only."
  },
  {
    "question": "How do you configure remote development capabilities with Spring Boot DevTools?",
    "answer": "Configure remote development by including DevTools in deployed application, setting spring.devtools.remote.secret property for security, using RemoteSpringApplication to connect to remote instance, configuring remote debugging with spring.devtools.remote.debug.enabled=true, setting up tunnel connections through proxy settings, and enabling hot-swapping of classes in remote environments for development efficiency."
  },
  {
    "question": "What is the difference between @ConfigurationProperties and @Value annotations?",
    "answer": "@ConfigurationProperties enables type-safe binding of related properties to POJOs with validation support, IDE auto-completion, and centralized configuration management. @Value injects individual property values and supports SpEL expressions but lacks type safety and validation. Use @ConfigurationProperties for grouped related properties and @Value for simple individual property injection."
  },
  {
    "question": "How do you implement custom property sources in Spring Boot?",
    "answer": "Implement custom property sources by creating classes that extend PropertySource, implementing getProperty() method to resolve property values, registering property sources using @PropertySource annotation or PropertySourcesPlaceholderConfigurer, creating custom PropertySourceLoader for different file formats, and adding property sources programmatically through ApplicationContextInitializer or EnvironmentPostProcessor."
  },
  {
    "question": "What is property resolution order in Spring Boot and how does it work?",
    "answer": "Spring Boot resolves properties in specific order (highest to lowest precedence): command line arguments, Java system properties, OS environment variables, profile-specific properties (application-{profile}.properties), application properties, @PropertySource annotations, default properties. This hierarchical approach allows environment-specific overrides without changing application code."
  },
  {
    "question": "How do you implement property validation and type conversion in Spring Boot?",
    "answer": "Implement property validation using @ConfigurationProperties with Bean Validation annotations (@NotNull, @Valid, @Min, @Max), creating custom validators, using @Validated annotation on configuration classes, implementing Converter or PropertyEditor for custom type conversion, and using ConversionService for complex type transformations. Spring Boot automatically performs basic type conversion."
  },
  {
    "question": "What are Spring Boot configuration processors and how do you create custom ones?",
    "answer": "Configuration processors generate metadata for IDE auto-completion and validation. Create custom processors by implementing ConfigurationMetadataAnnotationProcessor, generating spring-configuration-metadata.json files, using @ConfigurationProperties annotation with proper JavaDoc, creating custom annotation processors for specialized configuration patterns, and providing hints for IDE integration."
  },
  {
    "question": "How do you implement conditional property loading in Spring Boot?",
    "answer": "Implement conditional property loading using @ConditionalOnProperty annotation to load beans based on property values, @Profile annotation for environment-specific properties, @ConditionalOnExpression for complex SpEL-based conditions, custom @Conditional implementations for advanced logic, and PropertySourcesPlaceholderConfigurer for dynamic property resolution based on runtime conditions."
  },
  {
    "question": "What is the difference between application.properties and application.yml formats?",
    "answer": "Both serve the same purpose but different formats: application.properties uses key-value pairs (server.port=8080), while application.yml uses hierarchical YAML structure. YAML advantages: more readable for complex configurations, supports lists and nested objects naturally, less verbose. Properties advantages: simpler syntax, wider tool support, less sensitive to indentation errors."
  },
  {
    "question": "How do you handle property encryption and decryption in Spring Boot?",
    "answer": "Handle property encryption using Spring Cloud Config encryption features with {cipher} prefix, implementing custom PropertySourceLoader for encrypted properties, using Jasypt library for transparent encryption/decryption, creating custom EnvironmentPostProcessor for decryption logic, storing encryption keys securely, and implementing key rotation mechanisms for enhanced security."
  },
  {
    "question": "What are Spring Boot startup events and how do you handle them?",
    "answer": "Spring Boot publishes various startup events: ApplicationStartingEvent (very early), ApplicationEnvironmentPreparedEvent (environment ready), ApplicationContextInitializedEvent (context created), ApplicationPreparedEvent (context loaded), ApplicationStartedEvent (context refreshed), ApplicationReadyEvent (ready to serve), ApplicationFailedEvent (startup failed). Handle using @EventListener or ApplicationListener implementations."
  },
  {
    "question": "How do you implement custom ApplicationContext events in Spring Boot?",
    "answer": "Create custom events by extending ApplicationEvent, publish events using ApplicationEventPublisher.publishEvent(), create listeners using @EventListener annotation or ApplicationListener interface, implement async event processing with @Async, handle event ordering with @Order annotation, create conditional listeners with SpEL expressions, and implement event filtering based on source or payload."
  },
  {
    "question": "What is the difference between synchronous and asynchronous event processing in Spring?",
    "answer": "Synchronous events block the publisher until all listeners complete, ensuring immediate processing and error propagation. Asynchronous events (@Async) execute in separate threads, providing better performance and non-blocking behavior but with delayed processing and complex error handling. Choose based on requirements for immediate consistency versus performance and scalability."
  },
  {
    "question": "How do you implement event-driven architecture patterns in Spring Boot?",
    "answer": "Implement event-driven architecture using ApplicationEvents for intra-application communication, Spring Cloud Stream for inter-service messaging, message brokers (RabbitMQ, Kafka) for reliable messaging, event sourcing patterns with event stores, CQRS (Command Query Responsibility Segregation) for read/write separation, saga patterns for distributed transactions, and event scheduling for temporal workflows."
  },
  {
    "question": "What are the best practices for handling application events in Spring Boot?",
    "answer": "Best practices include: keeping event payloads lightweight, implementing proper error handling in listeners, using async processing for non-critical operations, avoiding circular event dependencies, implementing event ordering when necessary, using conditional listeners to reduce unnecessary processing, monitoring event processing performance, implementing event replay mechanisms for reliability, and documenting event contracts."
  },
  {
    "question": "How do you implement event sourcing patterns in Spring Boot applications?",
    "answer": "Implement event sourcing by creating event store for persistent event storage, defining domain events as immutable objects, implementing aggregate roots that apply events, creating event publishers for domain events, building read models from event streams, implementing event replay capabilities, handling event versioning and migration, and using Spring Data for event persistence and querying."
  },
  {
    "question": "What is the role of ApplicationRunner and CommandLineRunner in Spring Boot?",
    "answer": "ApplicationRunner and CommandLineRunner provide hooks to execute code after Spring Boot application context is loaded. CommandLineRunner receives raw String arguments, while ApplicationRunner provides structured ApplicationArguments. Use for initialization tasks, data loading, startup validations, or triggering business logic that requires full application context availability."
  },
  {
    "question": "How do you implement graceful application shutdown in Spring Boot?",
    "answer": "Implement graceful shutdown using server.shutdown=graceful property, configuring spring.lifecycle.timeout-per-shutdown-phase for timeout, implementing @PreDestroy methods for cleanup logic, using DisposableBean interface, creating custom shutdown hooks with Runtime.addShutdownHook(), configuring connection pool shutdown, cleaning up message broker connections, and ensuring in-flight request completion."
  },
  {
    "question": "What are Spring Boot configuration slices and how do you use them for testing?",
    "answer": "Configuration slices are test annotations that load only specific parts of application context: @WebMvcTest (web layer), @DataJpaTest (JPA repositories), @JsonTest (JSON processing), @WebFluxTest (reactive web). They provide faster, focused testing by auto-configuring only relevant components, reducing test execution time while maintaining Spring features like dependency injection."
  },
  {
    "question": "How do you implement custom auto-configuration in Spring Boot?",
    "answer": "Create custom auto-configuration by defining @Configuration classes with conditional annotations (@ConditionalOnClass, @ConditionalOnMissingBean), listing them in META-INF/spring.factories file, providing @ConfigurationProperties for customization, implementing proper conditional logic for when configuration applies, creating starter modules with dependencies, and following Spring Boot auto-configuration naming conventions."
  },
  {
    "question": "What are the debugging techniques for Spring Boot auto-configuration issues?",
    "answer": "Debug auto-configuration using --debug flag or debug=true property to see auto-configuration report, checking conditions that failed or succeeded, using @ConditionalOnBean/@ConditionalOnMissingBean debugging, reviewing dependency conflicts with mvn dependency:tree, validating classpath scanning and component registration, checking configuration properties binding, and using Spring Boot Actuator's conditions endpoint."
  },
  {
    "question": "How do you implement custom health indicators for Spring Boot Actuator?",
    "answer": "Create custom health indicators by implementing HealthIndicator interface with health() method, returning Health.up() or Health.down() with details, using AbstractHealthIndicator for simplified implementation, registering as Spring beans with @Component, grouping health indicators for different audiences, implementing reactive health indicators for WebFlux, and configuring health endpoint visibility and details."
  },
  {
    "question": "What are the security considerations for Spring Boot Actuator endpoints?",
    "answer": "Secure Actuator endpoints by using different management port, enabling Spring Security authentication, configuring access control with management.endpoints.web.exposure settings, excluding sensitive endpoints in production, using HTTPS for management endpoints, implementing role-based access (@PreAuthorize), setting up network restrictions, disabling endpoints by default (management.endpoints.enabled-by-default=false), and monitoring endpoint access."
  },
  {
    "question": "How do you implement custom metrics and monitoring in Spring Boot applications?",
    "answer": "Implement custom metrics using Micrometer API with MeterRegistry, creating counters (Counter.builder().register()), timers (@Timed annotation), and gauges (Gauge.builder().register()), adding custom tags for dimensionality, exporting to monitoring systems (Prometheus, Grafana), implementing business metrics, monitoring application performance, and setting up alerting based on metric thresholds."
  },
  {
    "question": "What are the performance optimization strategies for Spring Boot applications?",
    "answer": "Optimization strategies include: profiling with tools like VisualVM or YourKit, implementing caching strategies (Spring Cache, Redis), optimizing database queries and connection pooling, using async processing for long-running tasks, configuring JVM settings (heap size, GC), implementing proper logging levels, minimizing auto-configuration overhead, optimizing Spring context startup, using lazy initialization where appropriate, and monitoring with APM tools."
  },
  {
    "question": "How do you implement distributed tracing in Spring Boot microservices?",
    "answer": "Implement distributed tracing using Spring Cloud Sleuth for automatic instrumentation, integrating with Zipkin for trace collection and visualization, configuring sampling rates (spring.sleuth.sampler.probability), adding custom spans for business operations, propagating trace context between services, implementing trace correlation IDs, exporting traces to various backends (Jaeger, Zipkin), and monitoring trace performance and errors."
  },
  {
    "question": "What are the deployment strategies for Spring Boot applications in containerized environments?",
    "answer": "Deployment strategies include: creating optimized Docker images with multi-stage builds, using base images with appropriate Java versions, implementing health checks and readiness probes, configuring resource limits and requests, using Kubernetes deployments with rolling updates, implementing blue-green or canary deployments, setting up horizontal pod autoscaling, configuring persistent volumes for stateful components, and implementing proper logging and monitoring."
  },
  {
    "question": "How do you implement circuit breaker patterns in Spring Boot applications?",
    "answer": "Implement circuit breaker using Resilience4j library with @CircuitBreaker annotation, configuring failure thresholds and timeout settings, implementing fallback methods with @Recover, monitoring circuit breaker state through Actuator endpoints, combining with retry mechanisms (@Retry), implementing bulkhead patterns for resource isolation, configuring different circuit breakers for different services, and setting up alerts for circuit breaker state changes."
  },
  {
    "question": "What are the best practices for Spring Boot application logging and monitoring?",
    "answer": "Best practices include: using appropriate log levels (ERROR, WARN, INFO, DEBUG), implementing structured logging with JSON format, adding correlation IDs for request tracing, avoiding logging sensitive information, using async logging for performance, configuring log rotation and retention, implementing centralized logging (ELK stack), monitoring application metrics with Micrometer, setting up alerting for critical issues, and conducting regular log analysis for insights."
  },
  {
    "question": "How do you implement token-based authentication using Spring Security without using JWT?",
    "answer": "Implement token-based authentication by creating custom authentication tokens, storing them in a database or cache (like Redis), implementing a custom AuthenticationProvider to validate tokens, creating a custom filter to extract tokens from requests, and managing token expiration and invalidation. Use secure random token generation and associate tokens with user sessions."
  },
  {
    "question": "What is the difference between stateful and stateless authentication in Spring Security?",
    "answer": "Stateful authentication maintains session state on the server (typically using HTTP sessions), while stateless authentication doesn't store any session information on the server. Stateful uses cookies/session IDs, while stateless typically uses tokens like JWT. Stateless is more scalable for distributed systems but requires token validation on each request. Stateful provides better security control but complicates horizontal scaling."
  },
  {
    "question": "How do you implement custom authentication success and failure URLs in Spring Security?",
    "answer": "Configure custom URLs using HttpSecurity: .formLogin().loginPage(\"/custom-login\").defaultSuccessUrl(\"/dashboard\", true).failureUrl(\"/login-error\"). You can also implement AuthenticationSuccessHandler and AuthenticationFailureHandler for complex logic: .successHandler(customSuccessHandler).failureHandler(customFailureHandler). This allows for role-based redirects and custom error handling."
  },
  {
    "question": "What are the security implications of using @AuthenticationPrincipal in Spring Security?",
    "answer": "@AuthenticationPrincipal provides direct access to the authenticated user object in controller methods. Security implications include potential information leakage if principal contains sensitive data, need to validate principal state before use, risk of modification if principal is mutable, serialization issues in distributed systems, and ensuring principal implementation follows security best practices. Consider using DTOs instead of direct domain objects as principals."
  },
  {
    "question": "How do you implement OAuth2 client credentials flow in Spring Security?",
    "answer": "Configure OAuth2 client credentials by adding spring-security-oauth2-client dependency, defining client registration in application.yml with grant-type: client_credentials, creating OAuth2AuthorizedClientManager bean, using @RegisteredOAuth2AuthorizedClient in controllers, and implementing OAuth2AuthorizedClientProvider for automatic token management. This flow is used for service-to-service authentication without user interaction."
  },
  {
    "question": "What is the role of OAuth2AuthorizedClientManager in Spring Security?",
    "answer": "OAuth2AuthorizedClientManager coordinates the overall flow of authorizing OAuth2 clients. It manages OAuth2AuthorizedClient instances, handles authorization grants through OAuth2AuthorizedClientProvider, manages token refresh, handles authorization failures, and provides integration with reactive and servlet environments. It acts as the central component for OAuth2 client authorization workflows."
  },
  {
    "question": "How do you implement custom OAuth2 token validation in Spring Security?",
    "answer": "Implement custom token validation by creating a custom ReactiveJwtDecoder or JwtDecoder, implementing custom JwtValidator for additional validation rules, creating custom OAuth2TokenValidator, configuring custom introspection endpoints, implementing custom JwtAuthenticationConverter for claims mapping, and handling token validation errors with custom exception handling."
  },
  {
    "question": "What are the security considerations for implementing OAuth2 in microservices?",
    "answer": "Security considerations include: using proper token validation at each service, implementing token relay for service-to-service calls, securing inter-service communication with mutual TLS, managing token propagation and refresh, implementing proper scope validation, handling token expiration gracefully, securing OAuth2 configuration and secrets, implementing audit logging for OAuth2 events, and ensuring proper CORS configuration for OAuth2 endpoints."
  },
  {
    "question": "How do you configure CSRF protection for specific endpoints while disabling it for others?",
    "answer": "Configure selective CSRF protection using: http.csrf().ignoringAntMatchers(\"/api/**\") to disable for specific paths, or create multiple SecurityFilterChain beans with different CSRF configurations, use @Order to prioritize configurations, implement custom RequestMatcher for complex logic, configure CSRF for different URL patterns, and ensure proper CSRF token handling for protected endpoints."
  },
  {
    "question": "What is the difference between CookieCsrfTokenRepository and HttpSessionCsrfTokenRepository?",
    "answer": "CookieCsrfTokenRepository stores CSRF tokens in cookies (client-side), making them accessible to JavaScript and supporting stateless applications. HttpSessionCsrfTokenRepository stores tokens in HTTP sessions (server-side), providing better security but requiring session state. Cookie-based is suitable for SPA applications, while session-based is better for traditional web applications with server-side rendering."
  },
  {
    "question": "How do you implement CSRF protection in a Spring Boot REST API consumed by a JavaScript frontend?",
    "answer": "Configure CSRF with CookieCsrfTokenRepository: .csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse()), create endpoint to provide CSRF token to frontend, configure CORS to allow credentials, implement JavaScript to read CSRF token from cookie and include in request headers, handle CSRF token refresh, and ensure proper error handling for CSRF failures."
  },
  {
    "question": "What are the best practices for managing CSRF tokens in Spring Security?",
    "answer": "Best practices include: using secure, HttpOnly cookies when possible, implementing token rotation on each request, setting appropriate token expiration times, validating tokens on state-changing operations only, implementing proper error handling for invalid tokens, ensuring tokens are transmitted over HTTPS, clearing tokens on logout, implementing BREACH protection, and monitoring for CSRF attack attempts."
  },
  {
    "question": "How do you access the current user's SecurityContext in different layers of a Spring application?",
    "answer": "Access SecurityContext using: SecurityContextHolder.getContext().getAuthentication() in any layer, @AuthenticationPrincipal in controllers, SecurityContextHolder.getContext() in services, implementing SecurityContextHolderAwareRequestWrapper for servlet access, using SecurityEvaluationContextExtension for SpEL expressions, and ensuring proper thread context propagation for async operations."
  },
  {
    "question": "What are the different strategies for storing SecurityContext in Spring Security?",
    "answer": "SecurityContext storage strategies include: MODE_THREADLOCAL (default) - stores context in ThreadLocal, MODE_INHERITABLETHREADLOCAL - allows child threads to inherit context, MODE_GLOBAL - single context for entire JVM, and custom implementations for specialized requirements. Choose based on application architecture and threading model requirements."
  },
  {
    "question": "How do you propagate SecurityContext to child threads in Spring Security?",
    "answer": "Propagate SecurityContext to child threads using: SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL), DelegatingSecurityContextRunnable/Callable wrappers, @Async with SecurityContextHolder configuration, CompletableFuture.supplyAsync with security context transfer, and implementing custom ThreadPoolTaskExecutor with SecurityContextHolderAwareScheduledThreadPoolExecutor."
  },
  {
    "question": "What security patterns should be followed when developing Spring Boot applications for production?",
    "answer": "Production security patterns include: implementing defense in depth with multiple security layers, using secure defaults and principle of least privilege, implementing proper input validation and output encoding, securing sensitive configuration with encryption, implementing comprehensive logging and monitoring, using HTTPS everywhere, implementing rate limiting and DDoS protection, regular security testing and code reviews, keeping dependencies updated, and implementing incident response procedures."
  },
  {
    "question": "How do you secure Spring Boot application configuration in production environments?",
    "answer": "Secure configuration by: using environment variables for sensitive data, implementing configuration encryption with Jasypt or Spring Cloud Config, storing secrets in dedicated secret management systems (HashiCorp Vault, AWS Secrets Manager), using file system permissions to protect config files, implementing configuration validation, avoiding hardcoded secrets in code, using profile-specific configurations, and implementing configuration change auditing."
  },
  {
    "question": "What are the best practices for deploying Spring Boot applications securely in containerized environments?",
    "answer": "Container security best practices include: using minimal base images (Alpine, Distroless), running containers as non-root users, implementing proper secrets management in Kubernetes, using network policies for container communication, scanning images for vulnerabilities, implementing resource limits and security contexts, using read-only file systems where possible, implementing proper logging and monitoring, and regular security updates for base images and dependencies."
  },
  {
    "question": "How do you implement security headers in Spring Boot applications?",
    "answer": "Implement security headers using Spring Security's HeadersConfigurer: http.headers().frameOptions().deny().contentTypeOptions().httpStrictTransportSecurity().cacheControl().and().contentSecurityPolicy(). Common headers include X-Frame-Options, X-Content-Type-Options, Strict-Transport-Security, Content-Security-Policy, X-XSS-Protection, and Referrer-Policy. Configure headers based on application requirements and security needs."
  },
  {
    "question": "What are the security considerations for Spring Boot applications using WebSockets?",
    "answer": "WebSocket security considerations include: implementing proper authentication during handshake, validating origin headers to prevent CSRF, using secure WebSocket connections (WSS), implementing message-level authorization, managing connection limits to prevent DoS, implementing proper session management, validating all incoming messages, implementing rate limiting for messages, and ensuring proper error handling without information disclosure."
  },
  {
    "question": "How do you implement secure session management in Spring Boot applications?",
    "answer": "Implement secure session management by: configuring session timeout appropriately, using secure session cookies (HttpOnly, Secure, SameSite), implementing session fixation protection, using strong session ID generation, implementing concurrent session control, clearing sessions on logout, storing minimal data in sessions, implementing session monitoring and audit logging, and using distributed session storage for scalability."
  },
  {
    "question": "What are the performance implications of different Spring Security configurations?",
    "answer": "Performance implications include: authentication provider choice affects lookup speed, session vs stateless authentication impacts memory usage, filter chain order affects processing time, password encoder strength impacts CPU usage, access decision managers affect authorization speed, security context storage strategy impacts thread performance, and database vs in-memory user stores affect authentication latency. Profile and monitor to optimize for your specific use case."
  },
  {
    "question": "How do you implement audit logging for security events in Spring Boot applications?",
    "answer": "Implement audit logging by: using Spring Boot Actuator's audit events, implementing custom ApplicationEventListener for security events, creating AuditEventRepository for storing audit data, logging authentication and authorization events, implementing custom audit annotations with AOP, using structured logging for security events, implementing log analysis and alerting, ensuring audit logs are tamper-proof, and complying with regulatory requirements for audit trails."
  },
  {
    "question": "What are the common Spring Security vulnerabilities and how do you prevent them?",
    "answer": "Common vulnerabilities include: session fixation (use session fixation protection), CSRF attacks (enable CSRF protection), clickjacking (use X-Frame-Options), XSS attacks (implement proper output encoding), SQL injection (use parameterized queries), insecure direct object references (implement proper authorization), security misconfiguration (follow security hardening guides), using components with known vulnerabilities (regular dependency updates), and insufficient logging (implement comprehensive audit logging)."
  },
  {
    "question": "How do you implement Blue-Green deployment for Spring Boot applications?",
    "answer": "Implement Blue-Green deployment by: maintaining two identical production environments (Blue and Green), deploying new versions to the inactive environment, performing comprehensive testing on the inactive environment, using load balancer or reverse proxy to switch traffic, implementing database migration strategies, ensuring zero-downtime deployments, implementing rollback procedures, monitoring application health during switches, and automating the deployment pipeline with CI/CD tools."
  },
  {
    "question": "What are the best practices for monitoring Spring Boot applications in production?",
    "answer": "Monitoring best practices include: using Spring Boot Actuator for health checks and metrics, implementing APM tools (New Relic, AppDynamics), setting up centralized logging with ELK stack, monitoring JVM metrics (heap, GC, threads), implementing custom business metrics, setting up alerting for critical thresholds, monitoring database performance, implementing distributed tracing for microservices, monitoring infrastructure metrics, and creating comprehensive dashboards."
  },
  {
    "question": "How do you configure SSL/TLS termination for Spring Boot applications?",
    "answer": "Configure SSL/TLS by: generating or obtaining SSL certificates, configuring server.ssl properties in application.yml, implementing SSL termination at load balancer or reverse proxy, using Let's Encrypt for automatic certificate renewal, configuring HTTP to HTTPS redirects, implementing HSTS headers, managing certificate stores and keystores, monitoring certificate expiration, and ensuring proper cipher suite configuration for security."
  },
  {
    "question": "What are the strategies for database migration in Spring Boot production deployments?",
    "answer": "Database migration strategies include: using Flyway or Liquibase for version-controlled migrations, implementing backward-compatible schema changes, using blue-green database deployments, implementing rolling updates with database compatibility, creating comprehensive backup and rollback procedures, testing migrations in staging environments, implementing migration monitoring and alerting, using feature flags for database-dependent features, and coordinating application and database deployments."
  },
  {
    "question": "How do you implement graceful shutdown in Spring Boot applications?",
    "answer": "Implement graceful shutdown using: server.shutdown=graceful property, configuring spring.lifecycle.timeout-per-shutdown-phase, implementing @PreDestroy methods for cleanup, using DisposableBean interface for resource cleanup, implementing custom ApplicationListener for ContextClosedEvent, ensuring in-flight requests complete before shutdown, closing database connections and external service connections properly, and implementing health check endpoints for deployment orchestration."
  },
  {
    "question": "How do you implement custom password validation in Spring Security?",
    "answer": "Implement custom password validation by creating custom PasswordEncoder with validation logic, using Bean Validation annotations (@ValidPassword) with custom validators, implementing PasswordPolicyService for complex rules, creating password strength evaluators, implementing password history checking to prevent reuse, using regular expressions for complexity requirements, implementing dictionary-based password checking, creating user-friendly validation messages, implementing client-side password strength meters, and regular updates to password policies based on security best practices."
  },
  {
    "question": "What are the best practices for implementing security testing in Spring Security applications?",
    "answer": "Security testing best practices include: using @WithMockUser and @WithUserDetails for authentication testing, testing authorization with different user roles and permissions, using MockMvc with Spring Security test support, implementing integration tests for complete authentication flows, testing security configurations with @SpringBootTest, using security-focused test slices like @WebMvcTest with security, testing CSRF protection and security headers, implementing penetration testing for security vulnerabilities, using automated security scanning tools, and regular security assessments and code reviews."
  },
  {
    "question": "How do you handle security in Spring Boot applications with multiple data sources?",
    "answer": "Handle multi-datasource security by: configuring separate UserDetailsService for each data source, using custom authentication providers for different user stores, implementing datasource-specific authorization logic, using @Transactional with specific transaction managers for security operations, configuring separate security contexts for different application modules, implementing proper user migration between data sources, using federated authentication for unified user experience, implementing proper audit logging across data sources, and ensuring consistent security policies across all data sources."
  },
  {
    "question": "How do you implement custom application events in Spring Boot?",
    "answer": "Create custom events by extending ApplicationEvent, publish events using ApplicationEventPublisher.publishEvent(), create listeners using @EventListener annotation or ApplicationListener interface, implement async event processing with @Async, handle event ordering with @Order annotation, create conditional listeners with SpEL expressions, implement event filtering based on source or payload, handle exceptions in event listeners, and use transaction-bound events with @TransactionalEventListener."
  },
  {
    "question": "What is the difference between synchronous and asynchronous event processing in Spring?",
    "answer": "Synchronous events block the publisher until all listeners complete, ensuring immediate processing and error propagation. Asynchronous events (@Async) execute in separate threads, providing better performance and non-blocking behavior but with delayed processing and complex error handling. Choose based on requirements for immediate consistency versus performance and scalability needs."
  },
  {
    "question": "How do you implement event-driven architecture patterns in Spring Boot?",
    "answer": "Implement event-driven architecture using ApplicationEvents for intra-application communication, Spring Cloud Stream for inter-service messaging, message brokers (RabbitMQ, Kafka) for reliable messaging, event sourcing patterns with event stores, CQRS (Command Query Responsibility Segregation) for read/write separation, saga patterns for distributed transactions, event scheduling for temporal workflows, and domain events for business logic decoupling."
  },
  {
    "question": "How do you handle application startup events in Spring Boot?",
    "answer": "Spring Boot publishes various startup events: ApplicationStartingEvent (very early), ApplicationEnvironmentPreparedEvent (environment ready), ApplicationContextInitializedEvent (context created), ApplicationPreparedEvent (context loaded), ApplicationStartedEvent (context refreshed), ApplicationReadyEvent (ready to serve), ApplicationFailedEvent (startup failed). Handle using @EventListener or ApplicationListener implementations."
  },
  {
    "question": "What are the best practices for handling application events in Spring Boot?",
    "answer": "Best practices include: keeping event payloads lightweight, implementing proper error handling in listeners, using async processing for non-critical operations, avoiding circular event dependencies, implementing event ordering when necessary, using conditional listeners to reduce unnecessary processing, monitoring event processing performance, implementing event replay mechanisms for reliability, and documenting event contracts clearly."
  },
  {
    "question": "How do you implement event sourcing patterns in Spring Boot applications?",
    "answer": "Implement event sourcing by creating event store for persistent event storage, defining domain events as immutable objects, implementing aggregate roots that apply events, creating event publishers for domain events, building read models from event streams, implementing event replay capabilities, handling event versioning and migration, using Spring Data for event persistence and querying, and implementing snapshot mechanisms for performance optimization."
  },
  {
    "question": "How do you create web applications with Spring Boot using Thymeleaf?",
    "answer": "Create web applications by adding spring-boot-starter-thymeleaf dependency, creating HTML templates in src/main/resources/templates, using Thymeleaf syntax with th: attributes, implementing controllers that return view names, using Model to pass data to templates, configuring template properties (caching, mode), implementing form handling with th:object and th:field, handling validation errors, creating fragments for reusable components, and using layout dialects for consistent page structure."
  },
  {
    "question": "What are the differences between @Controller and @RestController in Spring Boot?",
    "answer": "@Controller is used for traditional MVC applications returning view names, while @RestController combines @Controller and @ResponseBody for REST APIs. Key differences: @Controller methods return view names (String) or ModelAndView, @RestController methods return data directly (serialized to JSON/XML), @RestController eliminates need for @ResponseBody on each method, @Controller typically works with view technologies, @RestController is designed for API endpoints."
  },
  {
    "question": "How do you implement form validation in Spring Boot web applications?",
    "answer": "Implement form validation using Bean Validation annotations (@NotBlank, @Email, @Size) on model objects, using @Valid annotation in controller methods, handling BindingResult for validation errors, creating custom validators implementing ConstraintValidator, displaying errors in templates using th:errors, implementing client-side validation for better UX, using @Validated for group validation, and creating custom validation messages in messages.properties."
  },
  {
    "question": "How do you handle file uploads in Spring Boot web applications?",
    "answer": "Handle file uploads using MultipartFile parameter in controller methods, configuring multipart properties (spring.servlet.multipart.max-file-size), validating file types and sizes, storing files using file.transferTo() or processing streams, implementing progress tracking for large files, handling multiple file uploads, using @RequestParam for file arrays, implementing security checks for uploaded files, and providing download functionality for stored files."
  },
  {
    "question": "What is the role of ModelAndView in Spring Boot web applications?",
    "answer": "ModelAndView combines model data and view name in a single object, allowing controllers to return both data and view information together. It's useful when you need to set view names dynamically, add multiple model attributes programmatically, handle redirects with flash attributes, or when migrating from older Spring MVC patterns. Modern Spring Boot applications often prefer returning String view names and using Model parameter instead."
  },
  {
    "question": "How do you implement internationalization (i18n) in Spring Boot web applications?",
    "answer": "Implement i18n using MessageSource bean with ResourceBundleMessageSource, creating property files for each locale (messages_en.properties, messages_fr.properties), configuring LocaleResolver to determine user locale, using LocaleChangeInterceptor for runtime locale switching, accessing messages in templates with #{messages.key}, implementing locale-based formatting for dates and numbers, and providing locale selection UI components."
  },
  {
    "question": "How do you customize error pages in Spring Boot web applications?",
    "answer": "Customize error pages by creating templates in error/ directory (error/404.html, error/500.html), implementing ErrorController interface for custom error handling, using @ControllerAdvice for global exception handling, configuring error attributes with server.error properties, creating custom error views with Thymeleaf, handling different content types (HTML, JSON), and providing user-friendly error messages while hiding sensitive information."
  },
  {
    "question": "What are Spring Boot starters and how do they work?",
    "answer": "Spring Boot starters are dependency descriptors that bundle commonly used libraries for specific functionality. Examples include spring-boot-starter-web (web applications), spring-boot-starter-data-jpa (JPA data access), spring-boot-starter-security (security). They provide curated, tested, and compatible dependency versions, reducing configuration overhead and dependency conflicts by following opinionated defaults and auto-configuration principles."
  },
  {
    "question": "How do you create custom Spring Boot starters?",
    "answer": "Create custom starters by: creating auto-configuration classes with @Configuration and conditional annotations, listing them in META-INF/spring.factories, creating a starter module with dependencies, providing @ConfigurationProperties for customization, including spring-boot-autoconfigure dependency, following naming convention: {company}-spring-boot-starter-{name} for third-party starters, and documenting configuration options and usage examples."
  },
  {
    "question": "What is Spring Boot auto-configuration and how does it work?",
    "answer": "Auto-configuration uses @EnableAutoConfiguration to trigger AutoConfigurationImportSelector, which loads configuration classes listed in META-INF/spring.factories. Each auto-configuration class uses conditional annotations (@ConditionalOnClass, @ConditionalOnMissingBean) to determine applicability. Auto-configuration applies sensible defaults based on classpath contents and existing beans, providing convention-over-configuration benefits."
  },
  {
    "question": "How do you override Spring Boot auto-configuration?",
    "answer": "Override auto-configuration by: defining your own beans (which take precedence due to @ConditionalOnMissingBean), using @EnableAutoConfiguration(exclude) to exclude specific configurations, creating custom configuration classes with @Configuration, using application properties to customize auto-configured components, implementing custom conditional logic, and providing alternative implementations that satisfy the same conditions."
  },
  {
    "question": "What are configuration properties in Spring Boot and how do you use them?",
    "answer": "@ConfigurationProperties enables type-safe configuration properties binding. It maps external configuration (properties files, environment variables) to POJOs with validation support. Example: @ConfigurationProperties(prefix = \"app.datasource\") maps app.datasource.* properties to class fields. Provides IDE auto-completion, validation, and centralized configuration management compared to individual @Value annotations."
  },
  {
    "question": "How do you implement property validation in Spring Boot?",
    "answer": "Implement property validation using @ConfigurationProperties with Bean Validation annotations (@NotNull, @Valid, @Min, @Max), creating custom validators, using @Validated annotation on configuration classes, implementing Converter or PropertyEditor for custom type conversion, and using ConversionService for complex type transformations. Spring Boot automatically performs basic type conversion and validation."
  },
  {
    "question": "What is property binding in Spring Boot and how does it work?",
    "answer": "Property binding automatically maps configuration from various sources (properties files, environment variables, command line arguments) to application components. Spring Boot supports relaxed binding (different naming conventions), type conversion, nested properties, collections binding, and validation. Use @ConfigurationProperties for type-safe binding and @Value for simple property injection."
  },
  {
    "question": "How do you handle configuration for different environments in Spring Boot?",
    "answer": "Handle environment-specific configuration using profiles with profile-specific property files (application-{profile}.properties), environment variables, command line arguments, external configuration files, Spring Cloud Config for centralized management, conditional beans with @Profile, and property precedence rules where environment-specific values override default ones."
  },
  {
    "question": "What are the debugging techniques for Spring Boot applications?",
    "answer": "Debug Spring Boot applications using: --debug flag for auto-configuration reports, Spring Boot DevTools for hot reloading, IDE debugging with breakpoints, Spring Boot Actuator endpoints for application insights, logging configuration for detailed output, remote debugging capabilities, profiling tools for performance analysis, and testing with different profiles and configurations."
  },
  {
    "question": "How do you implement health checks in Spring Boot applications?",
    "answer": "Implement health checks using Spring Boot Actuator with built-in indicators (database, disk space, JMS) exposed via /actuator/health endpoint. Create custom health indicators by implementing HealthIndicator interface or extending AbstractHealthIndicator. Configure health endpoint exposure and details visibility through management.endpoint.health properties for application monitoring."
  },
  {
    "question": "What are Spring Boot Actuator endpoints and how do you use them?",
    "answer": "Actuator endpoints provide production-ready monitoring and management features: /actuator/health for health status, /actuator/metrics for application metrics, /actuator/info for application information, /actuator/env for environment properties, /actuator/loggers for logging configuration, /actuator/threaddump for thread analysis. Configure endpoint exposure and security through management properties."
  },
  {
    "question": "How do you secure Actuator endpoints in production?",
    "answer": "Secure Actuator endpoints by: using different management port, enabling Spring Security authentication, configuring access control with management.endpoints.web.exposure settings, excluding sensitive endpoints in production, using HTTPS for management endpoints, implementing role-based access (@PreAuthorize), setting up network restrictions, disabling endpoints by default (management.endpoints.enabled-by-default=false), and monitoring endpoint access."
  },
  {
    "question": "How do you implement custom metrics in Spring Boot applications?",
    "answer": "Implement custom metrics using Micrometer API with MeterRegistry, creating counters (Counter.builder().register()), timers (@Timed annotation), and gauges (Gauge.builder().register()), adding custom tags for dimensionality, exporting to monitoring systems (Prometheus, Grafana), implementing business metrics, monitoring application performance, and setting up alerting based on metric thresholds."
  },
  {
    "question": "What are the performance optimization strategies for Spring Boot applications?",
    "answer": "Optimization strategies include: profiling with tools like VisualVM or YourKit, implementing caching strategies (Spring Cache, Redis), optimizing database queries and connection pooling, using async processing for long-running tasks, configuring JVM settings (heap size, GC), implementing proper logging levels, minimizing auto-configuration overhead, optimizing Spring context startup, using lazy initialization where appropriate, and monitoring with APM tools."
  },
  {
    "question": "How do you implement distributed tracing in Spring Boot microservices?",
    "answer": "Implement distributed tracing using Spring Cloud Sleuth for automatic instrumentation, integrating with Zipkin for trace collection and visualization, configuring sampling rates (spring.sleuth.sampler.probability), adding custom spans for business operations, propagating trace context between services, implementing trace correlation IDs, exporting traces to various backends (Jaeger, Zipkin), and monitoring trace performance and errors."
  },
  {
    "question": "What are the deployment strategies for Spring Boot applications in containerized environments?",
    "answer": "Deployment strategies include: creating optimized Docker images with multi-stage builds, using base images with appropriate Java versions, implementing health checks and readiness probes, configuring resource limits and requests, using Kubernetes deployments with rolling updates, implementing blue-green or canary deployments, setting up horizontal pod autoscaling, configuring persistent volumes for stateful components, and implementing proper logging and monitoring."
  },
  {
    "question": "How do you implement circuit breaker patterns in Spring Boot applications?",
    "answer": "Implement circuit breaker using Resilience4j library with @CircuitBreaker annotation, configuring failure thresholds and timeout settings, implementing fallback methods with @Recover, monitoring circuit breaker state through Actuator endpoints, combining with retry mechanisms (@Retry), implementing bulkhead patterns for resource isolation, configuring different circuit breakers for different services, and setting up alerts for circuit breaker state changes."
  },
  {
    "question": "What are the best practices for Spring Boot application logging and monitoring?",
    "answer": "Best practices include: using appropriate log levels (ERROR, WARN, INFO, DEBUG), implementing structured logging with JSON format, adding correlation IDs for request tracing, avoiding logging sensitive information, using async logging for performance, configuring log rotation and retention, implementing centralized logging (ELK stack), monitoring application metrics with Micrometer, setting up alerting for critical issues, and conducting regular log analysis for insights."
  },
  {
    "question": "How do you implement graceful shutdown in Spring Boot applications?",
    "answer": "Implement graceful shutdown using: server.shutdown=graceful property, spring.lifecycle.timeout-per-shutdown-phase for timeout configuration, @PreDestroy methods for cleanup logic, DisposableBean interface implementation, custom shutdown hooks with Runtime.addShutdownHook(), connection pool shutdown configuration, message broker connection cleanup, and in-flight request completion before shutdown."
  },
  {
    "question": "What are the security considerations specific to Spring Boot applications?",
    "answer": "Spring Boot security considerations include: securing Actuator endpoints in production, using HTTPS with proper SSL configuration, implementing proper authentication and authorization, securing configuration properties with encryption, regular dependency updates for security patches, proper CORS configuration, input validation and sanitization, secure session management, and protection against common vulnerabilities (XSS, CSRF, SQL injection)."
  },
  {
    "question": "How do you monitor Spring Boot applications in production?",
    "answer": "Monitor production applications using: Spring Boot Actuator endpoints for health and metrics, Micrometer integration with monitoring systems (Prometheus, Grafana), Application Performance Monitoring tools (New Relic, Dynatrace), centralized logging with ELK stack, custom health indicators for business metrics, JVM monitoring (heap, GC, threads), database connection pool monitoring, and alert configuration for critical metrics."
  },
  {
    "question": "What are the common pitfalls and anti-patterns in Spring Boot development?",
    "answer": "Common pitfalls include: overusing @Autowired field injection instead of constructor injection, creating circular dependencies, not using appropriate bean scopes, ignoring transaction boundaries, over-configuration instead of relying on auto-configuration, not securing Actuator endpoints, improper exception handling, not using profiles for environment-specific configuration, blocking operations in async methods, and not implementing proper health checks."
  },
  {
    "question": "How do you implement data migration strategies in Spring Boot applications?",
    "answer": "Implement data migration using Flyway or Liquibase for version-controlled database migrations, creating migration scripts with proper versioning, implementing rollback strategies, using @Sql annotations for test data, configuring migration properties, handling schema changes in production, implementing data validation after migrations, and coordinating migrations with application deployments."
  },
  {
    "question": "What are the testing strategies for Spring Boot applications?",
    "answer": "Testing strategies include: unit testing with @MockBean and Mockito, integration testing with @SpringBootTest, slice testing (@WebMvcTest, @DataJpaTest) for focused testing, using TestContainers for external dependencies, implementing contract testing with Spring Cloud Contract, performance testing with load testing tools, security testing with Spring Security Test, and end-to-end testing with WebDriver or REST Assured."
  },
  {
    "question": "How do you implement API versioning in Spring Boot REST APIs?",
    "answer": "Implement API versioning using URI versioning (/api/v1/users), header versioning (Accept: application/vnd.api.v1+json), parameter versioning (?version=1), content negotiation, or custom annotations. Organize controllers by version, maintain backward compatibility, implement proper deprecation strategies, document version changes, and use semantic versioning principles."
  },
  {
    "question": "What are the caching strategies in Spring Boot applications?",
    "answer": "Caching strategies include: using Spring Cache abstraction with annotations (@Cacheable, @CachePut, @CacheEvict), implementing distributed caching with Redis, using local caching with Caffeine or Ehcache, configuring cache eviction policies, implementing cache warming strategies, monitoring cache performance, using HTTP caching headers for web applications, and implementing cache-aside or write-through patterns."
  },
  {
    "question": "How do you implement database transactions in Spring Boot?",
    "answer": "Implement transactions using @Transactional annotation at service layer methods, configuring transaction managers for different data sources, using propagation levels (REQUIRED, REQUIRES_NEW, NESTED), implementing proper rollback strategies with rollbackFor attribute, handling transaction boundaries correctly, using read-only transactions for queries, implementing distributed transactions with JTA when needed, and monitoring transaction performance."
  },
  {
    "question": "What are the Spring Boot configuration precedence rules?",
    "answer": "Configuration precedence (highest to lowest): command line arguments, Java system properties (-Dproperty=value), OS environment variables, profile-specific properties outside jar (application-{profile}.properties), profile-specific properties inside jar, application properties outside jar, application properties inside jar, @PropertySource annotations, and default properties. This allows environment-specific overrides without code changes."
  },
  {
    "question": "How do you implement Spring Boot application packaging and deployment?",
    "answer": "Package Spring Boot applications as executable JARs using Maven/Gradle plugins, create Docker images with multi-stage builds, implement CI/CD pipelines with automated testing and deployment, use cloud-native deployment platforms (Kubernetes, Cloud Foundry), configure environment-specific properties, implement health checks for deployment verification, use blue-green or rolling deployment strategies, and monitor deployment success with metrics and logging."
  },
  {
    "question": "What are the Spring Boot development best practices?",
    "answer": "Best practices include: using constructor injection over field injection, organizing code with proper layering (controller, service, repository), implementing proper exception handling with @ControllerAdvice, using profiles for environment management, writing comprehensive tests, following naming conventions, implementing proper logging, securing applications appropriately, monitoring performance, documenting APIs, and following Spring Boot conventions over configuration principles."
  },
  {
    "question": "How do you troubleshoot common Spring Boot application issues?",
    "answer": "Troubleshoot issues by: enabling debug logging (--debug flag), checking auto-configuration reports, analyzing stack traces, using Spring Boot DevTools for hot reloading, inspecting Actuator endpoints for application state, checking dependency conflicts, validating configuration properties, using profiling tools for performance issues, implementing proper error handling, and leveraging IDE debugging capabilities with breakpoints and variable inspection."
  },
  {
    "question": "What are the Spring Boot microservices communication patterns?",
    "answer": "Communication patterns include: synchronous communication with REST APIs and WebClient, asynchronous messaging with RabbitMQ or Kafka, event-driven architecture with Spring Cloud Stream, service discovery with Eureka or Consul, API gateways for routing and cross-cutting concerns, circuit breakers for resilience, distributed tracing for monitoring, and saga patterns for distributed transactions."
  },
  {
    "question": "How do you implement Spring Boot application observability?",
    "answer": "Implement observability through: distributed tracing with Spring Cloud Sleuth and Zipkin, metrics collection with Micrometer and Prometheus, structured logging with JSON format and correlation IDs, application monitoring with Actuator endpoints, custom health indicators for business metrics, alerting systems for critical events, dashboards with Grafana for visualization, and performance profiling with APM tools."
  },
  {
    "question": "How do you implement distributed configuration management in Spring Boot microservices?",
    "answer": "Implement distributed configuration management using Spring Cloud Config Server for centralized configuration storage, Git repositories for version-controlled configurations, Spring Cloud Bus for real-time configuration updates across services, environment-specific profiles for different deployment environments, encryption for sensitive properties, and automatic refresh capabilities using @RefreshScope annotation to update configurations without service restarts."
  },
  {
    "question": "What are the best practices for implementing API gateway patterns in Spring Boot?",
    "answer": "Best practices include using Spring Cloud Gateway for routing and filtering, implementing rate limiting and throttling, centralizing cross-cutting concerns like authentication and logging, implementing circuit breaker patterns for resilience, using service discovery for dynamic routing, implementing request/response transformation, setting up proper CORS policies, monitoring gateway performance, and implementing proper error handling and fallback mechanisms."
  },
  {
    "question": "How do you implement event sourcing patterns in Spring Boot applications?",
    "answer": "Implement event sourcing by creating immutable event objects representing state changes, using event stores for persistent storage of events, implementing aggregate roots that apply events to rebuild state, creating event handlers for side effects and projections, implementing snapshots for performance optimization, using event versioning for schema evolution, implementing replay mechanisms for debugging and recovery, and ensuring proper ordering and consistency of events."
  },
  {
    "question": "What are the strategies for implementing multi-tenancy in Spring Boot applications?",
    "answer": "Multi-tenancy strategies include database per tenant (separate databases for each tenant), schema per tenant (shared database with separate schemas), shared database with tenant isolation using row-level security, dynamic data source routing based on tenant context, tenant-specific configuration management, implementing tenant context propagation across services, using discriminator columns for data isolation, and implementing proper security and access controls."
  },
  {
    "question": "How do you implement CQRS (Command Query Responsibility Segregation) in Spring Boot?",
    "answer": "Implement CQRS by separating command and query models, using different data stores optimized for reads and writes, implementing command handlers for write operations, creating query handlers for read operations, using event sourcing for command side persistence, implementing projection builders for query side views, ensuring eventual consistency between command and query sides, and using message brokers for asynchronous communication between sides."
  },
  {
    "question": "What are the best practices for implementing saga patterns in distributed transactions?",
    "answer": "Saga pattern best practices include choosing between orchestration (centralized coordinator) and choreography (distributed coordination), implementing compensating actions for rollback scenarios, designing idempotent operations, implementing proper timeout and retry mechanisms, using correlation IDs for tracking saga instances, implementing saga state persistence, handling partial failures gracefully, and providing monitoring and debugging capabilities for saga execution."
  },
  {
    "question": "How do you implement custom Spring Boot actuator endpoints?",
    "answer": "Create custom actuator endpoints by implementing the Endpoint interface or using @Endpoint annotation, defining @ReadOperation for read operations, @WriteOperation for write operations, and @DeleteOperation for delete operations. Configure endpoint exposure through management properties, implement security for sensitive endpoints, provide health indicators extending AbstractHealthIndicator, and integrate with monitoring systems through custom metrics and indicators."
  },
  {
    "question": "What are the strategies for implementing blue-green deployments with Spring Boot?",
    "answer": "Blue-green deployment strategies include maintaining two identical production environments (blue and green), using load balancers or service mesh for traffic switching, implementing health checks for deployment validation, using feature flags for gradual rollouts, implementing database migration strategies, monitoring application metrics during switches, implementing automated rollback procedures, and ensuring zero-downtime deployments through proper coordination."
  },
  {
    "question": "How do you implement custom Spring Boot starter modules?",
    "answer": "Create custom starters by defining auto-configuration classes with @Configuration and conditional annotations, creating META-INF/spring.factories files listing auto-configurations, providing @ConfigurationProperties for customization, implementing proper conditional logic with @ConditionalOnClass and @ConditionalOnMissingBean, creating comprehensive documentation, following naming conventions, providing default configurations, and implementing proper testing for auto-configuration behavior."
  },
  {
    "question": "What are the best practices for implementing Spring Boot application monitoring?",
    "answer": "Monitoring best practices include using Spring Boot Actuator for application metrics, integrating with APM tools like New Relic or Dynatrace, implementing custom metrics with Micrometer, setting up distributed tracing with Zipkin or Jaeger, implementing structured logging with correlation IDs, monitoring JVM metrics and garbage collection, setting up alerting for critical thresholds, implementing health checks for dependencies, and creating comprehensive dashboards."
  },
  {
    "question": "How do you implement database connection pooling optimization in Spring Boot?",
    "answer": "Optimize connection pooling by configuring HikariCP settings (pool size, timeout values, leak detection), implementing connection validation queries, setting appropriate idle timeout values, monitoring connection pool metrics, implementing circuit breakers for database failures, using separate pools for read and write operations, configuring proper transaction timeouts, implementing connection pool sizing based on application load, and monitoring database connection usage patterns."
  },
  {
    "question": "What are the strategies for implementing API versioning in microservices?",
    "answer": "API versioning strategies include URI versioning (/api/v1/resource), header versioning (Accept: application/vnd.api.v1+json), parameter versioning (?version=1), content negotiation using media types, semantic versioning for backward compatibility, implementing version deprecation policies, maintaining multiple versions simultaneously, using API gateways for version routing, implementing proper documentation for each version, and providing migration guides for version upgrades."
  },
  {
    "question": "How do you implement custom security configurations for Spring Boot applications?",
    "answer": "Implement custom security by extending WebSecurityConfigurerAdapter, configuring multiple SecurityFilterChain beans for different URL patterns, implementing custom authentication providers, creating custom authorization managers, implementing JWT token validation filters, configuring method-level security with @PreAuthorize, implementing custom password encoders, setting up CORS configurations, implementing custom login and logout handlers, and integrating with external identity providers."
  },
  {
    "question": "What are the best practices for implementing Spring Boot batch processing?",
    "answer": "Batch processing best practices include using Spring Batch framework for complex batch jobs, implementing proper chunk-based processing for large datasets, using transaction management with appropriate isolation levels, implementing error handling and retry mechanisms, using job parameters for dynamic configuration, implementing proper monitoring and logging, using parallel processing for improved performance, implementing restart capabilities for failed jobs, and using appropriate data sources and writers."
  },
  {
    "question": "How do you implement reactive programming patterns in Spring Boot?",
    "answer": "Implement reactive programming using Spring WebFlux for non-blocking web applications, utilizing Mono and Flux for asynchronous data streams, implementing reactive repositories with Spring Data Reactive, using backpressure handling for flow control, implementing error handling with reactive operators, using reactive security with WebFluxSecurity, implementing reactive caching, using reactive message handling, and implementing proper testing with StepVerifier and WebTestClient."
  },
  {
    "question": "What are the strategies for implementing container orchestration with Spring Boot?",
    "answer": "Container orchestration strategies include using Kubernetes for production deployments, implementing health checks and readiness probes, configuring resource limits and requests, using ConfigMaps and Secrets for configuration management, implementing horizontal pod autoscaling, using service mesh for inter-service communication, implementing ingress controllers for external access, using persistent volumes for stateful applications, implementing rolling updates and deployment strategies, and monitoring container metrics."
  },
  {
    "question": "How do you implement custom message queue configurations in Spring Boot?",
    "answer": "Configure custom message queues by setting up connection factories for different brokers, implementing custom message converters for serialization, configuring dead letter queues for error handling, implementing message routing and filtering, setting up proper transaction management, implementing custom retry policies, configuring message acknowledgment modes, implementing message priority and delay features, setting up monitoring and alerting, and implementing proper error handling and logging."
  },
  {
    "question": "What are the best practices for implementing Spring Boot application security testing?",
    "answer": "Security testing best practices include using @WithMockUser for authentication testing, implementing integration tests for security configurations, testing authorization rules with different user roles, using MockMvc for security-aware testing, implementing penetration testing with security tools, testing CSRF protection and XSS prevention, validating input sanitization, testing session management and timeout, implementing security regression testing, and using automated security scanning in CI/CD pipelines."
  },
  {
    "question": "How do you implement custom exception handling strategies in Spring Boot?",
    "answer": "Implement custom exception handling using @ControllerAdvice for global exception handling, creating custom exception classes with proper HTTP status codes, implementing @ExceptionHandler methods for specific exceptions, using ResponseEntityExceptionHandler for REST APIs, implementing proper error response formats, adding correlation IDs for error tracking, implementing error logging and monitoring, providing user-friendly error messages, handling validation errors appropriately, and implementing circuit breaker exception handling."
  },
  {
    "question": "What are the strategies for implementing data migration in Spring Boot applications?",
    "answer": "Data migration strategies include using Flyway or Liquibase for database version control, implementing incremental migration scripts, using rollback strategies for failed migrations, implementing data validation after migrations, using blue-green deployments for zero-downtime migrations, implementing cross-database migrations, using ETL processes for complex data transformations, implementing proper backup and recovery procedures, monitoring migration performance, and implementing proper testing of migration scripts."
  },
  {
    "question": "How do you implement performance monitoring and profiling in Spring Boot?",
    "answer": "Implement performance monitoring using Spring Boot Actuator metrics, integrating with APM tools like Micrometer and Prometheus, implementing custom performance metrics, using profiling tools like JProfiler or VisualVM, monitoring JVM performance and garbage collection, implementing distributed tracing for microservices, setting up alerting for performance thresholds, monitoring database query performance, implementing load testing with tools like JMeter, and creating performance dashboards."
  },
  {
    "question": "What are the best practices for implementing Spring Boot application documentation?",
    "answer": "Documentation best practices include using Swagger/OpenAPI for API documentation, implementing comprehensive README files, documenting configuration properties and their purposes, creating architecture diagrams and deployment guides, documenting security configurations and access controls, providing examples and code samples, maintaining up-to-date dependency documentation, implementing automated documentation generation, documenting troubleshooting procedures, and creating user guides for different audiences."
  },
  {
    "question": "How do you implement custom Spring Boot configuration processors?",
    "answer": "Implement custom configuration processors by creating annotation processors that generate metadata, using @ConfigurationProperties for type-safe configuration binding, implementing custom PropertySource implementations, creating configuration validation logic, implementing environment-specific configuration resolution, using SpEL expressions for dynamic configuration, implementing configuration encryption and decryption, providing IDE support through metadata generation, and implementing proper configuration testing strategies."
  },
  {
    "question": "What are the strategies for implementing disaster recovery in Spring Boot applications?",
    "answer": "Disaster recovery strategies include implementing automated backup procedures for data and configurations, setting up multi-region deployments for geographic redundancy, implementing database replication and failover mechanisms, using circuit breakers and bulkhead patterns for fault isolation, implementing proper monitoring and alerting systems, creating runbooks for disaster scenarios, implementing automated recovery procedures, testing disaster recovery scenarios regularly, maintaining offsite backups, and implementing business continuity planning."
  },
  {
    "question": "How do you implement custom Spring Boot health indicators for complex systems?",
    "answer": "Create custom health indicators by implementing HealthIndicator interface for simple checks or extending AbstractHealthIndicator for detailed implementations, implementing composite health indicators for multiple dependencies, creating reactive health indicators for non-blocking checks, implementing custom health aggregation logic, adding detailed health information with status details, implementing health indicator caching for expensive checks, creating database and external service health checks, and implementing health indicator security and exposure controls."
  },
  {
    "question": "What are the best practices for implementing Spring Boot application deployment pipelines?",
    "answer": "Deployment pipeline best practices include implementing CI/CD with automated testing stages, using containerization with Docker for consistent deployments, implementing infrastructure as code with tools like Terraform, using blue-green or canary deployment strategies, implementing automated rollback mechanisms, setting up proper environment promotion workflows, implementing security scanning in pipelines, using feature flags for controlled releases, implementing deployment monitoring and validation, and maintaining deployment artifacts and versioning."
  },
  {
    "question": "How do you implement advanced caching strategies in Spring Boot applications?",
    "answer": "Implement advanced caching using multi-level cache hierarchies (L1 local, L2 distributed), implementing cache warming strategies for critical data, using cache partitioning and sharding for scalability, implementing cache invalidation patterns and strategies, using write-through and write-behind caching patterns, implementing cache metrics and monitoring, using cache compression for memory optimization, implementing cache eviction policies based on business rules, setting up cache replication for high availability, and implementing cache consistency across distributed systems."
  },
  {
    "question": "What are the strategies for implementing data consistency in distributed Spring Boot systems?",
    "answer": "Data consistency strategies include implementing eventual consistency patterns, using distributed locks for critical sections, implementing optimistic and pessimistic locking strategies, using event sourcing for audit trails and consistency, implementing saga patterns for distributed transactions, using message queues for reliable data propagation, implementing conflict resolution strategies, using vector clocks for ordering events, implementing proper isolation levels, and monitoring consistency metrics across distributed systems."
  },
  {
    "question": "How do you implement custom Spring Boot testing strategies for microservices?",
    "answer": "Implement microservices testing using contract testing with Spring Cloud Contract, implementing service virtualization with WireMock, creating integration tests with Testcontainers, implementing end-to-end testing strategies, using test doubles and mocks for external dependencies, implementing performance and load testing, creating test data management strategies, implementing test environment automation, using test pyramids for balanced testing approaches, and implementing continuous testing in CI/CD pipelines."
  },
  {
    "question": "What are the best practices for implementing Spring Boot application observability?",
    "answer": "Observability best practices include implementing the three pillars: metrics (with Micrometer), logging (structured with correlation IDs), and tracing (distributed with Zipkin/Jaeger), using OpenTelemetry for standardized observability, implementing custom business metrics, creating comprehensive dashboards with Grafana, implementing alerting strategies based on SLIs/SLOs, using distributed tracing for request flow analysis, implementing error tracking and analysis, monitoring application dependencies, and implementing observability as code."
  },
  {
    "question": "How do you implement advanced security patterns for Spring Boot microservices?",
    "answer": "Implement advanced security using zero-trust architecture principles, implementing mutual TLS (mTLS) for service-to-service communication, using service mesh for security policy enforcement, implementing OAuth2 and OpenID Connect for authentication, using JWT tokens with proper validation and rotation, implementing API gateway security patterns, using secrets management with tools like HashiCorp Vault, implementing security scanning and vulnerability management, setting up security monitoring and incident response, and implementing compliance frameworks."
  },
  {
    "question": "What are the strategies for implementing cost optimization in Spring Boot cloud deployments?",
    "answer": "Cost optimization strategies include implementing auto-scaling policies based on demand, using spot instances and reserved capacity for predictable workloads, optimizing resource allocation and sizing, implementing efficient caching to reduce compute costs, using serverless patterns where appropriate, implementing proper monitoring and cost tracking, optimizing data transfer and storage costs, using multi-cloud strategies for cost comparison, implementing resource tagging for cost allocation, and regularly reviewing and optimizing cloud resource usage."
  },
  {
    "question": "How do you implement advanced message processing patterns in Spring Boot?",
    "answer": "Implement advanced messaging using publish-subscribe patterns for event-driven architectures, implementing message routing and filtering based on content, using message transformation and enrichment patterns, implementing message aggregation and correlation, using competing consumers for load distribution, implementing message ordering and sequencing, using dead letter queues for error handling, implementing message deduplication strategies, using message priority and delay features, and implementing proper monitoring and alerting for message processing."
  },
  {
    "question": "What are the best practices for implementing Spring Boot application governance?",
    "answer": "Application governance best practices include implementing code quality standards and enforcement, using architectural decision records (ADRs) for design decisions, implementing proper code review processes, setting up security and compliance scanning, implementing dependency management and vulnerability tracking, using standardized development processes and guidelines, implementing proper documentation and knowledge management, setting up automated quality gates in CI/CD, implementing change management processes, and maintaining technical debt tracking and resolution."
  },
  {
    "question": "How do you implement custom Spring Boot application metrics and KPIs?",
    "answer": "Implement custom metrics using Micrometer's MeterRegistry for business and technical metrics, creating custom gauges for real-time measurements, implementing counters for event tracking, using timers for performance measurement, implementing distribution summaries for statistical analysis, creating custom metric tags for dimensionality, implementing metric aggregation and rollup strategies, setting up alerting based on metric thresholds, implementing metric retention and historical analysis, and integrating with business intelligence systems."
  },
  {
    "question": "What are the strategies for implementing Spring Boot application modernization?",
    "answer": "Modernization strategies include migrating from monolithic to microservices architecture, implementing cloud-native patterns and practices, upgrading to reactive programming models, implementing containerization and orchestration, modernizing data access patterns and databases, implementing API-first design approaches, upgrading security implementations to modern standards, implementing observability and monitoring capabilities, modernizing deployment and CI/CD practices, and implementing proper testing strategies for modern architectures."
  },
  {
    "question": "How do you implement advanced database management patterns in Spring Boot?",
    "answer": "Implement advanced database patterns using database per service for microservices, implementing read/write splitting for performance optimization, using database sharding and partitioning strategies, implementing database replication and failover mechanisms, using database pooling and connection management optimization, implementing database migration and versioning strategies, using polyglot persistence for different data requirements, implementing database monitoring and performance optimization, setting up database backup and recovery procedures, and implementing database security and compliance measures."
  },
  {
    "question": "What are the best practices for implementing Spring Boot application internationalization at scale?",
    "answer": "Internationalization at scale includes implementing dynamic locale detection and switching, using efficient message bundle loading and caching, implementing right-to-left (RTL) language support, using Unicode and UTF-8 encoding consistently, implementing locale-specific formatting for dates, numbers, and currencies, creating automated translation workflows, implementing context-aware translations, using content delivery networks for localized content, implementing locale-specific testing strategies, and managing translation versioning and updates."
  },
  {
    "question": "How do you implement advanced error handling and resilience patterns in Spring Boot?",
    "answer": "Implement advanced resilience using circuit breaker patterns with Resilience4j, implementing bulkhead patterns for resource isolation, using retry mechanisms with exponential backoff, implementing timeout patterns for external calls, using rate limiting to prevent overload, implementing fallback strategies for graceful degradation, using health checks for dependency monitoring, implementing chaos engineering practices, setting up proper error logging and alerting, and implementing disaster recovery procedures."
  },
  {
    "question": "What are the strategies for implementing Spring Boot application performance at scale?",
    "answer": "Performance at scale strategies include implementing horizontal scaling with load balancing, using caching strategies at multiple levels, implementing asynchronous processing for non-blocking operations, optimizing database queries and connections, using content delivery networks for static content, implementing efficient serialization and data formats, using connection pooling and resource management, implementing proper JVM tuning and garbage collection optimization, monitoring performance metrics and bottlenecks, and implementing performance testing and capacity planning."
  },
  {
    "question": "How do you implement advanced Spring Boot application configuration management for enterprise environments?",
    "answer": "Enterprise configuration management includes using centralized configuration servers with Spring Cloud Config, implementing environment-specific configuration strategies, using encryption for sensitive configuration data, implementing configuration versioning and rollback capabilities, using feature flags for dynamic configuration changes, implementing configuration validation and schema enforcement, setting up configuration change auditing and approval workflows, using configuration templates and inheritance, implementing configuration backup and recovery procedures, and integrating with enterprise configuration management tools."
  },
  {
    "question": "What are the best practices for implementing Spring Boot application lifecycle management in production?",
    "answer": "Application lifecycle management includes implementing proper application startup and shutdown procedures, using health checks for application readiness and liveness, implementing graceful shutdown with proper resource cleanup, setting up application versioning and release management, implementing rolling updates and deployment strategies, using blue-green and canary deployment patterns, implementing proper logging and audit trails, setting up application monitoring and alerting, implementing backup and recovery procedures, and maintaining comprehensive documentation and runbooks."
  },
  {
    "question": "How do you implement advanced integration patterns in Spring Boot microservices?",
    "answer": "Advanced integration patterns include implementing API gateways for service aggregation and routing, using service mesh for service-to-service communication, implementing event-driven architectures with message brokers, using saga patterns for distributed transactions, implementing circuit breakers and bulkheads for resilience, using content-based routing and message transformation, implementing service discovery and load balancing, using asynchronous messaging patterns, implementing data synchronization strategies, and setting up proper monitoring and observability."
  },
  {
    "question": "What are the strategies for implementing Spring Boot application compliance and audit requirements?",
    "answer": "Compliance and audit strategies include implementing comprehensive audit logging for all user actions and system events, using immutable audit trails with proper retention policies, implementing data privacy and protection measures (GDPR, CCPA), setting up access controls and authorization tracking, implementing security scanning and vulnerability management, using compliance frameworks and standards (SOC2, PCI-DSS), implementing data encryption for data at rest and in transit, setting up regular security assessments and penetration testing, maintaining compliance documentation and reporting, and implementing incident response and breach notification procedures."
  },
  {
    "question": "How do you implement advanced Spring Boot application optimization for cloud-native environments?",
    "answer": "Cloud-native optimization includes implementing auto-scaling based on metrics and demand, using serverless patterns where appropriate, implementing efficient resource utilization and rightsizing, using managed services for infrastructure components, implementing multi-region deployments for high availability, using infrastructure as code for consistent deployments, implementing proper cost monitoring and optimization, using cloud-native security patterns and services, implementing observability with cloud-native tools, and optimizing for cloud provider specific features and capabilities."
  },
  {
    "question": "What are the advanced patterns for implementing Spring Boot application data management and analytics?",
    "answer": "Advanced data management patterns include implementing event sourcing for audit trails and data reconstruction, using CQRS for separating read and write operations, implementing data lakes and warehouses for analytics, using stream processing for real-time data analysis, implementing data versioning and schema evolution strategies, using polyglot persistence for different data requirements, implementing data governance and quality management, setting up data pipeline automation, implementing data privacy and anonymization techniques, and integrating with machine learning and AI platforms for advanced analytics."
  },
  {
    "question": "How do you implement enterprise-grade Spring Boot application architecture patterns?",
    "answer": "Enterprise architecture patterns include implementing domain-driven design (DDD) principles, using hexagonal architecture for clean separation of concerns, implementing proper layering with clear boundaries, using dependency inversion and dependency injection patterns, implementing proper abstraction and interface design, using design patterns appropriate for enterprise needs, implementing proper error handling and exception management, setting up proper logging and monitoring strategies, implementing security patterns and compliance requirements, and maintaining architectural documentation and decision records."
  },
  {
    "question": "What are the best practices for implementing Spring Boot application DevOps and site reliability engineering?",
    "answer": "DevOps and SRE best practices include implementing infrastructure as code with proper version control, setting up comprehensive monitoring and alerting based on SLIs and SLOs, implementing automated incident response and remediation, using chaos engineering to test system resilience, implementing proper capacity planning and performance testing, setting up error budgets and reliability targets, implementing automated testing and quality assurance in CI/CD pipelines, using feature flags for safe deployments, implementing proper on-call procedures and runbooks, and maintaining comprehensive documentation and knowledge sharing practices."
  },
  {
    "question": "How do you implement custom security filters in Spring Security filter chain?",
    "answer": "Create custom filters by extending GenericFilterBean or OncePerRequestFilter, implementing doFilter() or doFilterInternal() methods. Add filters using HttpSecurity.addFilterBefore(), addFilterAfter(), or addFilterAt() methods. Custom filters can handle authentication, authorization, logging, or request modification. Ensure proper filter ordering and exception handling."
  },
  {
    "question": "What is Spring Security's SecurityMetadataSource and how is it used?",
    "answer": "SecurityMetadataSource provides security metadata (ConfigAttributes) for secured resources, defining required authorities for access decisions. FilterSecurityInterceptor uses it to determine access requirements. Implementations include DefaultFilterInvocationSecurityMetadataSource for URL patterns and PrePostAnnotationSecurityMetadataSource for method annotations. Custom implementations enable dynamic security metadata resolution."
  },
  {
    "question": "How do you implement account lockout mechanisms in Spring Security?",
    "answer": "Implement account lockout by tracking failed login attempts in database, creating custom AuthenticationFailureHandler to count failures, modifying UserDetailsService to check lockout status, creating scheduled tasks for automatic unlock, implementing manual unlock for administrators, adding lockout notifications, configuring different thresholds for user types, and logging lockout events for security monitoring."
  },
  {
    "question": "What are Spring Security events and how do you implement custom event listeners?",
    "answer": "Spring Security publishes authentication events like AuthenticationSuccessEvent and AuthenticationFailureEvent. Implement listeners using @EventListener annotation or ApplicationListener interface. Custom events can extend AbstractAuthenticationEvent. Use ApplicationEventPublisher to publish custom events. Events enable security monitoring, audit logging, and triggering business logic on authentication state changes."
  },
  {
    "question": "How do you implement role hierarchy in Spring Security?",
    "answer": "Implement role hierarchy using RoleHierarchy interface with RoleHierarchyImpl. Define relationships like 'ROLE_ADMIN > ROLE_USER > ROLE_GUEST' where higher roles inherit lower role permissions. Configure RoleHierarchyVoter or use with method security. This allows administrators to access user resources without explicitly granting multiple roles, simplifying permission management."
  },
  {
    "question": "What is Spring Security's remember-me functionality and how do you implement it securely?",
    "answer": "Remember-me functionality allows persistent authentication across browser sessions. Implement using token-based or persistent login approaches. Security considerations include using secure HttpOnly cookies, implementing token rotation, setting appropriate expiration times, using strong token generation, storing tokens securely with hashing, providing logout functionality that clears tokens, and monitoring for suspicious usage patterns."
  },
  {
    "question": "How do you integrate Spring Security with external authentication providers like LDAP or Active Directory?",
    "answer": "Integrate with LDAP by adding spring-security-ldap dependency, configuring LDAP context source with server details, setting up LDAP authentication provider with user search filters, configuring group search for role mapping, implementing custom UserDetailsContextMapper for attribute mapping, setting up connection pooling and timeout configurations, and handling LDAP exceptions with fallback mechanisms."
  },
  {
    "question": "What are the security considerations for implementing WebSocket authentication in Spring Boot?",
    "answer": "WebSocket security challenges include unauthorized access (no Same Origin Policy enforcement), CSRF attacks, data interception, DoS attacks, message authorization, session management, and legacy protocol handling. Implement authentication in handshake, use WSS for encryption, configure CSRF protection, implement connection limits, validate message permissions, and maintain session integrity across long connections."
  },
  {
    "question": "How do you implement API key authentication in Spring Security?",
    "answer": "Implement API key authentication by creating custom authentication filter to extract keys from headers, implementing ApiKeyAuthenticationProvider for validation, storing keys securely with hashing, configuring stateless security, adding rate limiting per key, implementing key rotation mechanisms, providing different permission levels per key, and monitoring key usage for suspicious activity."
  },
  {
    "question": "What is the difference between @Secured and @PreAuthorize annotations in method security?",
    "answer": "@Secured supports only role-based security with simple string comparisons using RoleVoter. @PreAuthorize supports SpEL expressions, method parameter access, complex authorization logic, and custom permission evaluators. @PreAuthorize is more flexible, allowing expressions like @PreAuthorize('hasRole(\"ADMIN\") and #id == authentication.name'). Use @Secured for simple role checks and @PreAuthorize for complex requirements."
  },
  {
    "question": "How do you implement time-based access control in Spring Security?",
    "answer": "Implement time-based access control by creating custom AccessDecisionVoter that checks current time, using @PreAuthorize with time-based SpEL expressions, implementing PermissionEvaluator with temporal logic, creating time-based security metadata source, using custom authentication providers with time validation, implementing session timeout based on time-of-day policies, and creating scheduled tasks to update permissions."
  },
  {
    "question": "What are the best practices for Spring Security configuration in production environments?",
    "answer": "Production best practices include: using HTTPS everywhere, implementing proper session management with secure cookies, configuring security headers (HSTS, CSP, X-Frame-Options), using strong password policies and MFA, implementing proper logging without exposing sensitive data, regular security updates and dependency scanning, implementing rate limiting and DDoS protection, using secrets management systems, configuring proper CORS policies, and conducting regular security assessments."
  },
  {
    "question": "How do you configure Spring Boot DevTools for optimal development experience?",
    "answer": "Configure DevTools by adding spring-boot-devtools dependency, enabling automatic restart on classpath changes, configuring LiveReload for browser refresh, setting custom restart triggers, excluding certain paths from monitoring using spring.devtools.restart.exclude, configuring remote debugging capabilities, setting up remote update for deployed applications, and disabling DevTools in production builds automatically."
  },
  {
    "question": "What are the performance implications of using Spring Boot DevTools?",
    "answer": "DevTools uses two classloaders: base classloader for third-party JARs (unchanged) and restart classloader for application classes (reloaded on changes). This is faster than full JVM restart but slower than no restart. Memory usage increases due to dual classloaders. LiveReload adds slight overhead. DevTools automatically disables in production, so performance impact is development-only."
  },
  {
    "question": "How do you configure remote development capabilities with Spring Boot DevTools?",
    "answer": "Configure remote development by including DevTools in deployed application, setting spring.devtools.remote.secret property for security, using RemoteSpringApplication to connect to remote instance, configuring remote debugging with spring.devtools.remote.debug.enabled=true, setting up tunnel connections through proxy settings, and enabling hot-swapping of classes in remote environments for development efficiency."
  },
  {
    "question": "What is the difference between @ConfigurationProperties and @Value annotations?",
    "answer": "@ConfigurationProperties enables type-safe binding of related properties to POJOs with validation support, IDE auto-completion, and centralized configuration management. @Value injects individual property values and supports SpEL expressions but lacks type safety and validation. Use @ConfigurationProperties for grouped related properties and @Value for simple individual property injection."
  },
  {
    "question": "How do you implement custom property sources in Spring Boot?",
    "answer": "Implement custom property sources by creating classes that extend PropertySource, implementing getProperty() method to resolve property values, registering property sources using @PropertySource annotation or PropertySourcesPlaceholderConfigurer, creating custom PropertySourceLoader for different file formats, and adding property sources programmatically through ApplicationContextInitializer or EnvironmentPostProcessor."
  },
  {
    "question": "What is property resolution order in Spring Boot and how does it work?",
    "answer": "Spring Boot resolves properties in specific order (highest to lowest precedence): command line arguments, Java system properties, OS environment variables, profile-specific properties (application-{profile}.properties), application properties, @PropertySource annotations, default properties. This hierarchical approach allows environment-specific overrides without changing application code."
  },
  {
    "question": "How do you implement property validation and type conversion in Spring Boot?",
    "answer": "Implement property validation using @ConfigurationProperties with Bean Validation annotations (@NotNull, @Valid, @Min, @Max), creating custom validators, using @Validated annotation on configuration classes, implementing Converter or PropertyEditor for custom type conversion, and using ConversionService for complex type transformations. Spring Boot automatically performs basic type conversion."
  },
  {
    "question": "What are Spring Boot configuration processors and how do you create custom ones?",
    "answer": "Configuration processors generate metadata for IDE auto-completion and validation. Create custom processors by implementing ConfigurationMetadataAnnotationProcessor, generating spring-configuration-metadata.json files, using @ConfigurationProperties annotation with proper JavaDoc, creating custom annotation processors for specialized configuration patterns, and providing hints for IDE integration."
  },
  {
    "question": "How do you implement conditional property loading in Spring Boot?",
    "answer": "Implement conditional property loading using @ConditionalOnProperty annotation to load beans based on property values, @Profile annotation for environment-specific properties, @ConditionalOnExpression for complex SpEL-based conditions, custom @Conditional implementations for advanced logic, and PropertySourcesPlaceholderConfigurer for dynamic property resolution based on runtime conditions."
  },
  {
    "question": "What is the difference between application.properties and application.yml formats?",
    "answer": "Both serve the same purpose but different formats: application.properties uses key-value pairs (server.port=8080), while application.yml uses hierarchical YAML structure. YAML advantages: more readable for complex configurations, supports lists and nested objects naturally, less verbose. Properties advantages: simpler syntax, wider tool support, less sensitive to indentation errors."
  },
  {
    "question": "How do you handle property encryption and decryption in Spring Boot?",
    "answer": "Handle property encryption using Spring Cloud Config encryption features with {cipher} prefix, implementing custom PropertySourceLoader for encrypted properties, using Jasypt library for transparent encryption/decryption, creating custom EnvironmentPostProcessor for decryption logic, storing encryption keys securely, and implementing key rotation mechanisms for enhanced security."
  },
  {
    "question": "What are Spring Boot startup events and how do you handle them?",
    "answer": "Spring Boot publishes various startup events: ApplicationStartingEvent (very early), ApplicationEnvironmentPreparedEvent (environment ready), ApplicationContextInitializedEvent (context created), ApplicationPreparedEvent (context loaded), ApplicationStartedEvent (context refreshed), ApplicationReadyEvent (ready to serve), ApplicationFailedEvent (startup failed). Handle using @EventListener or ApplicationListener implementations."
  },
  {
    "question": "How do you implement custom ApplicationContext events in Spring Boot?",
    "answer": "Create custom events by extending ApplicationEvent, publish events using ApplicationEventPublisher.publishEvent(), create listeners using @EventListener annotation or ApplicationListener interface, implement async event processing with @Async, handle event ordering with @Order annotation, create conditional listeners with SpEL expressions, and implement event filtering based on source or payload."
  },
  {
    "question": "What is the difference between synchronous and asynchronous event processing in Spring?",
    "answer": "Synchronous events block the publisher until all listeners complete, ensuring immediate processing and error propagation. Asynchronous events (@Async) execute in separate threads, providing better performance and non-blocking behavior but with delayed processing and complex error handling. Choose based on requirements for immediate consistency versus performance and scalability."
  },
  {
    "question": "How do you implement event-driven architecture patterns in Spring Boot?",
    "answer": "Implement event-driven architecture using ApplicationEvents for intra-application communication, Spring Cloud Stream for inter-service messaging, message brokers (RabbitMQ, Kafka) for reliable messaging, event sourcing patterns with event stores, CQRS (Command Query Responsibility Segregation) for read/write separation, saga patterns for distributed transactions, and event scheduling for temporal workflows."
  },
  {
    "question": "What are the best practices for handling application events in Spring Boot?",
    "answer": "Best practices include: keeping event payloads lightweight, implementing proper error handling in listeners, using async processing for non-critical operations, avoiding circular event dependencies, implementing event ordering when necessary, using conditional listeners to reduce unnecessary processing, monitoring event processing performance, implementing event replay mechanisms for reliability, and documenting event contracts."
  },
  {
    "question": "How do you implement event sourcing patterns in Spring Boot applications?",
    "answer": "Implement event sourcing by creating event store for persistent event storage, defining domain events as immutable objects, implementing aggregate roots that apply events, creating event publishers for domain events, building read models from event streams, implementing event replay capabilities, handling event versioning and migration, and using Spring Data for event persistence and querying."
  },
  {
    "question": "What is the role of ApplicationRunner and CommandLineRunner in Spring Boot?",
    "answer": "ApplicationRunner and CommandLineRunner provide hooks to execute code after Spring Boot application context is loaded. CommandLineRunner receives raw String arguments, while ApplicationRunner provides structured ApplicationArguments. Use for initialization tasks, data loading, startup validations, or triggering business logic that requires full application context availability."
  },
  {
    "question": "How do you implement graceful application shutdown in Spring Boot?",
    "answer": "Implement graceful shutdown using server.shutdown=graceful property, configuring spring.lifecycle.timeout-per-shutdown-phase for timeout, implementing @PreDestroy methods for cleanup logic, using DisposableBean interface, creating custom shutdown hooks with Runtime.addShutdownHook(), configuring connection pool shutdown, cleaning up message broker connections, and ensuring in-flight request completion."
  },
  {
    "question": "What are Spring Boot configuration slices and how do you use them for testing?",
    "answer": "Configuration slices are test annotations that load only specific parts of application context: @WebMvcTest (web layer), @DataJpaTest (JPA repositories), @JsonTest (JSON processing), @WebFluxTest (reactive web). They provide faster, focused testing by auto-configuring only relevant components, reducing test execution time while maintaining Spring features like dependency injection."
  },
  {
    "question": "How do you implement custom auto-configuration in Spring Boot?",
    "answer": "Create custom auto-configuration by defining @Configuration classes with conditional annotations (@ConditionalOnClass, @ConditionalOnMissingBean), listing them in META-INF/spring.factories file, providing @ConfigurationProperties for customization, implementing proper conditional logic for when configuration applies, creating starter modules with dependencies, and following Spring Boot auto-configuration naming conventions."
  },
  {
    "question": "What are the debugging techniques for Spring Boot auto-configuration issues?",
    "answer": "Debug auto-configuration using --debug flag or debug=true property to see auto-configuration report, checking conditions that failed or succeeded, using @ConditionalOnBean/@ConditionalOnMissingBean debugging, reviewing dependency conflicts with mvn dependency:tree, validating classpath scanning and component registration, checking configuration properties binding, and using Spring Boot Actuator's conditions endpoint."
  },
  {
    "question": "How do you implement custom health indicators for Spring Boot Actuator?",
    "answer": "Create custom health indicators by implementing HealthIndicator interface with health() method, returning Health.up() or Health.down() with details, using AbstractHealthIndicator for simplified implementation, registering as Spring beans with @Component, grouping health indicators for different audiences, implementing reactive health indicators for WebFlux, and configuring health endpoint visibility and details."
  },
  {
    "question": "What are the security considerations for Spring Boot Actuator endpoints?",
    "answer": "Secure Actuator endpoints by using different management port, enabling Spring Security authentication, configuring access control with management.endpoints.web.exposure settings, excluding sensitive endpoints in production, using HTTPS for management endpoints, implementing role-based access (@PreAuthorize), setting up network restrictions, disabling endpoints by default (management.endpoints.enabled-by-default=false), and monitoring endpoint access."
  },
  {
    "question": "How do you implement custom metrics and monitoring in Spring Boot applications?",
    "answer": "Implement custom metrics using Micrometer API with MeterRegistry, creating counters (Counter.builder().register()), timers (@Timed annotation), and gauges (Gauge.builder().register()), adding custom tags for dimensionality, exporting to monitoring systems (Prometheus, Grafana), implementing business metrics, monitoring application performance, and setting up alerting based on metric thresholds."
  },
  {
    "question": "What are the performance optimization strategies for Spring Boot applications?",
    "answer": "Optimization strategies include: profiling with tools like VisualVM or YourKit, implementing caching strategies (Spring Cache, Redis), optimizing database queries and connection pooling, using async processing for long-running tasks, configuring JVM settings (heap size, GC), implementing proper logging levels, minimizing auto-configuration overhead, optimizing Spring context startup, using lazy initialization where appropriate, and monitoring with APM tools."
  },
  {
    "question": "How do you implement distributed tracing in Spring Boot microservices?",
    "answer": "Implement distributed tracing using Spring Cloud Sleuth for automatic instrumentation, integrating with Zipkin for trace collection and visualization, configuring sampling rates (spring.sleuth.sampler.probability), adding custom spans for business operations, propagating trace context between services, implementing trace correlation IDs, exporting traces to various backends (Jaeger, Zipkin), and monitoring trace performance and errors."
  },
  {
    "question": "What are the deployment strategies for Spring Boot applications in containerized environments?",
    "answer": "Deployment strategies include: creating optimized Docker images with multi-stage builds, using base images with appropriate Java versions, implementing health checks and readiness probes, configuring resource limits and requests, using Kubernetes deployments with rolling updates, implementing blue-green or canary deployments, setting up horizontal pod autoscaling, configuring persistent volumes for stateful components, and implementing proper logging and monitoring."
  },
  {
    "question": "How do you implement circuit breaker patterns in Spring Boot applications?",
    "answer": "Implement circuit breaker using Resilience4j library with @CircuitBreaker annotation, configuring failure thresholds and timeout settings, implementing fallback methods with @Recover, monitoring circuit breaker state through Actuator endpoints, combining with retry mechanisms (@Retry), implementing bulkhead patterns for resource isolation, configuring different circuit breakers for different services, and setting up alerts for circuit breaker state changes."
  },
  {
    "question": "What are the best practices for Spring Boot application logging and monitoring?",
    "answer": "Best practices include: using appropriate log levels (ERROR, WARN, INFO, DEBUG), implementing structured logging with JSON format, adding correlation IDs for request tracing, avoiding logging sensitive information, using async logging for performance, configuring log rotation and retention, implementing centralized logging (ELK stack), monitoring application metrics with Micrometer, setting up alerting for critical issues, and conducting regular log analysis for insights."
  },
  {
    "question": "How do you implement graceful shutdown in Spring Boot applications?",
    "answer": "Implement graceful shutdown using: server.shutdown=graceful property, spring.lifecycle.timeout-per-shutdown-phase for timeout configuration, @PreDestroy methods for cleanup logic, DisposableBean interface implementation, custom shutdown hooks with Runtime.addShutdownHook(), connection pool shutdown configuration, message broker connection cleanup, and in-flight request completion before shutdown."
  },
  {
    "question": "What are the security considerations specific to Spring Boot applications?",
    "answer": "Spring Boot security considerations include: securing Actuator endpoints in production, using HTTPS with proper SSL configuration, implementing proper authentication and authorization, securing configuration properties with encryption, regular dependency updates for security patches, proper CORS configuration, input validation and sanitization, secure session management, and protection against common vulnerabilities (XSS, CSRF, SQL injection)."
  },
  {
    "question": "How do you monitor Spring Boot applications in production?",
    "answer": "Monitor production applications using: Spring Boot Actuator endpoints for health and metrics, Micrometer integration with monitoring systems (Prometheus, Grafana), Application Performance Monitoring tools (New Relic, Dynatrace), centralized logging with ELK stack, custom health indicators for business metrics, JVM monitoring (heap, GC, threads), database connection pool monitoring, and alert configuration for critical metrics."
  },
  {
    "question": "What are the common pitfalls and anti-patterns in Spring Boot development?",
    "answer": "Common pitfalls include: overusing @Autowired field injection instead of constructor injection, creating circular dependencies, not using appropriate bean scopes, ignoring transaction boundaries, over-configuration instead of relying on auto-configuration, not securing Actuator endpoints, improper exception handling, not using profiles for environment-specific configuration, blocking operations in async methods, and not implementing proper health checks."
  },
  {
    "question": "How do you implement data migration strategies in Spring Boot applications?",
    "answer": "Implement data migration using Flyway or Liquibase for version-controlled database migrations, creating migration scripts with proper versioning, implementing rollback strategies, using @Sql annotations for test data, configuring migration properties, handling schema changes in production, implementing data validation after migrations, and coordinating migrations with application deployments."
  },
  {
    "question": "What are the testing strategies for Spring Boot applications?",
    "answer": "Testing strategies include: unit testing with @MockBean and Mockito, integration testing with @SpringBootTest, slice testing (@WebMvcTest, @DataJpaTest) for focused testing, using TestContainers for external dependencies, implementing contract testing with Spring Cloud Contract, performance testing with load testing tools, security testing with Spring Security Test, and end-to-end testing with WebDriver or REST Assured."
  },
  {
    "question": "How do you implement API versioning in Spring Boot REST APIs?",
    "answer": "Implement API versioning using URI versioning (/api/v1/users), header versioning (Accept: application/vnd.api.v1+json), parameter versioning (?version=1), content negotiation, or custom annotations. Organize controllers by version, maintain backward compatibility, implement proper deprecation strategies, document version changes, and use semantic versioning principles."
  },
  {
    "question": "What are the caching strategies in Spring Boot applications?",
    "answer": "Caching strategies include: using Spring Cache abstraction with annotations (@Cacheable, @CachePut, @CacheEvict), implementing distributed caching with Redis, using local caching with Caffeine or Ehcache, configuring cache eviction policies, implementing cache warming strategies, monitoring cache performance, using HTTP caching headers for web applications, and implementing cache-aside or write-through patterns."
  },
  {
    "question": "How do you implement database transactions in Spring Boot?",
    "answer": "Implement transactions using @Transactional annotation at service layer methods, configuring transaction managers for different data sources, using propagation levels (REQUIRED, REQUIRES_NEW, NESTED), implementing proper rollback strategies with rollbackFor attribute, handling transaction boundaries correctly, using read-only transactions for queries, implementing distributed transactions with JTA when needed, and monitoring transaction performance."
  },
  {
    "question": "How do you configure Spring Boot to work with RabbitMQ for message queuing?",
    "answer": "Add the spring-boot-starter-amqp dependency. Configure connection properties (spring.rabbitmq.host, spring.rabbitmq.port, spring.rabbitmq.username, spring.rabbitmq.password) in application.properties or YAML. Define a RabbitTemplate bean for sending messages and a @RabbitListener-annotated method for consuming messages. Optionally configure RabbitAdmin and Queue, Exchange, and Binding beans for infrastructure setup."
  },
  {
    "question": "What are the advantages of using Kafka with Spring Boot for event streaming?",
    "answer": "Kafka provides high throughput, horizontal scalability, and built-in partitioning for event streams. Spring Kafka integration offers KafkaTemplate for sending, @KafkaListener for consuming, and support for transactions and message conversion. It enables durable, replayable streams and decouples producers from consumers."
  },
  {
    "question": "How do you implement a Kafka producer and consumer in Spring Boot?",
    "answer": "Include spring-kafka dependency. For producers, configure ProducerFactory and KafkaTemplate beans, then call kafkaTemplate.send(topic, key, message). For consumers, configure ConsumerFactory and ConcurrentKafkaListenerContainerFactory, then annotate a method with @KafkaListener(topics = \"topicName\"). Adjust serializers and deserializers via properties."
  },
  {
    "question": "What patterns help ensure message delivery guarantees in distributed systems?",
    "answer": "Use idempotent consumers, deduplication, transactional outbox/inbox patterns, and at-least-once vs. exactly-once semantics. With Kafka, enable idempotence on the producer and transactions. With RabbitMQ, use publisher confirms and manual acknowledgments."
  },
  {
    "question": "How do you manage multiple database types (SQL and NoSQL) in Spring Boot?",
    "answer": "Define multiple DataSource beans with @Configuration and @Primary/@Qualifier annotations. Create separate EntityManagerFactory and PlatformTransactionManager beans for each SQL database. For NoSQL stores (e.g., MongoDB), configure MongoTemplate or reactive MongoDB beans. Use repository packages and @EnableJpaRepositories/@EnableMongoRepositories with appropriate factory references."
  },
  {
    "question": "What strategies exist for database connection pooling optimization?",
    "answer": "Use HikariCP (default) and tune maxPoolSize, minimumIdle, connectionTimeout, idleTimeout, leakDetectionThreshold in application properties. Monitor pool metrics via Actuator. For high loads, consider separate pools for read and write or multiple data sources."
  },
  {
    "question": "How do you implement database sharding in Spring Boot applications?",
    "answer": "Use a proxy or middleware (e.g., ShardingSphere) and configure sharding rules in application properties or a YAML file. Define sharding strategies based on ranges, hash, or inline expression. Spring Boot auto-configures DataSource via starter dependencies."
  },
  {
    "question": "How can you dynamically refresh configuration properties at runtime?",
    "answer": "Use Spring Cloud Config with a Config Server and @RefreshScope on beans that need dynamic refresh. Expose /actuator/refresh endpoint and send a POST to it when configuration changes. Optionally integrate Spring Cloud Bus for distributing refresh events across services."
  },
  {
    "question": "What is the role of EnvironmentPostProcessor in advanced configuration?",
    "answer": "EnvironmentPostProcessor lets you modify the Environment before the application context is refreshed. Implement this interface to add or override property sources programmatically. Register your processor in META-INF/spring.factories."
  },
  {
    "question": "How do you implement feature toggles in Spring Boot?",
    "answer": "Use a library like Togglz or FF4J. Define feature enums, enable a FeatureProvider (e.g., JDBC, YAML), and inject FeatureManager to check feature.isActive(MyFeatures.FEATURE_X). Integrate with @ConditionalOnExpression or custom Spring @Bean methods."
  },
  {
    "question": "What approaches exist for centralized logging in microservices?",
    "answer": "Use the ELK stack (Elasticsearch, Logstash, Kibana) or EFK (Fluentd). Configure Logback with a TCP or HTTP appender (e.g., Logstash encoder). Include correlation IDs in logs and ship logs to the central server for aggregation, searching, and dashboards."
  },
  {
    "question": "How do you implement distributed tracing with Spring Boot?",
    "answer": "Use Spring Cloud Sleuth to add trace and span IDs automatically. Export spans to Zipkin or Jaeger by including the respective starter (spring-cloud-starter-zipkin). Configure sampling rates and service names in properties."
  },
  {
    "question": "How can you secure inter-service communication in a Spring Boot microservices environment?",
    "answer": "Use TLS/mTLS for transport security. Manage certificates via a PKI or service mesh. For HTTP calls, configure RestTemplate or WebClient with key/trust stores. For gRPC, set up SSL contexts."
  },
  {
    "question": "What is a service mesh and how does it complement Spring Boot microservices?",
    "answer": "A service mesh (e.g., Istio, Linkerd) is a dedicated infrastructure layer for service-to-service communication, offering load balancing, mTLS, observability, and traffic control. It offloads cross-cutting concerns from the application code."
  },
  {
    "question": "How do you implement rate limiting for API endpoints in Spring Boot?",
    "answer": "Use a filter or interceptor with a token bucket or leaky bucket algorithm (e.g., Bucket4j). Alternatively, configure API gateway (Spring Cloud Gateway) with rate-limiter filter backed by Redis."
  },
  {
    "question": "What techniques exist for controlling concurrency and flow in message-driven systems?",
    "answer": "Use backpressure-aware flows in Reactor or RxJava, configure concurrency limits in @RabbitListener or @KafkaListener with container factory settings (concurrency, max.poll.records), and implement batching where appropriate."
  },
  {
    "question": "How do you manage secrets and sensitive configuration in Spring Boot?",
    "answer": "Use a secret management tool (HashiCorp Vault, AWS Secrets Manager) and Spring Cloud Vault or Spring Cloud AWS starters. Fetch secrets at runtime and map them to property sources. Avoid hardcoding in properties files."
  },
  {
    "question": "What is the purpose of Spring Boot's config data API in version 2.4+?",
    "answer": "The config data API replaces legacy bootstrap context, consolidating config loading in a single phase. It supports import of additional config files (including remote sources) via spring.config.import property and provides a more flexible loading order."
  },
  {
    "question": "How can you use Actuator to expose custom health groups for different audiences?",
    "answer": "Set management.endpoint.health.group.<group>.include=health,db,circuitbreaker in properties. Access /actuator/health/<group> to get only those indicators, enabling separation of system vs. business health checks."
  },
  {
    "question": "What are the strategies for API documentation versioning with Springdoc OpenAPI?",
    "answer": "Configure multiple Dockets in SpringFox or groups in springdoc-openapi by setting springdoc.group-configs and grouping controllers via packages or paths. Each group generates its own OpenAPI spec and UI endpoint."
  },
  {
    "question": "How do you integrate resiliency patterns like retries and circuit breakers with WebClient?",
    "answer": "Use Reactor Retry for retry strategies on Flux/Mono (retryWhen). For circuit breakers, integrate Resilience4j Reactor operators: CircuitBreakerOperator.of(circuitBreaker) applied to the reactive stream."
  },
  {
    "question": "What is the role of functional bean registration in Spring Framework 5+?",
    "answer": "Functional bean registration (via org.springframework.context.support.GenericApplicationContext.registerBean()) allows programmatic bean definitions without annotations. Useful for dynamic or library code that needs to register beans conditionally."
  },
  {
    "question": "How can you use Kotlin with Spring Boot for configuration properties?",
    "answer": "Define data classes annotated with @ConfigurationProperties and use constructor binding (enable via spring.main.bind-constructor-properties=true). Ensure the class is immutable and uses val properties."
  },
  {
    "question": "What strategies exist for integrating GraphQL with Spring Boot?",
    "answer": "Use spring-graphql starter. Define @Controller with @SchemaMapping and @QueryMapping. Configure GraphQlSource with schema files under src/main/resources/graphql. Use DataLoaderRegistry for batching and caching."
  },
  {
    "question": "How do you implement session sharing across instances in a Spring Boot cluster?",
    "answer": "Use Spring Session backed by Redis or JDBC. Add spring-session-data-redis dependency and configure spring.redis properties. Sessions are stored centrally, enabling sticky or non-sticky load balancing."
  },
  {
    "question": "How do you enable HTTP/2 support in embedded Tomcat with Spring Boot?",
    "answer": "Set server.http2.enabled=true and configure SSL (HTTP/2 requires HTTPS). Spring Boot auto-configures Tomcat’s protocol when HTTP/2 is enabled and SSL is present."
  },
  {
    "question": "What is the purpose of WebClientCustomizer in WebFlux?",
    "answer": "WebClientCustomizer allows global configuration of all WebClient.Builder instances (base URL, default headers, codecs) by defining a bean that implements WebClientCustomizer."
  },
  {
    "question": "How do you implement multipart file uploads in WebFlux?",
    "answer": "Use @RequestPart Mono<FilePart> filePart in a @PostMapping. FilePart.transferTo(Path) writes the file asynchronously. Configure spring.codec.max-in-memory-size and spring.webflux.multipart.enabled/ maxFileSize."
  },
  {
    "question": "What are the benefits of using Spring Boot’s layered jar feature?",
    "answer": "Designate layers (dependencies, spring-boot-loader, snapshot-dependencies, application) in build configuration. Docker images can layer-cache dependencies separately from frequently changing application code, reducing image rebuild times."
  },
  {
    "question": "How do you configure Jib for building container images of Spring Boot apps?",
    "answer": "Add com.google.cloud.tools:jib-maven-plugin or jib-gradle-plugin. Configure target image, registry credentials, and container settings in the plugin configuration. Jib builds optimized layers without a Docker daemon."
  },
  {
    "question": "What strategies exist for validating configuration at startup?",
    "answer": "Use @ConfigurationProperties with JSR-380 validation (@Validated, @NotNull). For other properties, create an ApplicationRunner or SmartLifecycle bean that checks required conditions on startup and fails fast if invalid."
  },
  {
    "question": "How do you implement file-based rate limiting with Redis in Spring Boot?",
    "answer": "Use a Redis script or Lua for token bucket logic, invoked via RedisTemplate. Wrap endpoints with a filter that checks and decrements tokens atomically per user/IP."
  },
  {
    "question": "What approaches exist for handling large file streaming in Spring MVC?",
    "answer": "Use StreamingResponseBody in @GetMapping to write to OutputStream chunk by chunk. Configure spring.mvc.async.request-timeout and disable buffering in the container."
  },
  {
    "question": "How do you enable Kotlin coroutines support in WebFlux controllers?",
    "answer": "Use the Kotlin coroutine support library (spring-boot-starter-webflux + kotlinx-coroutines-reactor). Define suspend functions in @RestController. Spring maps them to Mono/Flux automatically."
  },
  {
    "question": "What is the role of Netty in Spring Boot reactive applications?",
    "answer": "When using webflux-starter without Tomcat, Spring Boot auto-configures Netty via Reactor Netty. Netty provides a non-blocking, event-driven HTTP server and client for reactive streams."
  },
  {
    "question": "How do you configure IPv6 support in embedded servers with Spring Boot?",
    "answer": "Set server.address to an IPv6 address or ::0 for all interfaces. Ensure the container and OS network stack support IPv6. Spring Boot passes the address to the underlying server."
  },
  {
    "question": "How can you enforce file type restrictions on uploads in Spring Boot?",
    "answer": "Implement a custom validator on MultipartFile or FilePart that checks file.getContentType() or file.getOriginalFilename() extension. Reject invalid files by throwing ConstraintViolationException or return 400 in a ControllerAdvice."
  },
  {
    "question": "What patterns help manage application feature rollout in production?",
    "answer": "Use feature flags libraries, A/B testing frameworks, or conditional beans with @ConditionalOnProperty tied to dynamic config. Combine with gradual traffic shaping in the API gateway and analytics to monitor impact."
  },
  {
    "question": "How do you integrate Spring Boot with AWS Lambda?",
    "answer": "Use the spring-cloud-function-adapter-aws, implement @Bean Function<> handlers, and package as a ZIP with handler class. AWS Lambda invokes the function via the Spring Cloud Function adapter."
  },
  {
    "question": "What are the best practices for securing Spring Boot Actuator metrics endpoints?",
    "answer": "Expose only necessary endpoints (management.endpoints.web.exposure.include), secure with HTTP basic or OAuth2, run on a separate port, restrict by network ACLs, and audit access logs."
  },
  {
    "question": "How do you implement dynamic thread pool resizing in Spring Boot?",
    "answer": "Use ThreadPoolTaskExecutor and expose Bean as a @ManagedResource. At runtime, call setCorePoolSize() and setMaxPoolSize() via JMX or an actuator endpoint to adjust sizes without restart."
  },
  {
    "question": "What strategies exist for managing distributed locks in Spring Boot?",
    "answer": "Use Redis-based locks with Redisson or Spring Integration DistributedLockRegistry. For databases, use SELECT…FOR UPDATE or advisory locks. For Zookeeper, use Curator recipes."
  },
  {
    "question": "How do you implement custom exception mappers for GraphQL errors?",
    "answer": "Define a GraphQlExceptionHandler @Bean that implements DataFetcherExceptionResolver. Map exceptions to GraphQLError instances with custom errorType and extensions. Register via GraphQlConfigurer."
  }
]
