[
  {
    "question": "What is JVM (Java Virtual Machine) and what is its primary purpose?",
    "answer": "JVM is an abstract computing machine that enables a computer to run Java programs. It provides a runtime environment in which Java bytecode can be executed. The JVM is platform-independent, meaning Java programs can run on any device that has a compatible JVM, regardless of the underlying hardware and operating system. It is responsible for converting bytecode into machine code, managing memory, and providing other runtime services."
  },
  {
    "question": "What is JRE (Java Runtime Environment) and what does it include?",
    "answer": "JRE is a package that provides the necessary libraries and components to run Java applications. It includes the JVM, core libraries, and other components required to execute Java programs. The JRE does not include development tools such as compilers or debuggers; it is intended for users who want to run Java applications but not develop them."
  },
  {
    "question": "What is JDK (Java Development Kit) and what makes it different from JRE?",
    "answer": "JDK is a full-featured software development kit that includes everything needed to develop Java applications. It contains the JRE, the JVM, and development tools such as the Java compiler (javac), debugger, and other utilities. The JDK is intended for developers who want to write, compile, and debug Java applications. In essence, if you want to run Java applications, you need the JRE. If you want to develop Java applications, you need the JDK, which includes the JRE."
  },
  {
    "question": "What are the main components of JVM architecture?",
    "answer": "The main components of JVM architecture include: 1) Class Loader - responsible for loading class files into the JVM, 2) Runtime Data Areas (Method Area, Heap, Java Stack, PC Register, Native Method Stack), 3) Execution Engine (Interpreter, JIT Compiler, Garbage Collector), 4) Native Interface - allows JVM to interact with native applications, and 5) Java Native Interface (JNI) - framework for Java code to call and be called by native applications."
  },
  {
    "question": "What is the role of the Class Loader in JVM architecture?",
    "answer": "The Class Loader is responsible for loading class files into the JVM. It reads the bytecode from the class files and loads them into memory. It performs tasks such as loading, linking (verification, preparation, and resolution), and initializing classes."
  },
  {
    "question": "What are the different Runtime Data Areas in JVM?",
    "answer": "The JVM defines several runtime data areas: 1) Method Area - stores class-level data, including class structures, method data, and static variables, 2) Heap - the runtime data area where objects are allocated, shared among all threads and managed by garbage collector, 3) Java Stack - each thread has its own stack storing frames with local variables, operand stack, and references, 4) Program Counter (PC) Register - keeps track of currently executing instruction address per thread, 5) Native Method Stack - stores state of native method calls written in languages like C or C++."
  },
  {
    "question": "What components make up the Execution Engine in JVM?",
    "answer": "The Execution Engine consists of three main components: 1) Interpreter - reads and executes bytecode instructions one at a time, simple but slower for long-running applications, 2) Just-In-Time (JIT) Compiler - compiles bytecode into native machine code at runtime for improved performance, 3) Garbage Collector - manages memory by automatically reclaiming memory occupied by objects no longer in use, preventing memory leaks."
  },
  {
    "question": "What is the Native Interface in JVM and why is it useful?",
    "answer": "The Native Interface allows the JVM to interact with native applications and libraries written in other programming languages (e.g., C, C++). This is useful for accessing system-level resources or libraries that are not available in Java. It provides a bridge between Java code and native code."
  },
  {
    "question": "What is JNI (Java Native Interface)?",
    "answer": "JNI is a framework that allows Java code to call and be called by native applications and libraries. It provides a way for Java programs to interact with native code, enabling integration with system-specific functionality or existing libraries written in other languages."
  },
  {
    "question": "Can a Java application run without installing JRE on the system?",
    "answer": "Yes, a Java application can run without installing JRE using several approaches: 1) Bundled JRE - include JRE files within the application distribution, 2) Java Native Image using GraalVM to compile into native executable, 3) Docker containers that include JRE, 4) Java Web Start (deprecated), 5) Java Packager to create native installers with JRE included. Each method has trade-offs depending on specific use cases and requirements."
  },
  {
    "question": "Is it possible to have JDK installed without having JRE separately installed?",
    "answer": "Yes, it is possible because the JDK includes the JRE as part of its installation. When you install the JDK, you automatically get the JRE included, which allows you to run Java applications. However, if you only install the JRE, you will not have the development tools (like the Java compiler) that are included in the JDK. The JDK contains the JRE, but you can have the JRE without the JDK."
  },
  {
    "question": "What are the different types of memory storage areas used by JVM?",
    "answer": "JVM uses several memory storage areas: 1) Heap Memory - runtime data area where all class instances and arrays are allocated, shared among threads and managed by garbage collector, 2) Stack Memory - each thread has its own stack storing frames with local variables and method execution data, managed in LIFO manner, 3) Method Area - stores class-level data, structures, and constant pool information, shared among threads, 4) Program Counter Register - tracks currently executing instruction address per thread, 5) Native Method Stack - used for native methods written in other languages."
  },
  {
    "question": "How does garbage collection work in Java?",
    "answer": "Garbage collection is an automatic memory management process that reclaims memory by identifying and disposing of objects no longer in use. The process works through: 1) Object creation with references in heap, 2) Reachability analysis from root references to identify unreachable objects, 3) Various algorithms like Mark-and-Sweep, Generational GC, and Copying Collection, 4) Minor GC in young generation and Major GC in old generation, 5) Optional finalization before object removal. This prevents memory leaks and optimizes application performance."
  },
  {
    "question": "What is the Mark-and-Sweep garbage collection algorithm?",
    "answer": "Mark-and-Sweep is a garbage collection algorithm where the garbage collector first 'marks' all reachable objects starting from the root references. Then, it 'sweeps' through the heap, collecting all unmarked objects and reclaiming their memory. This two-phase approach ensures that only objects that are no longer accessible from the application are removed."
  },
  {
    "question": "How does Generational Garbage Collection work?",
    "answer": "Generational Garbage Collection is based on the observation that most objects are short-lived. The heap is divided into generations: 1) Young Generation - where new objects are allocated, further divided into Eden space and Survivor spaces, collected frequently since most objects die young, 2) Old Generation (Tenured) - where long-lived objects are moved after surviving several GC cycles, collected less frequently. This approach optimizes performance by focusing collection efforts where they're most effective."
  },
  {
    "question": "What are the different phases of garbage collection?",
    "answer": "Garbage collection occurs in different phases: 1) Minor GC - occurs in the young generation and is usually fast since it deals with smaller memory area, 2) Major GC (Full GC) - occurs in the old generation, takes longer as it involves larger memory area and may involve full heap scan. The frequency and duration of these phases depend on object allocation patterns and application behavior."
  },
  {
    "question": "What is the role of finalize() method in garbage collection?",
    "answer": "The finalize() method is a protected method of Object class that can be overridden to perform cleanup operations before an object is garbage collected. However, its use is discouraged since Java 9 due to unpredictability in execution timing, performance overhead, and potential memory leaks. There's no guarantee when or if finalize() will be called, and it can impact performance by delaying garbage collection."
  },
  {
    "question": "What are the different garbage collection algorithms available in JVM?",
    "answer": "JVM provides several garbage collection algorithms: 1) Serial GC - simple, single-threaded collector for small applications, 2) Parallel GC - uses multiple threads for better performance in multi-threaded applications, 3) Concurrent Mark-Sweep (CMS) GC - low-latency collector performing most work concurrently, 4) G1 (Garbage-First) GC - modern collector providing predictable pause times for large heaps, 5) Z Garbage Collector (ZGC) - low-latency collector for very large heaps, 6) Shenandoah GC - another low-pause collector. Choice depends on application requirements."
  },
  {
    "question": "What can cause memory leaks in Java despite garbage collection?",
    "answer": "Memory leaks in Java can occur when objects are still referenced but no longer needed: 1) Static references holding objects for application lifetime, 2) Listeners and callbacks not properly unregistered, 3) Cached objects without proper eviction policies, 4) Collections with objects not removed when no longer needed, 5) Unclosed resources like database connections or file streams, 6) Non-static inner classes holding implicit references to outer classes. These prevent garbage collection from reclaiming memory."
  },
  {
    "question": "What are the symptoms of memory leaks in Java applications?",
    "answer": "Symptoms of memory leaks include: 1) Increased memory consumption over time without corresponding workload increase, 2) Decreased application performance as memory usage grows, 3) Frequent garbage collection activities, 4) OutOfMemoryError exceptions indicating the application has run out of available memory. These symptoms indicate that memory is not being properly reclaimed by the garbage collector."
  },
  {
    "question": "How can memory leaks be prevented in Java?",
    "answer": "Memory leaks can be prevented by: 1) Minimizing static variables and clearing them when not needed, 2) Properly managing listeners and callbacks by unregistering them, 3) Implementing effective caching strategies with eviction policies, 4) Using collections wisely and removing objects when no longer needed, 5) Closing resources properly using try-with-resources statements, 6) Regular profiling and monitoring of memory usage, 7) Code reviews to identify potential leak sources early."
  },
  {
    "question": "Is Java 100% object-oriented and why?",
    "answer": "Java is not 100% object-oriented because it includes primitive data types (int, char, boolean, etc.) that are not objects. While Java supports key OOP concepts like encapsulation, inheritance, and polymorphism, and almost everything is treated as an object except primitives, it also allows static methods and variables that belong to the class rather than instances. Java provides wrapper classes for primitives to work with them in an object-oriented way when needed."
  },
  {
    "question": "What are the advantages of Java being partially object-oriented?",
    "answer": "Advantages of Java's partial object-oriented nature include: 1) Flexibility to choose appropriate paradigm for specific problems, 2) Simplicity for straightforward tasks using procedural approach, 3) Performance benefits in certain scenarios with procedural programming, 4) Legacy code integration with existing procedural systems, 5) Ease of learning with gradual progression from procedural to OOP concepts, 6) Modularity allowing mix of programming styles, 7) Code reusability through both paradigms, 8) Interoperability with diverse programming environments."
  },
  {
    "question": "Why are object-oriented programming languages widely used in enterprise projects?",
    "answer": "OOP languages are preferred in enterprise projects because of: 1) Modularity allowing independent team work on components, 2) Encapsulation providing better data protection and security, 3) Reusability through inheritance and polymorphism saving development time, 4) Maintainability with clear structure and localized changes, 5) Abstraction simplifying complex system design, 6) Collaboration through common vocabulary and interfaces, 7) Scalability with modular and extensible design, 8) Design patterns providing proven solutions, 9) Better testing capabilities with unit testing, 10) Integration with modern technologies, 11) Support for agile development methodologies."
  },
  {
    "question": "What does the line 'public static void main(String args[])' mean in Java?",
    "answer": "This line declares the main method which serves as the entry point for Java applications: 1) 'public' - access modifier allowing JVM to access method from outside the class, 2) 'static' - method belongs to class itself, not instances, allowing JVM to call without creating object, 3) 'void' - return type indicating method doesn't return any value, 4) 'main' - specific method name that JVM looks for as starting point, 5) 'String args[]' - parameter array holding command-line arguments passed to program."
  },
  {
    "question": "What happens if you don't declare the main method as static?",
    "answer": "If the main method is not declared as static, you will encounter a NoSuchMethodError when trying to run the program. The JVM looks for a static method named main to start program execution. Since the main method must be called without creating an instance of the class, it must be static. The JVM cannot invoke a non-static method without an object instance."
  },
  {
    "question": "Can you override the main method in Java?",
    "answer": "You cannot override the main method in the traditional sense as you would with instance methods in inheritance. However, you can define a main method in a subclass, but this creates a separate method rather than overriding the superclass main method. Each class can have its own main method, and they coexist independently without affecting each other."
  },
  {
    "question": "Can you overload the main method in Java?",
    "answer": "Yes, you can overload the main method by creating multiple main methods with different parameter types or counts in the same class. However, only the standard main method with 'String[] args' signature is recognized by the JVM as the entry point. The overloaded versions must be called explicitly from the standard main method or other methods - they won't be executed automatically when running the program."
  },
  {
    "question": "Can the JVM execute overloaded main methods?",
    "answer": "No, the JVM cannot execute overloaded main methods. The JVM only executes the specific 'public static void main(String[] args)' method signature. While you can define overloaded versions of main with different parameters, the JVM will only call the standard signature when starting the program. Other overloaded main methods must be called explicitly from within the standard main method."
  },
  {
    "question": "What are primitive data types in Java and how do they differ from non-primitive types?",
    "answer": "Primitive data types are basic data types that hold values directly in memory. There are 8 primitives: byte, short, int, long, float, double, char, boolean. They are stored in stack memory, have default values, are immutable, and provide fast access. Non-primitive types are reference types (classes, interfaces, arrays, enums) that hold references to objects in heap memory, have default value of null, can be mutable or immutable, and are more complex data structures derived from primitives."
  },
  {
    "question": "Can primitive data types in Java be null?",
    "answer": "No, primitive data types cannot be null in Java. Primitives hold their values directly and have default values (0 for int, false for boolean, etc.). If you need a variable that can hold a null value, you should use the corresponding wrapper classes (Integer for int, Boolean for boolean, etc.) which are objects and can be assigned null."
  },
  {
    "question": "Does Java support pointers like C or C++?",
    "answer": "No, Java does not support pointers in the same way as C or C++. Instead of pointers, Java uses references, which are variables that hold the address of an object in memory without allowing direct memory manipulation. Key differences: 1) No pointer arithmetic, 2) Automatic memory management through garbage collection, 3) Object references instead of memory addresses, 4) Null references for uninitialized objects. This design enhances safety and reduces memory-related errors."
  },
  {
    "question": "What are wrapper classes in Java and why are they needed?",
    "answer": "Wrapper classes convert primitive data types into objects. Each primitive has a corresponding wrapper: Boolean, Character, Byte, Short, Integer, Long, Float, Double. They are needed because: 1) Object-oriented features require objects, not primitives, 2) Collections can only store objects, 3) Wrapper classes can hold null values, 4) They provide utility methods for type conversion and operations, 5) Support for autoboxing/unboxing, 6) Required for generics which work only with objects, 7) Enable reflection capabilities."
  },
  {
    "question": "What are the key features of wrapper classes?",
    "answer": "Key features of wrapper classes include: 1) Object representation - allow primitives to be treated as objects, 2) Null values - can be assigned null unlike primitives, 3) Utility methods - provide conversion methods like parseInt(), valueOf(), 4) Autoboxing and unboxing - automatic conversion between primitives and wrappers, 5) Immutability - wrapper objects cannot be changed once created, requiring new objects for different values."
  },
  {
    "question": "Why are wrapper classes important in Java collections?",
    "answer": "Wrapper classes are crucial in collections because: 1) Collections can only store objects, not primitives, 2) Generics require type parameters to be objects, enabling List<Integer> instead of List<int>, 3) They can hold null values representing absence of data, 4) Provide utility methods for operations, 5) Support autoboxing/unboxing for seamless conversion, making it easier to work with collections without manual type conversion."
  },
  {
    "question": "What are autoboxing and unboxing in Java?",
    "answer": "Autoboxing is the automatic conversion from primitive types to their corresponding wrapper classes (int to Integer). Unboxing is the reverse process, converting wrapper classes back to primitives (Integer to int). These conversions happen automatically when needed, such as adding primitives to collections or retrieving values. This feature simplifies code by eliminating the need for explicit conversions between primitives and their wrapper objects."
  },
  {
    "question": "Can autoboxing lead to unexpected behavior?",
    "answer": "Yes, autoboxing can lead to unexpected behavior, particularly with Integer caching. Java caches Integer objects for values between -128 and 127. When comparing autoboxed integers outside this range using ==, you compare object references rather than values, potentially getting false even for equal values. For values within the cache range, == returns true because they reference the same cached object. Always use .equals() method for value comparison with wrapper objects."
  },
  {
    "question": "Can autoboxing and unboxing cause NullPointerException?",
    "answer": "Yes, unboxing can cause NullPointerException when trying to unbox a null wrapper reference. If you have an Integer object set to null and attempt to assign it to a primitive int, Java tries to unbox the null reference, resulting in NullPointerException. To avoid this, always check for null before unboxing or use Optional for better null handling."
  },
  {
    "question": "What are try, catch, and finally blocks in Java exception handling?",
    "answer": "Exception handling in Java uses: 1) try block - encloses code that might throw exceptions, allowing testing for errors, 2) catch block - handles exceptions thrown in try block, can have multiple catch blocks for different exception types, 3) finally block - executes code that must run regardless of whether exceptions occurred, typically used for cleanup activities like closing resources. This structure ensures robust error handling and proper resource management."
  },
  {
    "question": "What happens to finally block when return statements are executed in try or catch blocks?",
    "answer": "The finally block will still execute before the method returns, even if return statements are present in try or catch blocks. The method prepares to return the specified value, but the finally block executes first to ensure necessary cleanup. This guarantees that cleanup code runs regardless of how the method exits, maintaining resource integrity and program stability."
  },
  {
    "question": "Can you execute a Java program with try-finally blocks without catch blocks?",
    "answer": "Yes, you can use try-finally blocks without catch blocks. The finally block will execute regardless of whether an exception occurs. However, if an exception is thrown and not caught, it will propagate up the call stack after the finally block executes. This pattern is useful for cleanup activities when you don't want to handle the exception in the current method."
  },
  {
    "question": "What is the performance impact of using try-catch-finally blocks?",
    "answer": "Try-catch-finally blocks have minimal performance impact when exceptions are not thrown. However, when exceptions are thrown, performance can degrade due to overhead from exception handling mechanisms, stack trace capture, and control flow management. The JVM may also be unable to perform certain optimizations on code within try-catch blocks. For performance-critical code, consider using boolean checks instead of exception handling for control flow."
  },
  {
    "question": "In what scenarios will the finally block not execute?",
    "answer": "The finally block may not execute in these scenarios: 1) System.exit() is called, terminating the JVM immediately, 2) Thread termination through Thread.stop() (deprecated and unsafe), 3) Fatal errors like OutOfMemoryError or StackOverflowError that cause JVM termination, 4) Infinite loops or deadlocks that prevent reaching the finally block. Under normal circumstances with typical exceptions, the finally block will always execute."
  },
  {
    "question": "Can you have multiple finally blocks for a single try block?",
    "answer": "No, you cannot have multiple finally blocks for a single try block. The structure allows only one finally block per try-catch-finally statement. If you need multiple cleanup actions, include them all within the single finally block or call separate methods from within the finally block to handle different cleanup tasks."
  },
  {
    "question": "What are checked and unchecked exceptions in Java?",
    "answer": "Checked exceptions are checked at compile-time and must be either caught using try-catch or declared in method signature using throws keyword. They represent recoverable conditions like IOException, SQLException. Unchecked exceptions are not checked at compile-time, derive from RuntimeException, and typically represent programming errors like NullPointerException, ArrayIndexOutOfBoundsException. Checked exceptions must be handled or declared, while unchecked exceptions are optional to handle."
  },
  {
    "question": "How can you handle multiple exceptions in a single catch block?",
    "answer": "Since Java 7, you can handle multiple exceptions in a single catch block using the multi-catch feature. Separate multiple exception types with the pipe (|) character. For example: catch (NullPointerException | ArrayIndexOutOfBoundsException e). This reduces code duplication when the handling logic is the same for different exceptions. You can only use one variable name for the caught exception, and more specific exceptions should be caught before general ones."
  },
  {
    "question": "What is the String Pool in Java and how does it work?",
    "answer": "The String Pool is a special memory area in the Java heap where string literals are stored to optimize memory usage. When a string literal is created, Java checks if an identical string exists in the pool. If it does, the reference to existing string is returned; if not, a new string is created and added to the pool. This process is called string interning. String literals are automatically interned, while strings created with 'new' keyword are not automatically pooled, improving memory efficiency and enabling fast string comparisons."
  },
  {
    "question": "What is method area in JVM and what does it store?",
    "answer": "Method area is a runtime data area in JVM that stores class-level data including class structures, method data, constant pool information, and static variables. It is shared among all threads and contains metadata about classes such as class definitions, method bytecode, field information, and runtime constant pool. This area is also known as Metaspace in newer JVM versions."
  },
  {
    "question": "What is the difference between stack memory and heap memory in Java?",
    "answer": "Stack memory stores method call frames, local variables, and partial results for each thread individually. It follows LIFO (Last In First Out) principle and is automatically managed. Heap memory stores all class instances and arrays, is shared among all threads, and is managed by garbage collector. Stack is faster to access but smaller in size, while heap is larger but slower to access due to garbage collection overhead."
  },
  {
    "question": "What happens when heap memory is full in Java?",
    "answer": "When heap memory is full, the JVM throws an OutOfMemoryError with the message 'Java heap space'. Before throwing this error, the JVM attempts full garbage collection to reclaim memory. If insufficient memory is freed even after aggressive garbage collection, the application terminates. This can be prevented by increasing heap size using -Xmx flag or optimizing memory usage by fixing memory leaks."
  },
  {
    "question": "What is the purpose of -Xms and -Xmx JVM parameters?",
    "answer": "-Xms sets the initial heap size when JVM starts, while -Xmx sets the maximum heap size that JVM can use. For example, -Xms512m sets initial heap to 512MB and -Xmx2g sets maximum heap to 2GB. Setting these parameters appropriately can improve application performance by avoiding frequent heap expansions and ensuring sufficient memory is available."
  },
  {
    "question": "What is memory leak in Java and how can it occur despite garbage collection?",
    "answer": "A memory leak in Java occurs when objects are no longer needed but still have references preventing garbage collection. Common causes include: static collections that grow indefinitely, listeners not properly removed, unclosed resources like database connections, ThreadLocal variables not cleared, and circular references in some cases. Even with garbage collection, these referenced objects cannot be collected, leading to memory exhaustion over time."
  },
  {
    "question": "What is the difference between System.gc() and Runtime.gc()?",
    "answer": "Both System.gc() and Runtime.gc() are equivalent - System.gc() internally calls Runtime.getRuntime().gc(). Both methods suggest to the JVM that garbage collection should be performed, but they don't guarantee it will happen immediately or at all. The JVM may ignore these requests based on its internal algorithms and current memory conditions. It's generally not recommended to call these methods explicitly."
  },
  {
    "question": "What is OutOfMemoryError and what are its different types?",
    "answer": "OutOfMemoryError is thrown when JVM cannot allocate memory. Different types include: 1) 'Java heap space' - heap is full, 2) 'Metaspace' - class metadata area is full, 3) 'Direct buffer memory' - off-heap memory is exhausted, 4) 'unable to create new native thread' - cannot create more threads, 5) 'GC overhead limit exceeded' - too much time spent in garbage collection with little memory recovered."
  },
  {
    "question": "What is the difference between shallow copy and deep copy in Java?",
    "answer": "Shallow copy creates a new object but references to nested objects remain the same as original. Changes to nested objects affect both copies. Deep copy creates a new object with completely independent copies of all nested objects. Java's clone() method performs shallow copy by default. Deep copy requires custom implementation, often using serialization/deserialization or recursive cloning of all nested objects."
  },
  {
    "question": "How does clone() method work in Java?",
    "answer": "The clone() method creates a copy of an object. To use it, a class must implement Cloneable interface and override the clone() method. The default implementation performs shallow copy - copying primitive fields and references to objects, but not the objects themselves. For deep copying, you must override clone() to recursively clone nested objects. If Cloneable is not implemented, CloneNotSupportedException is thrown."
  },
  {
    "question": "What is the finalize() method and why is it deprecated?",
    "answer": "The finalize() method is called by garbage collector before reclaiming an object's memory, intended for cleanup operations. It's deprecated since Java 9 because: 1) unpredictable execution timing, 2) performance overhead, 3) can prevent or delay garbage collection, 4) can resurrect objects, 5) no guarantee of execution. Better alternatives include try-with-resources, AutoCloseable interface, or explicit cleanup methods."
  },
  {
    "question": "What is phantom reference in Java?",
    "answer": "PhantomReference is the weakest reference type that doesn't prevent garbage collection and always returns null when get() is called. It's used for cleanup actions after an object becomes unreachable but before memory is reclaimed. Phantom references are enqueued in a ReferenceQueue when the object is about to be collected, allowing for post-mortem cleanup operations like releasing native resources."
  },
  {
    "question": "What is the difference between Comparable and Comparator interfaces?",
    "answer": "Comparable interface is implemented by the class whose objects need to be sorted, providing natural ordering through compareTo() method. Comparator is a separate interface for custom sorting logic, used when you want multiple ways to sort or cannot modify the original class. Comparable provides single sorting logic, while Comparator allows multiple sorting strategies and can be implemented as lambda expressions."
  },
  {
    "question": "How do you handle null values when sorting collections?",
    "answer": "When sorting collections with potential null values: 1) Use Comparator.nullsFirst() or Comparator.nullsLast() to handle nulls explicitly, 2) Check for null in custom comparators before comparison, 3) Use Comparator.naturalOrder() with null handling, 4) Consider filtering out nulls before sorting. Example: Collections.sort(list, Comparator.nullsFirst(String::compareTo));"
  },
  {
    "question": "What is the difference between fail-fast and fail-safe iterators?",
    "answer": "Fail-fast iterators throw ConcurrentModificationException if collection is modified during iteration (ArrayList, HashMap iterators). They work on original collection. Fail-safe iterators work on copy of collection and don't throw exceptions when collection is modified during iteration (ConcurrentHashMap, CopyOnWriteArrayList). Fail-safe iterators may not reflect latest changes but are thread-safe."
  },
  {
    "question": "What is ConcurrentModificationException and how to avoid it?",
    "answer": "ConcurrentModificationException occurs when a collection is modified while being iterated using fail-fast iterators. To avoid: 1) Use iterator's remove() method instead of collection's remove(), 2) Use concurrent collections like ConcurrentHashMap, 3) Use traditional for loop with index, 4) Synchronize access to collection, 5) Create a copy of collection before iteration, 6) Use streams for filtering operations."
  },
  {
    "question": "What is the load factor in HashMap and how does it affect performance?",
    "answer": "Load factor determines when HashMap should be resized. Default is 0.75, meaning when 75% of capacity is filled, the map is resized (doubled). Lower load factor reduces collisions but wastes space. Higher load factor saves space but increases collisions and lookup time. Load factor of 0.75 provides a good balance between time and space complexity, minimizing both memory usage and collision probability."
  },
  {
    "question": "How does HashMap handle hash collisions?",
    "answer": "HashMap handles collisions using chaining - multiple entries with same hash are stored in a linked list at the same bucket. In Java 8+, when the number of items in a bucket exceeds threshold (8), the linked list converts to a balanced tree (red-black tree) for better performance. This reduces worst-case lookup time from O(n) to O(log n). When items decrease below threshold (6), it converts back to linked list."
  },
  {
    "question": "What is the difference between HashMap and LinkedHashMap?",
    "answer": "HashMap doesn't maintain any order of elements and provides O(1) performance for basic operations. LinkedHashMap maintains insertion order (or access order if specified) using additional doubly-linked list, with slightly slower performance due to maintaining order. LinkedHashMap is useful when you need predictable iteration order, such as for caching with LRU (Least Recently Used) eviction policy."
  },
  {
    "question": "What is WeakHashMap and when would you use it?",
    "answer": "WeakHashMap uses weak references for keys, allowing keys to be garbage collected when they're no longer referenced elsewhere. When a key is garbage collected, its entry is automatically removed from the map. It's useful for scenarios like caching where you want entries to be removed automatically when keys are no longer in use, preventing memory leaks. However, it's not suitable when you need to guarantee key retention."
  },
  {
    "question": "What is the difference between ArrayList and Vector?",
    "answer": "ArrayList is not synchronized (not thread-safe) and generally faster, while Vector is synchronized (thread-safe) but slower due to synchronization overhead. ArrayList grows by 50% when capacity is exceeded, Vector doubles its size. Vector is legacy from Java 1.0, while ArrayList was introduced in Java 1.2. For thread safety, prefer ArrayList with external synchronization or use Collections.synchronizedList()."
  },
  {
    "question": "What is the difference between Array and ArrayList?",
    "answer": "Arrays have fixed size and can store primitives or objects, providing direct memory access with best performance. ArrayList is resizable, can only store objects (not primitives), and provides dynamic size management with built-in methods like add(), remove(). Arrays use [] syntax, ArrayList uses methods. Arrays are faster for accessing elements, ArrayList is more flexible for dynamic operations and provides utility methods."
  },
  {
    "question": "When should you use LinkedList over ArrayList?",
    "answer": "Use LinkedList when: 1) Frequent insertions/deletions at beginning or middle of list, 2) Implementing queue or deque operations, 3) Size varies significantly and unpredictably, 4) Don't need random access by index. Use ArrayList when: 1) Frequent random access by index, 2) More reads than insertions/deletions, 3) Need better memory locality, 4) Iterating through elements frequently. ArrayList is generally preferred due to better cache performance."
  },
  {
    "question": "What is the difference between Set and List interfaces?",
    "answer": "Set doesn't allow duplicate elements and has no concept of indexed access - elements are retrieved by iteration. List allows duplicates and provides indexed access to elements with methods like get(index), set(index, element). Set is useful for uniqueness constraints, List for ordered collections with possible duplicates. Set implementations include HashSet, LinkedHashSet, TreeSet; List implementations include ArrayList, LinkedList, Vector."
  },
  {
    "question": "What is the difference between HashSet and TreeSet?",
    "answer": "HashSet uses hash table for storage, provides O(1) average time complexity for basic operations, doesn't maintain any order, and allows null values. TreeSet uses red-black tree (balanced BST), provides O(log n) time complexity, maintains sorted order of elements, doesn't allow null values, and elements must be Comparable or use custom Comparator. Use HashSet for fast access, TreeSet for sorted collection."
  },
  {
    "question": "What is LinkedHashSet and when to use it?",
    "answer": "LinkedHashSet combines HashSet's performance with LinkedList's ordering. It maintains insertion order using additional linked list while providing HashSet's O(1) performance for basic operations. Use LinkedHashSet when you need: 1) Unique elements (Set behavior), 2) Predictable iteration order, 3) Better performance than TreeSet for basic operations, 4) Insertion order preservation for scenarios like maintaining order of user inputs."
  },
  {
    "question": "What is PriorityQueue and how does it work?",
    "answer": "PriorityQueue is a heap-based priority queue where elements are ordered by their natural ordering or by a Comparator. It doesn't allow null elements and is not thread-safe. Elements are retrieved in priority order, not insertion order. Internally uses a binary heap data structure. Common operations: offer() to add, poll() to remove highest priority element, peek() to view without removing. Useful for task scheduling, finding top K elements, etc."
  },
  {
    "question": "What is the difference between poll() and remove() methods in Queue?",
    "answer": "Both methods remove and return the head element from queue, but differ in behavior when queue is empty. poll() returns null if queue is empty, making it safe to use without checking queue size. remove() throws NoSuchElementException if queue is empty. Similarly, peek() returns null for empty queue while element() throws exception. poll() and peek() are generally preferred for safer queue operations."
  },
  {
    "question": "What is Deque interface and its implementations?",
    "answer": "Deque (Double Ended Queue) allows insertion and removal at both ends. It extends Queue interface and provides methods like addFirst(), addLast(), removeFirst(), removeLast(), peekFirst(), peekLast(). Main implementations are ArrayDeque and LinkedList. ArrayDeque is preferred for deque operations due to better performance and memory efficiency. Deque can be used as both stack (LIFO) and queue (FIFO) data structure."
  },
  {
    "question": "What is the difference between synchronized and concurrent collections?",
    "answer": "Synchronized collections (like Collections.synchronizedList()) provide thread safety by synchronizing all methods, but have performance overhead and require manual synchronization during iteration to avoid ConcurrentModificationException. Concurrent collections (like ConcurrentHashMap, CopyOnWriteArrayList) are designed for concurrent access with better performance, lock-free or fine-grained locking, and built-in thread safety for iteration without external synchronization."
  },
  {
    "question": "What is CopyOnWriteArrayList and when to use it?",
    "answer": "CopyOnWriteArrayList creates a new copy of underlying array for every write operation (add, set, remove), while reads operate on the original array without synchronization. It's thread-safe and provides consistent iteration without ConcurrentModificationException. Best suited for scenarios with many reads and few writes, such as observer patterns, event listeners, or caching scenarios where read performance is critical and writes are infrequent."
  },
  {
    "question": "What is BlockingQueue and its implementations?",
    "answer": "BlockingQueue extends Queue and provides blocking operations - threads wait when trying to add to full queue or remove from empty queue. Key methods: put() (blocking add), take() (blocking remove), offer() with timeout, poll() with timeout. Implementations include ArrayBlockingQueue (bounded), LinkedBlockingQueue (optionally bounded), PriorityBlockingQueue (unbounded priority queue), SynchronousQueue (no storage). Used in producer-consumer scenarios."
  },
  {
    "question": "What is the difference between Enumeration and Iterator?",
    "answer": "Enumeration is older (Java 1.0) and provides only hasMoreElements() and nextElement() methods for forward traversal without removal capability. Iterator is newer (Java 1.2) and provides hasNext(), next(), and remove() methods, allowing element removal during iteration. Iterator is fail-fast, throwing ConcurrentModificationException if collection is modified. Enumeration is not fail-fast. Iterator is preferred for new code."
  },
  {
    "question": "What is ListIterator and how is it different from Iterator?",
    "answer": "ListIterator extends Iterator and provides additional capabilities: 1) Bidirectional traversal using hasNext(), next(), hasPrevious(), previous(), 2) Element modification using set() and add(), 3) Index access with nextIndex() and previousIndex(). It's specifically designed for List implementations. Regular Iterator only provides forward traversal and remove() method. ListIterator allows more comprehensive list manipulation during iteration."
  },
  {
    "question": "What are the different ways to iterate over a Map?",
    "answer": "Several ways to iterate over Map: 1) Using keySet(): for(String key : map.keySet()), 2) Using entrySet(): for(Map.Entry<String, String> entry : map.entrySet()), 3) Using values(): for(String value : map.values()), 4) Using Java 8 streams: map.entrySet().stream().forEach(), 5) Using iterators explicitly, 6) Traditional for loop with keySet(). EntrySet iteration is most efficient when you need both key and value."
  },
  {
    "question": "What is the difference between keySet(), values(), and entrySet() in Map?",
    "answer": "keySet() returns a Set view of keys in the map - changes to this set reflect in the original map. values() returns a Collection view of values - it's not a Set because duplicate values are allowed. entrySet() returns a Set view of key-value mappings as Map.Entry objects. All these views are backed by the original map, so changes in the map are reflected in the views and vice versa (where applicable)."
  },
  {
    "question": "What is EnumSet and its advantages?",
    "answer": "EnumSet is a specialized Set implementation for enum types. It uses bit vector representation internally, making it extremely compact and efficient. Advantages: 1) Much faster than HashSet for enum types, 2) Compact memory usage, 3) Type-safe at compile time, 4) Rich factory methods like allOf(), noneOf(), range(), 5) All basic operations execute in constant time. It's the preferred Set implementation when working with enums."
  },
  {
    "question": "What is EnumMap and when to use it?",
    "answer": "EnumMap is a specialized Map implementation for enum keys. It uses array internally indexed by enum ordinals, providing excellent performance. Advantages: 1) Faster than HashMap for enum keys, 2) Compact representation, 3) Natural ordering based on enum declaration order, 4) Type-safe, 5) All operations execute in constant time. Use EnumMap when keys are enum types for better performance and memory efficiency compared to regular maps."
  },
  {
    "question": "What is the Collections utility class and its common methods?",
    "answer": "Collections is a utility class providing static methods for common collection operations: 1) sort() for sorting lists, 2) reverse() for reversing order, 3) shuffle() for random ordering, 4) binarySearch() for searching sorted lists, 5) max()/min() for finding extremes, 6) synchronizedXXX() for creating thread-safe wrappers, 7) unmodifiableXXX() for creating read-only views, 8) emptyXXX() for creating empty collections, 9) singletonXXX() for single-element collections."
  },
  {
    "question": "What is the difference between Collections.sort() and Arrays.sort()?",
    "answer": "Collections.sort() works with List implementations and uses merge sort algorithm (stable sort), ensuring O(n log n) performance. Arrays.sort() works with arrays and uses dual-pivot quicksort for primitives (unstable, O(n log n) average) and TimSort for objects (stable, O(n log n)). Collections.sort() internally converts list to array, sorts using Arrays.sort(), then updates the list. Both handle null elements appropriately with custom comparators."
  },
  {
    "question": "What are immutable collections and how to create them?",
    "answer": "Immutable collections cannot be modified after creation. Ways to create: 1) Collections.unmodifiableXXX() creates unmodifiable views of existing collections, 2) Java 9+ factory methods: List.of(), Set.of(), Map.of(), 3) Google Guava library: ImmutableList, ImmutableSet, ImmutableMap, 4) Copy constructor with defensive copying. Immutable collections provide thread safety, prevent accidental modifications, and can be safely shared across multiple components."
  },
  {
    "question": "What is the difference between Collections.emptyList() and new ArrayList()?",
    "answer": "Collections.emptyList() returns a singleton immutable empty list that cannot be modified and saves memory by reusing the same instance. new ArrayList() creates a new mutable empty list instance that can be modified. Use Collections.emptyList() when you need to return an empty list that won't be modified, saving memory and improving performance. Use new ArrayList() when you need a mutable list that will be populated later."
  },
  {
    "question": "What is NavigableSet and NavigableMap?",
    "answer": "NavigableSet extends SortedSet and NavigableMap extends SortedMap, providing navigation methods for finding closest matches. NavigableSet methods include lower(), floor(), ceiling(), higher() for finding elements relative to given value, and descendingSet() for reverse view. NavigableMap provides similar methods plus firstEntry(), lastEntry(), pollFirstEntry(), pollLastEntry(). TreeSet and TreeMap implement these interfaces, enabling efficient range queries and navigation operations."
  },
  {
    "question": "What is the difference between capacity and size in ArrayList?",
    "answer": "Size is the number of elements currently stored in ArrayList, returned by size() method. Capacity is the internal array length that determines how many elements can be stored without reallocation. Capacity is always >= size and grows automatically when needed. You can set initial capacity using constructor ArrayList(int capacity) to avoid frequent reallocations. Methods like ensureCapacity() and trimToSize() help manage capacity explicitly for performance optimization."
  },
  {
    "question": "How does ArrayList grow when it reaches capacity?",
    "answer": "When ArrayList reaches capacity and a new element is added, it creates a new array with increased size (typically 50% larger: newCapacity = oldCapacity + (oldCapacity >> 1)), copies all existing elements to the new array, and replaces the old array. This operation is O(n) and can be expensive for large lists. To minimize growth operations, initialize ArrayList with appropriate initial capacity if the approximate size is known."
  },
  {
    "question": "What is the difference between Iterator and Spliterator?",
    "answer": "Iterator provides sequential traversal with hasNext(), next(), and remove() methods, designed for single-threaded use. Spliterator (Splittable Iterator) supports both sequential and parallel traversal, designed for parallel processing with methods like tryAdvance(), forEachRemaining(), trySplit() for splitting into multiple spliterators. Spliterator enables efficient parallel stream operations and provides characteristics like ORDERED, DISTINCT, SORTED, SIZED for optimization."
  },
  {
    "question": "What are the characteristics of Spliterator?",
    "answer": "Spliterator characteristics help optimize parallel processing: 1) ORDERED - elements have defined order, 2) DISTINCT - no duplicate elements, 3) SORTED - elements are sorted, 4) SIZED - exact size is known, 5) NONNULL - no null elements, 6) IMMUTABLE - elements cannot be modified, 7) CONCURRENT - can be safely used concurrently, 8) SUBSIZED - split results have known size. These characteristics allow the parallel stream framework to apply appropriate optimizations."
  },
  {
    "question": "What is the difference between parallel() and sequential() in streams?",
    "answer": "parallel() converts a sequential stream to parallel stream, enabling operations to be executed concurrently across multiple threads using ForkJoinPool. sequential() converts parallel stream back to sequential processing. Parallel streams can improve performance for CPU-intensive operations on large datasets, but have overhead for thread management and coordination. Use parallel streams carefully - they're beneficial for substantial computational work but can harm performance for simple operations or small datasets."
  },
  {
    "question": "What is ForkJoinPool and how does it relate to parallel streams?",
    "answer": "ForkJoinPool is a thread pool designed for work-stealing algorithm, where idle threads steal work from busy threads. It's optimized for divide-and-conquer algorithms. Parallel streams use the common ForkJoinPool by default (ForkJoinPool.commonPool()) with parallelism level typically equal to number of CPU cores. ForkJoinPool efficiently manages parallel stream operations by recursively splitting tasks and distributing them across available threads, then combining results."
  },
  {
    "question": "What is CompletableFuture and how is it different from Future?",
    "answer": "Future represents result of asynchronous computation but is limited - you can only check if done and get result (blocking). CompletableFuture extends Future and provides extensive API for composing, combining, and handling asynchronous computations. It supports: 1) Non-blocking callbacks with thenApply(), thenAccept(), 2) Composition with thenCompose(), 3) Combining multiple futures with thenCombine(), 4) Exception handling with exceptionally(), handle(), 5) Manual completion with complete(), completeExceptionally()."
  },
  {
    "question": "What are the different methods to create CompletableFuture?",
    "answer": "CompletableFuture creation methods: 1) CompletableFuture.completedFuture(value) - already completed future, 2) CompletableFuture.supplyAsync(supplier) - async computation returning value, 3) CompletableFuture.runAsync(runnable) - async computation without return, 4) new CompletableFuture<>() - manual completion, 5) CompletableFuture.allOf()/anyOf() - combining multiple futures. Methods can optionally take Executor parameter for custom thread pool instead of default ForkJoinPool.commonPool()."
  },
  {
    "question": "What is the difference between checked and unchecked exceptions in terms of compilation?",
    "answer": "Checked exceptions must be either caught using try-catch blocks or declared in the method signature using the throws keyword at compile time. If not handled, the code will not compile. Unchecked exceptions (RuntimeException and its subclasses) do not need to be explicitly handled or declared - the code will compile even if they are not caught. Examples of checked exceptions include IOException and SQLException, while unchecked exceptions include NullPointerException and IllegalArgumentException."
  },
  {
    "question": "What is the purpose of the throws keyword in Java method declarations?",
    "answer": "The throws keyword is used in method signatures to declare that a method might throw one or more checked exceptions. It serves as a contract between the method and its callers, informing them about potential exceptions they need to handle. When a method declares throws SomeException, any code calling that method must either catch the exception or propagate it further using throws in their own method signature."
  },
  {
    "question": "Can you have multiple catch blocks for the same try block?",
    "answer": "Yes, you can have multiple catch blocks for a single try block to handle different types of exceptions. The catch blocks are evaluated in order from top to bottom, and the first matching catch block is executed. It's important to arrange catch blocks from most specific to most general exceptions, as a more general exception type will catch all its subtypes, making subsequent catch blocks unreachable."
  },
  {
    "question": "What is the difference between throw and throws in Java?",
    "answer": "The 'throw' keyword is used to explicitly throw an exception from within a method or block of code. It is followed by an instance of an exception. The 'throws' keyword is used in method declarations to specify that the method might throw certain exceptions. 'throw' is used for actual exception throwing, while 'throws' is used for exception declaration. Example: throw new IllegalArgumentException() vs. public void method() throws IOException."
  },
  {
    "question": "What are custom exceptions and how do you create them in Java?",
    "answer": "Custom exceptions are user-defined exception classes that extend either Exception (for checked exceptions) or RuntimeException (for unchecked exceptions). They are created to represent specific error conditions in your application. To create a custom exception, you define a class that extends Exception or RuntimeException, typically providing constructors that accept error messages. Custom exceptions help in creating more meaningful and specific error handling for your application domain."
  },
  {
    "question": "What is exception chaining in Java?",
    "answer": "Exception chaining is the ability to associate one exception with another exception, creating a chain of exceptions that shows the complete path of error propagation. This is done using the 'cause' parameter in exception constructors or the initCause() method. Exception chaining helps in debugging by preserving the original exception information while wrapping it in a more appropriate exception for the current context. The getCause() method can be used to retrieve the underlying cause of an exception."
  },
  {
    "question": "What is the difference between FileInputStream and FileReader in Java?",
    "answer": "FileInputStream is used for reading raw binary data from files, working with bytes. It's suitable for reading binary files like images, videos, or any non-text files. FileReader is used for reading character data from files, automatically handling character encoding. It's designed for text files and converts bytes to characters using the default character encoding. FileReader is essentially a convenience class built on top of FileInputStream with an InputStreamReader."
  },
  {
    "question": "What is the difference between BufferedReader and Scanner for reading input?",
    "answer": "BufferedReader is more efficient for reading large amounts of text data as it reads chunks of data into a buffer, reducing the number of I/O operations. It's faster and uses less memory overhead. Scanner is more convenient and feature-rich, providing methods to parse different data types (nextInt(), nextDouble(), etc.) and handle delimiters and patterns. Scanner has more overhead but offers more functionality for parsing input. BufferedReader is preferred for performance-critical applications, while Scanner is better for convenience and parsing."
  },
  {
    "question": "What is serialVersionUID in Java serialization?",
    "answer": "serialVersionUID is a unique identifier for each Serializable class used during deserialization to verify that the sender and receiver of a serialized object have loaded classes that are compatible with respect to serialization. If the serialVersionUID of the serialized object doesn't match the serialVersionUID of the class in the JVM during deserialization, an InvalidClassException is thrown. It's recommended to explicitly declare serialVersionUID as a static final long field to maintain version control of serialized objects."
  },
  {
    "question": "What are the advantages and disadvantages of Java serialization?",
    "answer": "Advantages include: automatic handling of object graphs, built-in support in JVM, preservation of object state including private fields, and handling of circular references. Disadvantages include: platform dependency (Java-specific), security vulnerabilities, performance overhead, version compatibility issues, and large serialized object sizes. The process can be slow and the resulting byte streams are not human-readable. For these reasons, alternatives like JSON, XML, or Protocol Buffers are often preferred for data exchange."
  },
  {
    "question": "What is Externalization in Java and how is it different from Serialization?",
    "answer": "Externalization is a customized form of serialization where the programmer has complete control over the serialization process. A class implements the Externalizable interface and provides custom implementations of writeExternal() and readExternal() methods. Unlike default serialization, externalization requires explicit handling of all fields, offers better performance, smaller serialized output, and more control over the process. However, it requires more coding effort and the programmer must handle versioning manually."
  },
  {
    "question": "What is the purpose of the ObjectInputStream and ObjectOutputStream classes?",
    "answer": "ObjectInputStream and ObjectOutputStream are used for object serialization and deserialization in Java. ObjectOutputStream converts Java objects into a stream of bytes that can be written to files, sent over networks, or stored in databases using the writeObject() method. ObjectInputStream reverses this process, reading the byte stream and reconstructing the original Java objects using readObject(). These classes handle the complex process of converting object graphs, including handling references and maintaining object relationships."
  },
  {
    "question": "What is the NIO package in Java and how is it different from traditional I/O?",
    "answer": "NIO (New I/O) is a more efficient I/O API introduced in Java 1.4, designed for high-performance I/O operations. Key differences from traditional I/O include: NIO is non-blocking (can continue processing while I/O operations are pending), uses channels and buffers instead of streams, supports selectors for multiplexing I/O operations, and provides memory-mapped file access. NIO is more suitable for server applications handling many concurrent connections, while traditional I/O is simpler for basic file operations."
  },
  {
    "question": "What are Channels and Buffers in Java NIO?",
    "answer": "Channels represent connections to entities capable of I/O operations (files, sockets, etc.) and are bidirectional, meaning you can read and write through the same channel. Buffers are containers for data that work with channels - data is read from channels into buffers and written from buffers to channels. Buffers have capacity, position, and limit properties that manage data flow. This design provides more control over I/O operations and better performance for large-scale applications compared to traditional stream-based I/O."
  },
  {
    "question": "What is a Selector in Java NIO and what is its purpose?",
    "answer": "A Selector is a component that can monitor multiple channels for events such as connection opened, data arrived, etc. It enables a single thread to manage multiple channels efficiently, which is the foundation of non-blocking I/O. The selector allows you to register channels with it and then use a single thread to select the channels that are ready for processing. This is particularly useful in server applications where you need to handle many client connections simultaneously without creating a thread for each connection."
  },
  {
    "question": "What is the difference between Path and File classes in Java?",
    "answer": "The File class is part of the older java.io package and represents a file or directory path, but it has limitations like poor error handling and limited metadata support. The Path interface, introduced in Java 7 as part of NIO.2, is more modern and flexible. Path represents a file system path and provides better error handling, more operations, and works with the Files utility class. Path is more efficient, provides better exception handling, and supports modern file system features like symbolic links."
  },
  {
    "question": "What are the advantages of using try-with-resources over traditional try-catch-finally?",
    "answer": "Try-with-resources automatically closes resources that implement AutoCloseable or Closeable interfaces, eliminating the need for explicit finally blocks. Advantages include: automatic resource management prevents resource leaks, cleaner and more readable code, proper handling of exceptions during resource closing, and reduction of boilerplate code. If an exception occurs in both the try block and when closing the resource, the original exception is preserved and the closing exception is suppressed, making debugging easier."
  },
  {
    "question": "What is the AutoCloseable interface in Java?",
    "answer": "AutoCloseable is a functional interface introduced in Java 7 that defines a close() method for automatically managing resources. Classes implementing AutoCloseable can be used in try-with-resources statements, ensuring that the close() method is called automatically when exiting the try block. This interface is broader than Closeable as it allows close() to throw any Exception, not just IOException. Most resource classes like file streams, database connections, and network connections implement this interface."
  },
  {
    "question": "What is the difference between Reader/Writer and InputStream/OutputStream?",
    "answer": "InputStream and OutputStream are abstract classes for reading and writing binary data (bytes). They are used for handling binary files, images, videos, and any raw data. Reader and Writer are abstract classes for reading and writing character data (text). They handle character encoding and decoding automatically, making them suitable for text files. Reader/Writer classes internally use InputStream/OutputStream but add a layer of character encoding/decoding, making them more appropriate for text-based operations."
  },
  {
    "question": "What are annotations in Java and how are they used?",
    "answer": "Annotations in Java are metadata that provide information about the program but are not part of the program itself. They don't directly affect program semantics but can be used by the compiler, development tools, or at runtime through reflection. Annotations are declared using the @interface keyword and applied using the @ symbol. Common built-in annotations include @Override, @Deprecated, @SuppressWarnings. They are widely used in frameworks like Spring for dependency injection, JPA for ORM mapping, and testing frameworks for test configuration."
  },
  {
    "question": "What is the difference between @Override, @Deprecated, and @SuppressWarnings annotations?",
    "answer": "@Override indicates that a method is intended to override a method in a superclass, helping catch errors if the method signature doesn't match. @Deprecated marks a program element as deprecated, warning developers not to use it and suggesting alternatives. @SuppressWarnings tells the compiler to suppress specific warnings for the annotated element. These are built-in annotations that help with code quality, maintenance, and compiler feedback."
  },
  {
    "question": "How do you create custom annotations in Java?",
    "answer": "Custom annotations are created using the @interface keyword. You can define methods in the annotation to specify parameters, provide default values using the default keyword, and use meta-annotations like @Retention, @Target, and @Documented to control the annotation's behavior. Example: @interface MyAnnotation { String value() default \"default\"; int priority() default 1; }. The retention policy determines how long the annotation is retained (source, class, or runtime), and the target specifies where the annotation can be applied."
  },
  {
    "question": "What are meta-annotations in Java?",
    "answer": "Meta-annotations are annotations that can be applied to other annotations to control their behavior. The main meta-annotations are: @Retention (specifies how long the annotation is retained - SOURCE, CLASS, or RUNTIME), @Target (specifies where the annotation can be applied - TYPE, METHOD, FIELD, etc.), @Documented (indicates the annotation should be included in JavaDoc), @Inherited (allows annotation to be inherited by subclasses), and @Repeatable (allows the same annotation to be applied multiple times)."
  },
  {
    "question": "What is reflection and how can it be used to read annotations at runtime?",
    "answer": "Reflection allows inspection and manipulation of classes, methods, and fields at runtime. To read annotations at runtime, you use methods like getAnnotation(), isAnnotationPresent(), and getAnnotations() on Class, Method, or Field objects. The annotation must have @Retention(RetentionPolicy.RUNTIME) to be available at runtime. Example: Method method = obj.getClass().getMethod(\"methodName\"); MyAnnotation annotation = method.getAnnotation(MyAnnotation.class); This enables frameworks to process annotations and configure behavior dynamically."
  },
  {
    "question": "What is generics in Java and why was it introduced?",
    "answer": "Generics allow you to write code that works with different types while providing compile-time type safety. Introduced in Java 5, generics enable you to create classes, interfaces, and methods with type parameters. Benefits include: compile-time type checking (eliminating ClassCastException at runtime), elimination of type casting, enabling generic algorithms that work with different types, and better code readability. Example: List<String> instead of raw List ensures only String objects can be added."
  },
  {
    "question": "What is type erasure in Java generics?",
    "answer": "Type erasure is the process by which generic type information is removed during compilation. At runtime, generic types are replaced with their raw types or upper bounds, and type parameters are erased. This maintains backward compatibility with pre-generic Java code. Consequences include: inability to create arrays of generic types, cannot use instanceof with generic types, cannot catch generic exception types, and generic type information is not available at runtime through reflection."
  },
  {
    "question": "What are bounded type parameters in generics?",
    "answer": "Bounded type parameters restrict the types that can be used as generic arguments. Upper bounds use 'extends' keyword (T extends Number) to specify that the type parameter must be a subtype of the specified class. Lower bounds use 'super' keyword (? super Integer) in wildcards to specify that the type must be a supertype. Multiple bounds are possible using & (T extends Number & Comparable<T>). Bounded parameters enable you to call methods specific to the bound type and provide more type safety."
  },
  {
    "question": "What is the difference between <?>, <? extends T>, and <? super T> wildcards?",
    "answer": "<?> is an unbounded wildcard representing an unknown type, useful when you don't need to know the specific type. <? extends T> is an upper-bounded wildcard, meaning the unknown type is T or a subtype of T - used for reading data (producer). <? super T> is a lower-bounded wildcard, meaning the unknown type is T or a supertype of T - used for writing data (consumer). This follows the PECS principle: Producer Extends, Consumer Super, helping determine which wildcard to use based on whether you're reading from or writing to the collection."
  },
  {
    "question": "What are generic methods and how do you define them?",
    "answer": "Generic methods are methods that introduce their own type parameters, independent of the class's generic parameters. They are defined by placing type parameters in angle brackets before the return type. Example: public <T> T genericMethod(T param) { return param; }. Generic methods can be static or non-static and can have bounded type parameters. They're useful when you need generic behavior in a specific method without making the entire class generic, or when you need different type parameters than those defined at the class level."
  },
  {
    "question": "What is the diamond operator in Java generics?",
    "answer": "The diamond operator (<>) was introduced in Java 7 to reduce verbosity in generic instantiation. Instead of repeating generic type parameters on both sides of an assignment, you can use empty angle brackets on the right side. Example: List<String> list = new ArrayList<>(); instead of List<String> list = new ArrayList<String>();. The compiler infers the generic type from the left side of the assignment, making code cleaner while maintaining type safety."
  },
  {
    "question": "What are raw types in Java and why should they be avoided?",
    "answer": "Raw types are generic classes or interfaces used without type parameters, essentially treating them as they existed before generics. Example: List instead of List<String>. Raw types should be avoided because they bypass generic type checking, leading to potential ClassCastException at runtime, loss of type safety, compiler warnings, and inability to take advantage of generic benefits. They exist only for backward compatibility with pre-Java 5 code. Modern code should always use parameterized types."
  },
  {
    "question": "What is the Comparable interface and how is it used?",
    "answer": "Comparable is a generic interface that defines natural ordering for objects of classes that implement it. It contains a single method compareTo(T o) that returns a negative integer, zero, or positive integer if the current object is less than, equal to, or greater than the specified object. Classes implementing Comparable can be sorted using Collections.sort() or Arrays.sort() without providing a custom comparator. Example: String, Integer, and Date implement Comparable for their natural ordering."
  },
  {
    "question": "What is the Comparator interface and when should you use it over Comparable?",
    "answer": "Comparator is a functional interface that defines a comparison function for objects that don't implement Comparable or when you need multiple sorting criteria. Unlike Comparable (which defines natural ordering), Comparator provides external comparison logic. Use Comparator when: you can't modify the class to implement Comparable, you need multiple sorting strategies for the same class, or you want to sort by different criteria than the natural ordering. Comparator can be implemented as lambda expressions or method references."
  },
  {
    "question": "What is the Collections.sort() method and how does it work with Comparable and Comparator?",
    "answer": "Collections.sort() is a utility method that sorts List implementations. It has two overloaded versions: one that sorts objects implementing Comparable using their natural ordering, and another that accepts a Comparator for custom sorting logic. The method uses a stable, adaptive merge sort algorithm. When using Comparable, objects must implement compareTo() method. When using Comparator, you provide custom comparison logic. The sort is stable, meaning equal elements maintain their relative order."
  },
  {
    "question": "What is the purpose of the equals() and hashCode() contract in Java?",
    "answer": "The equals() and hashCode() contract ensures consistent behavior in hash-based collections. The contract states: 1) If two objects are equal according to equals(), they must have the same hashCode(), 2) If two objects have the same hashCode(), they may or may not be equal, 3) hashCode() must be consistent (return same value for same object during execution), 4) equals() must be reflexive, symmetric, transitive, consistent, and handle null properly. Violating this contract causes incorrect behavior in HashMap, HashSet, and other hash-based collections."
  },
  {
    "question": "What happens if you override equals() but not hashCode() or vice versa?",
    "answer": "If you override equals() but not hashCode(), objects that are equal according to equals() may have different hash codes, violating the contract. This causes problems in hash-based collections where equal objects might be stored in different buckets, leading to duplicates in HashSet or inability to retrieve values from HashMap. If you override hashCode() but not equals(), you might have objects with same hash code but considered unequal, causing performance issues due to hash collisions. Always override both methods together."
  },
  {
    "question": "What is the difference between == and equals() method in Java?",
    "answer": "The == operator compares references for objects (checking if two references point to the same memory location) and values for primitives. The equals() method compares the actual content of objects for logical equality. For objects, == checks identity while equals() checks equality. String s1 = \"hello\"; String s2 = \"hello\"; makes s1 == s2 true due to string interning, but String s1 = new String(\"hello\"); String s2 = new String(\"hello\"); makes s1 == s2 false while s1.equals(s2) is true."
  },
  {
    "question": "What is string interning in Java and how does it work?",
    "answer": "String interning is the process of storing only one copy of each distinct string value in the string pool. When you create a string literal, Java checks the string pool first. If the string exists, it returns the reference to the existing string; otherwise, it creates a new string and adds it to the pool. The intern() method can be used to manually add strings to the pool. String interning saves memory by avoiding duplicate string objects but can impact performance if overused, especially with dynamically created strings."
  },
  {
    "question": "What is the difference between String, StringBuffer, and StringBuilder performance-wise?",
    "answer": "String is immutable, so any modification creates a new object, making it inefficient for multiple concatenations (O(n²) complexity for n concatenations). StringBuffer is mutable and thread-safe (synchronized), providing better performance than String for modifications but with synchronization overhead. StringBuilder is mutable and not thread-safe, making it the fastest for string manipulations in single-threaded environments. For performance: StringBuilder > StringBuffer > String for multiple modifications. Use String for few operations, StringBuilder for many operations in single-threaded code, StringBuffer for multi-threaded scenarios."
  },
  {
    "question": "What are the different ways to create threads in Java beyond Thread and Runnable?",
    "answer": "Beyond extending Thread class and implementing Runnable, you can create threads using: 1) Callable interface with ExecutorService for tasks that return results, 2) TimerTask for scheduled tasks, 3) ForkJoinTask for parallel processing with work-stealing, 4) CompletableFuture for asynchronous programming, 5) Lambda expressions with Runnable, 6) Method references, 7) Thread pools using Executors utility class. Each approach has specific use cases: Callable for return values, TimerTask for scheduling, ForkJoinTask for divide-and-conquer algorithms."
  },
  {
    "question": "What is the ExecutorService and how is it different from directly creating threads?",
    "answer": "ExecutorService is a higher-level interface for managing and controlling thread execution. It provides thread pools, task queuing, and lifecycle management. Advantages over direct thread creation include: reuse of threads (avoiding creation/destruction overhead), better resource management, built-in task queuing, graceful shutdown capabilities, and various thread pool implementations (fixed, cached, scheduled). ExecutorService handles thread lifecycle automatically, provides better scalability, and offers features like task cancellation and result retrieval through Future objects."
  },
  {
    "question": "What are the different types of thread pools provided by the Executors class?",
    "answer": "The Executors class provides several thread pool implementations: 1) newFixedThreadPool(n) - fixed number of threads, good for stable workloads, 2) newCachedThreadPool() - creates threads as needed, suitable for many short-lived tasks, 3) newSingleThreadExecutor() - single thread for sequential task execution, 4) newScheduledThreadPool(n) - for delayed and periodic task execution, 5) newWorkStealingPool() - work-stealing pool for parallel processing. Each type is optimized for different scenarios based on task characteristics and performance requirements."
  },
  {
    "question": "What is the Future interface and how is it used with ExecutorService?",
    "answer": "Future represents the result of an asynchronous computation, providing methods to check if computation is complete, wait for completion, and retrieve results. Key methods include: get() to retrieve result (blocking), get(timeout) for timed waiting, cancel() to cancel execution, isDone() to check completion status, and isCancelled() to check cancellation status. When you submit a Callable to ExecutorService, it returns a Future object. Future enables you to perform other tasks while waiting for asynchronous computation results."
  },
  {
    "question": "What is the Callable interface and how is it different from Runnable?",
    "answer": "Callable is similar to Runnable but can return a result and throw checked exceptions. Runnable's run() method returns void and cannot throw checked exceptions, while Callable's call() method returns a generic type V and can throw Exception. Callable is used with ExecutorService to submit tasks that need to return results. You cannot start a thread directly with Callable - it must be submitted to an ExecutorService, which returns a Future object representing the pending result of the computation."
  },
  {
    "question": "What is deadlock in multithreading and how can it be prevented?",
    "answer": "Deadlock occurs when two or more threads are blocked forever, each waiting for the other to release a resource. It happens when threads acquire locks in different orders. Prevention strategies include: 1) Lock ordering - always acquire locks in the same order, 2) Lock timeout - use tryLock() with timeout, 3) Deadlock detection - monitor and break deadlocks when detected, 4) Avoid nested locks when possible, 5) Use higher-level concurrency utilities like java.util.concurrent classes. The banker's algorithm can also be used for deadlock avoidance in complex scenarios."
  },
  {
    "question": "What is the difference between synchronized methods and synchronized blocks?",
    "answer": "Synchronized methods lock the entire method using the object's intrinsic lock (this for instance methods, Class object for static methods). Synchronized blocks allow more granular control by specifying which object to lock and which code section to synchronize. Synchronized blocks can improve performance by reducing the synchronized code scope, allow locking on different objects, and provide more flexibility in lock management. Use synchronized methods for simplicity when the entire method needs synchronization, and synchronized blocks for fine-grained control."
  },
  {
    "question": "What are atomic operations and how do AtomicInteger and other atomic classes work?",
    "answer": "Atomic operations are indivisible operations that complete entirely or not at all, without interference from other threads. Java's atomic classes (AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference) use low-level atomic hardware primitives to provide lock-free thread-safe operations. They offer methods like compareAndSet(), incrementAndGet(), addAndGet() that are atomic. Atomic classes are more efficient than synchronized blocks for simple operations as they avoid the overhead of acquiring and releasing locks, using CPU-level atomic instructions instead."
  },
  {
    "question": "What is the volatile keyword and when should it be used?",
    "answer": "The volatile keyword ensures that reads and writes to a variable are directly performed on main memory, not CPU cache, providing visibility guarantees across threads. It prevents instruction reordering around volatile variables and ensures that changes made by one thread are immediately visible to other threads. Use volatile for: flags indicating state changes, double-checked locking patterns, and variables that are written by one thread and read by others. However, volatile doesn't provide atomicity for compound operations like increment, so use atomic classes for such operations."
  },
  {
    "question": "What is the CountDownLatch and how is it used?",
    "answer": "CountDownLatch is a synchronization utility that allows one or more threads to wait until a set of operations being performed by other threads completes. It's initialized with a count, and threads can wait using await() until the count reaches zero through countDown() calls. Common use cases include: waiting for multiple services to start before proceeding, coordinating parallel task completion, and implementing barriers where threads wait for each other. Once the count reaches zero, all waiting threads are released, and the latch cannot be reset."
  },
  {
    "question": "What is CyclicBarrier and how is it different from CountDownLatch?",
    "answer": "CyclicBarrier is a synchronization point where a fixed number of threads wait for each other to reach the barrier before proceeding. Key differences from CountDownLatch: CyclicBarrier is reusable (cyclic) after all threads reach the barrier, while CountDownLatch is one-time use. CyclicBarrier waits for threads to reach the barrier point (await()), while CountDownLatch waits for events to occur (countDown()). CyclicBarrier can execute a barrier action when all threads reach the barrier. Use CyclicBarrier for repetitive parallel processing phases, CountDownLatch for one-time coordination."
  },
  {
    "question": "What are the security concerns when using reflection in Java?",
    "answer": "Security concerns with reflection include: 1) Bypassing access control by accessing private fields and methods, potentially breaking encapsulation, 2) Risk of malicious code exploiting reflection to access sensitive data or methods, 3) SecurityManager restrictions that may need to be configured to limit reflection usage, 4) Potential for code injection attacks if reflection is used with user-provided class names or method names, 5) Breaking the principle of least privilege by allowing access to internal implementation details. To mitigate these risks, use reflection judiciously, validate inputs when using dynamic class loading, implement proper security policies, and avoid using reflection with untrusted data."
  },
  {
    "question": "What is the difference between Class.forName() and ClassLoader.loadClass()?",
    "answer": "Class.forName() and ClassLoader.loadClass() both load classes but have key differences: 1) Class.forName() loads and initializes the class (runs static blocks and initializes static fields), while ClassLoader.loadClass() only loads the class without initialization, 2) Class.forName() uses the current thread's context class loader by default, while ClassLoader.loadClass() uses the specific ClassLoader instance, 3) Class.forName() is more commonly used for simple class loading scenarios, while ClassLoader.loadClass() provides more control over the loading process, 4) Class.forName() throws ClassNotFoundException directly, while ClassLoader.loadClass() may throw different exceptions depending on the loader implementation."
  },
  {
    "question": "How do you create dynamic proxies in Java using reflection?",
    "answer": "Dynamic proxies in Java are created using the Proxy class and InvocationHandler interface: 1) Create an InvocationHandler implementation that defines how method calls should be handled, 2) Use Proxy.newProxyInstance() with the class loader, interfaces to implement, and the InvocationHandler, 3) The proxy intercepts method calls and forwards them to the InvocationHandler's invoke() method. Example: MyHandler handler = new MyHandler(); MyInterface proxy = (MyInterface) Proxy.newProxyInstance(MyInterface.class.getClassLoader(), new Class[]{MyInterface.class}, handler). Dynamic proxies are useful for implementing cross-cutting concerns like logging, security, or transaction management."
  },
  {
    "question": "What are annotations in Java and how are they processed using reflection?",
    "answer": "Annotations in Java are metadata that provide information about program elements without affecting program semantics. They are processed using reflection through: 1) isAnnotationPresent() to check if an annotation exists, 2) getAnnotation() to retrieve a specific annotation, 3) getAnnotations() to get all annotations, 4) getDeclaredAnnotations() to get annotations declared directly on the element. Annotations must have @Retention(RetentionPolicy.RUNTIME) to be available at runtime. Example: if (method.isAnnotationPresent(MyAnnotation.class)) { MyAnnotation annotation = method.getAnnotation(MyAnnotation.class); }. This enables frameworks to process annotations and configure behavior dynamically."
  },
  {
    "question": "What is the difference between InputStream and OutputStream in Java?",
    "answer": "InputStream and OutputStream are abstract classes for handling binary data streams: 1) InputStream is for reading data from a source (like files, network connections, or arrays), with key methods like read(), available(), and close(), 2) OutputStream is for writing data to a destination, with methods like write(), flush(), and close(), 3) Both handle byte-oriented data and are the foundation for all binary I/O operations in Java, 4) Common implementations include FileInputStream/FileOutputStream for files, ByteArrayInputStream/ByteArrayOutputStream for memory, and DataInputStream/DataOutputStream for primitive data types. They form the basis of Java's I/O hierarchy and are used extensively in file operations, network communication, and data processing."
  },
  {
    "question": "What are Reader and Writer classes in Java and when should you use them?",
    "answer": "Reader and Writer are abstract classes for handling character-based I/O operations: 1) Reader is for reading character data with automatic character encoding handling, providing methods like read(), ready(), and close(), 2) Writer is for writing character data with proper encoding, offering write(), flush(), and close() methods, 3) Use Reader/Writer for text data and InputStream/OutputStream for binary data, 4) Common implementations include FileReader/FileWriter for files, StringReader/StringWriter for strings, and BufferedReader/BufferedWriter for buffered operations. They automatically handle character encoding conversions, making them ideal for text processing, file reading/writing, and internationalization scenarios where character encoding matters."
  },
  {
    "question": "What is the purpose of BufferedReader and BufferedWriter?",
    "answer": "BufferedReader and BufferedWriter provide buffered I/O operations to improve performance: 1) They wrap other Reader/Writer streams and read/write data in chunks (buffers) rather than one character at a time, 2) BufferedReader offers additional methods like readLine() for reading entire lines, 3) Buffering reduces the number of system calls, significantly improving I/O performance, especially for small, frequent operations, 4) Default buffer size is usually 8192 characters, but can be customized, 5) Always call flush() on BufferedWriter to ensure all buffered data is written, and close() automatically flushes. They are essential for efficient file I/O and text processing operations where performance matters."
  },
  {
    "question": "What are DataInputStream and DataOutputStream used for?",
    "answer": "DataInputStream and DataOutputStream are used for reading and writing primitive Java data types in a portable, machine-independent format: 1) DataInputStream provides methods like readInt(), readDouble(), readUTF() for reading primitive types from an input stream, 2) DataOutputStream provides writeInt(), writeDouble(), writeUTF() for writing primitive types to an output stream, 3) They handle byte ordering and format conversion automatically, ensuring data written by DataOutputStream can be read correctly by DataInputStream regardless of platform, 4) Commonly used for network protocols, file formats, and serialization where you need to exchange primitive data between systems. They ensure data integrity and portability across different platforms and architectures."
  },
  {
    "question": "What is object serialization in Java and how does it work?",
    "answer": "Object serialization is the process of converting Java objects into a byte stream for storage or transmission: 1) Classes must implement Serializable interface to be serializable, 2) Use ObjectOutputStream.writeObject() to serialize and ObjectInputStream.readObject() to deserialize, 3) All non-transient and non-static fields are serialized recursively, 4) serialVersionUID helps maintain compatibility across versions, 5) transient fields are excluded from serialization, 6) Custom serialization can be implemented using writeObject() and readObject() methods. The process preserves object state and relationships, making it useful for persistence, caching, deep copying, and network communication. However, it's Java-specific and can have security implications."
  },
  {
    "question": "What are the security risks associated with Java serialization?",
    "answer": "Java serialization poses several security risks: 1) Deserialization can execute arbitrary code if malicious data is deserialized, leading to remote code execution attacks, 2) Object creation bypasses constructors, potentially creating objects in invalid states, 3) Private fields can be accessed and modified during deserialization, 4) Gadget chains can exploit existing classes to perform malicious operations, 5) Memory exhaustion attacks through deeply nested objects or large arrays, 6) Information disclosure through error messages during deserialization. Mitigation strategies include: validating input data, using whitelisting for allowed classes, implementing custom deserialization with validation, avoiding deserialization of untrusted data, and using safer alternatives like JSON or Protocol Buffers."
  },
  {
    "question": "What is the difference between Serializable and Externalizable interfaces?",
    "answer": "Serializable and Externalizable both enable object serialization but with different approaches: 1) Serializable uses automatic serialization where JVM handles the process, while Externalizable requires manual implementation of writeExternal() and readExternal() methods, 2) Serializable serializes all non-transient fields automatically, while Externalizable gives complete control over what gets serialized, 3) Serializable has performance overhead due to reflection, while Externalizable is faster as it's programmer-controlled, 4) Serializable handles versioning through serialVersionUID, while Externalizable requires manual version handling, 5) Externalizable results in smaller serialized output as you choose exactly what to serialize. Use Serializable for simplicity and automatic handling, Externalizable for performance and precise control."
  },
  {
    "question": "How do you create a simple TCP server in Java?",
    "answer": "Creating a TCP server in Java involves using ServerSocket: 1) Create a ServerSocket bound to a specific port, 2) Use accept() to wait for client connections, which returns a Socket for each client, 3) Get input/output streams from the Socket to communicate with the client, 4) Handle multiple clients using threads. Example: ServerSocket serverSocket = new ServerSocket(8080); Socket clientSocket = serverSocket.accept(); BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true); String request = in.readLine(); out.println(\"Response\"); The server listens continuously, accepts connections, processes requests, and sends responses back to clients."
  },
  {
    "question": "How do you create a TCP client in Java?",
    "answer": "Creating a TCP client in Java uses the Socket class: 1) Create a Socket connecting to the server's IP address and port, 2) Get input/output streams to communicate with the server, 3) Send requests and read responses, 4) Close the connection when done. Example: Socket socket = new Socket(\"localhost\", 8080); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); out.println(\"Hello Server\"); String response = in.readLine(); socket.close(); The client establishes connection, exchanges data with the server, and properly closes the connection to free resources."
  },
  {
    "question": "What is the difference between TCP and UDP in Java networking?",
    "answer": "TCP and UDP are different transport protocols with distinct characteristics in Java: 1) TCP (Socket/ServerSocket) is connection-oriented, reliable, guarantees data delivery and order, but has higher overhead. UDP (DatagramSocket/DatagramPacket) is connectionless, fast, but doesn't guarantee delivery or order, 2) TCP automatically handles lost packets, flow control, and error correction. UDP requires manual handling of reliability if needed, 3) TCP is suitable for applications requiring data integrity like web browsing, file transfer, email. UDP is ideal for real-time applications like gaming, video streaming, DNS queries where speed matters more than reliability, 4) TCP has built-in congestion control, UDP doesn't, 5) TCP streams data continuously, UDP sends discrete packets."
  },
  {
    "question": "How do you send and receive UDP packets in Java?",
    "answer": "UDP communication in Java uses DatagramSocket and DatagramPacket: For sending: 1) Create a DatagramSocket, 2) Create a DatagramPacket with data, destination IP, and port, 3) Use socket.send(packet). For receiving: 1) Create a DatagramSocket bound to a port, 2) Create an empty DatagramPacket with buffer, 3) Use socket.receive(packet) to receive data. Example: DatagramSocket socket = new DatagramSocket(); byte[] data = \"Hello\".getBytes(); InetAddress address = InetAddress.getByName(\"localhost\"); DatagramPacket packet = new DatagramPacket(data, data.length, address, 9876); socket.send(packet); For receiving, create packet with buffer and call receive(). UDP is suitable for scenarios where speed is more important than guaranteed delivery."
  },
  {
    "question": "What is URL and URLConnection in Java networking?",
    "answer": "URL and URLConnection classes provide high-level networking capabilities: 1) URL represents a Uniform Resource Locator, providing methods to parse and access URL components like protocol, host, port, and path, 2) URLConnection is an abstract class representing a communication link between application and URL resource, obtained via url.openConnection(), 3) HttpURLConnection extends URLConnection for HTTP-specific operations, providing methods for setting request methods, headers, and handling responses, 4) These classes simplify HTTP requests compared to raw socket programming, 5) URL can be used for reading content directly with openStream(), while URLConnection provides more control over request/response handling. They're commonly used for web service calls, REST API communication, and downloading web content."
  },
  {
    "question": "How do you make HTTP requests in Java without external libraries?",
    "answer": "Making HTTP requests in Java without external libraries uses URLConnection: 1) Create URL object with the target URL, 2) Open connection using url.openConnection(), cast to HttpURLConnection for HTTP-specific methods, 3) Set request method (GET, POST, etc.) and headers, 4) For POST requests, enable output and write data to output stream, 5) Read response using input stream. Example: URL url = new URL(\"https://api.example.com\"); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"GET\"); conn.setRequestProperty(\"Accept\", \"application/json\"); BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream())); This approach works for simple HTTP operations but lacks advanced features provided by libraries like Apache HttpClient."
  },
  {
    "question": "What is NIO (New I/O) in Java and how is it different from traditional I/O?",
    "answer": "NIO (New I/O) is a more efficient I/O API introduced in Java 1.4: 1) Traditional I/O is blocking and stream-oriented, while NIO is non-blocking and buffer-oriented, 2) NIO uses channels (bidirectional) instead of streams (unidirectional), and buffers for data transfer, 3) Selectors allow a single thread to monitor multiple channels, enabling efficient handling of many concurrent connections, 4) NIO supports memory-mapped files for very fast file access, 5) Traditional I/O blocks threads until operations complete, while NIO can continue processing while I/O operations are pending. NIO is more suitable for high-performance server applications handling many connections, while traditional I/O is simpler for basic file operations and sequential processing."
  },
  {
    "question": "What are Channels and Buffers in Java NIO?",
    "answer": "Channels and Buffers are core concepts in Java NIO: 1) Channels represent connections to I/O sources/destinations (files, sockets) and are bidirectional, unlike streams which are unidirectional, 2) Key channel types include FileChannel (files), SocketChannel (TCP sockets), ServerSocketChannel (server sockets), and DatagramChannel (UDP), 3) Buffers are containers for data with properties: capacity (total size), position (current index), and limit (first index that shouldn't be read/written), 4) Buffer types correspond to primitive types: ByteBuffer, CharBuffer, IntBuffer, etc., 5) Data flows: write data to buffer, flip buffer to prepare for reading, read data from buffer, clear/compact buffer for reuse. This design provides more control and efficiency for I/O operations."
  },
  {
    "question": "What is a Selector in Java NIO and how does it enable non-blocking I/O?",
    "answer": "A Selector in Java NIO enables a single thread to monitor multiple channels for I/O readiness: 1) Channels register with a Selector for specific events (read, write, connect, accept), 2) The select() method blocks until at least one registered channel is ready for I/O, 3) selectedKeys() returns channels that are ready for operations, 4) This allows one thread to handle multiple connections efficiently, instead of requiring one thread per connection. Process: create Selector, register channels with interest operations, call select() to wait for events, process ready channels, repeat. This is the foundation of scalable server architectures, enabling thousands of concurrent connections with minimal threads. It's particularly useful for server applications dealing with many idle connections."
  },
  {
    "question": "What is memory-mapped file I/O in Java?",
    "answer": "Memory-mapped file I/O in Java allows treating files as if they were in memory: 1) Use FileChannel.map() to create a MappedByteBuffer that maps file contents directly to virtual memory, 2) Operating system handles loading file pages into memory on-demand and writing changes back to disk, 3) Provides very fast access to large files since no explicit read/write calls are needed, 4) Changes to the buffer are automatically reflected in the file, 5) Multiple processes can map the same file for efficient data sharing. Example: RandomAccessFile file = new RandomAccessFile(\"data.txt\", \"rw\"); FileChannel channel = file.getChannel(); MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, file.length()); This is ideal for processing large files, databases, and applications requiring high-performance file access."
  },
  {
    "question": "What are the benefits and drawbacks of using Java NIO?",
    "answer": "Benefits of Java NIO: 1) Higher scalability - single thread can handle many connections, 2) Better performance for I/O-intensive applications with non-blocking operations, 3) Memory-mapped files provide very fast file access, 4) More control over I/O operations with buffers and channels, 5) Efficient for server applications handling many concurrent connections. Drawbacks: 1) Increased complexity compared to traditional I/O, 2) Steeper learning curve with concepts like buffers, channels, and selectors, 3) More difficult to debug and troubleshoot, 4) Not always faster for simple, sequential I/O operations, 5) Potential for more bugs due to complexity, 6) Buffer management requires careful attention to position, limit, and capacity. Choose NIO for high-performance, scalable applications; use traditional I/O for simpler scenarios."
  },
  {
    "question": "What is a lambda expression in Java and what are its components?",
    "answer": "A lambda expression is a concise way to represent anonymous functions introduced in Java 8: 1) Syntax: (parameters) -> expression or (parameters) -> { statements }, 2) Components include parameter list (can be empty, single, or multiple), arrow token (->), and body (expression or statement block), 3) Examples: x -> x * 2 (single parameter), (x, y) -> x + y (multiple parameters), () -> System.out.println(\"Hello\") (no parameters), 4) Type inference allows omitting parameter types in most cases, 5) Can only be used with functional interfaces (interfaces with single abstract method), 6) Provides cleaner, more readable code for operations like filtering, mapping, and event handling. Lambda expressions enable functional programming style in Java and work seamlessly with Stream API."
  },
  {
    "question": "What is method reference in Java 8 and what are its types?",
    "answer": "Method reference is a shorthand notation for lambda expressions that simply call an existing method: 1) Syntax uses :: operator, 2) Four types: Static method reference (ClassName::methodName), Instance method reference of particular object (instance::methodName), Instance method reference of arbitrary object (ClassName::methodName), Constructor reference (ClassName::new), 3) Examples: String::valueOf (static), System.out::println (instance), String::length (arbitrary object), ArrayList::new (constructor), 4) Method references make code more readable and concise when lambda simply calls an existing method, 5) They work with functional interfaces and Stream API operations. Use method references when lambda expression only calls a single method, otherwise use lambda expressions for more complex logic."
  },
  {
    "question": "What is the Stream API in Java 8 and what are its key characteristics?",
    "answer": "Stream API provides a functional approach to processing collections of data: 1) Key characteristics: functional programming style, lazy evaluation (operations only execute when terminal operation is called), support for parallel processing, immutable (operations return new streams), 2) Two types of operations: intermediate (filter, map, sorted - return streams) and terminal (collect, forEach, reduce - return results), 3) Streams are not data structures but provide a view of data source, 4) Support method chaining for fluent interfaces, 5) Can process infinite streams with short-circuiting operations. Example: list.stream().filter(x -> x > 5).map(x -> x * 2).collect(Collectors.toList()). Benefits include cleaner code, better readability, and easy parallelization for performance improvements."
  },
  {
    "question": "What are intermediate and terminal operations in Java Streams?",
    "answer": "Stream operations are categorized into intermediate and terminal: 1) Intermediate operations transform streams and return new streams, enabling method chaining - they are lazy and don't execute until a terminal operation is called, 2) Common intermediate operations: filter() (selects elements), map() (transforms elements), sorted() (orders elements), distinct() (removes duplicates), limit() (truncates stream), skip() (skips elements), 3) Terminal operations produce final results and trigger execution of the entire stream pipeline, 4) Common terminal operations: collect() (accumulates to collections), forEach() (performs action on each element), reduce() (combines elements), count() (counts elements), findFirst()/findAny() (retrieves elements). The lazy evaluation means intermediate operations are optimized and only necessary elements are processed."
  },
  {
    "question": "How do you use the collect() method in Java Streams?",
    "answer": "The collect() method is a terminal operation that accumulates stream elements into a collection or other result: 1) Uses Collector interface implementations from Collectors utility class, 2) Common collectors: toList(), toSet(), toMap(), joining() (strings), groupingBy() (grouping), partitioningBy() (splitting), counting(), summingInt(), averaging(), 3) Examples: stream.collect(Collectors.toList()), stream.collect(Collectors.groupingBy(Employee::getDepartment)), stream.collect(Collectors.joining(\", \")), 4) Custom collectors can be created using Collector.of() for specialized accumulation logic, 5) Supports parallel collection for performance, 6) Can collect to concurrent collections for thread safety. The collect() method is essential for converting stream results back to usable data structures."
  },
  {
    "question": "What is the difference between map() and flatMap() in Java Streams?",
    "answer": "map() and flatMap() both transform stream elements but handle nested structures differently: 1) map() applies a function to each element and returns a stream of results - one-to-one transformation, creates Stream<R> from Stream<T>, 2) flatMap() applies a function that returns streams and flattens the results into a single stream - one-to-many transformation, useful for nested collections, 3) Example with map(): Stream.of(\"hello\", \"world\").map(String::toUpperCase) produces Stream<String>, 4) Example with flatMap(): Stream.of([1,2], [3,4]).flatMap(Arrays::stream) produces Stream<Integer> with elements 1,2,3,4, 5) Use map() for simple transformations, flatMap() when dealing with nested structures or when transformation function returns collections/streams. flatMap() is essential for processing nested data structures and avoiding Stream<Stream<T>> scenarios."
  },
  {
    "question": "How do you perform parallel processing with Java Streams?",
    "answer": "Java Streams support parallel processing to utilize multiple CPU cores: 1) Convert sequential stream to parallel using parallelStream() on collections or parallel() on existing streams, 2) Parallel streams use ForkJoinPool.commonPool() by default for thread management, 3) Operations are automatically distributed across available threads, 4) Example: list.parallelStream().filter(condition).map(transformation).collect(Collectors.toList()), 5) Benefits: potential performance improvement for CPU-intensive operations on large datasets, 6) Considerations: overhead of thread management, not always faster (especially for small datasets or I/O bound operations), ordering may not be preserved unless explicitly requested, 7) Best practices: use for computational tasks, avoid for I/O operations, test performance gains, ensure operations are stateless and side-effect free."
  },
  {
    "question": "What are Optional class benefits and how do you use it?",
    "answer": "Optional is a container class to handle potentially null values safely: 1) Benefits: eliminates NullPointerException, makes null-handling explicit, encourages better API design, provides functional programming style for null checks, 2) Creation methods: Optional.of(value) (throws if null), Optional.ofNullable(value) (handles null), Optional.empty(), 3) Usage methods: isPresent() (checks if value exists), ifPresent(consumer) (executes if present), orElse(defaultValue) (returns default if empty), orElseGet(supplier) (lazy default computation), orElseThrow() (throws exception if empty), 4) Functional operations: map(), flatMap(), filter() for transformations, 5) Example: Optional<String> name = Optional.ofNullable(getName()); name.ifPresent(System.out::println); String result = name.orElse(\"Unknown\"). Use Optional for return types where null is possible, not for fields or parameters."
  },
  {
    "question": "What are default methods in interfaces and why were they introduced?",
    "answer": "Default methods in interfaces provide method implementations directly in interfaces: 1) Syntax: default keyword before method declaration, 2) Why introduced: enable interface evolution without breaking existing implementations, support functional programming features, allow multiple inheritance of behavior, 3) Benefits: backward compatibility when adding new methods to interfaces, reduce code duplication across implementations, enable mixin-like behavior, 4) Example: interface List { default void sort(Comparator<? super E> c) { Collections.sort(this, c); } }, 5) Resolution rules for conflicts: class methods override interface defaults, more specific interface defaults override general ones, explicit override required for ambiguity, 6) Use cases: adding utility methods to interfaces, providing common implementations, evolutionary interface design. Default methods revolutionized interface design by allowing concrete implementations while maintaining interface contracts."
  },
  {
    "question": "What is the diamond problem with default methods and how is it resolved?",
    "answer": "The diamond problem occurs when a class implements multiple interfaces with conflicting default methods: 1) Problem: if two interfaces have default methods with same signature, implementing class faces ambiguity, 2) Java's resolution rules: class implementations override interface defaults, more specific interface defaults take precedence, compiler error for unresolvable conflicts, 3) Solution: explicitly override conflicting method in implementing class, use InterfaceName.super.methodName() to call specific interface implementation, 4) Example: class C implements A, B { public void method() { A.super.method(); } }, 5) Prevention: careful interface design, avoiding method signature conflicts, using composition over multiple inheritance when possible. This ensures deterministic method resolution while preserving the benefits of multiple interface implementation."
  },
  {
    "question": "What are static methods in interfaces and how are they different from default methods?",
    "answer": "Static methods in interfaces are utility methods associated with the interface itself: 1) Cannot be inherited or overridden by implementing classes, 2) Called using InterfaceName.methodName() syntax, 3) Cannot be called on implementing class instances, 4) Differences from default methods: static methods belong to interface, not instances; cannot be overridden; not inherited; no conflict resolution needed, 5) Use cases: utility functions related to interface, factory methods, helper methods for default method implementations, 6) Example: interface Comparator { static <T> Comparator<T> naturalOrder() { return (Comparator<T>) Comparators.NaturalOrderComparator.INSTANCE; } }, 7) Benefits: namespace organization, logical grouping of related functionality, avoiding separate utility classes. Static interface methods provide a clean way to include utility functionality directly in interfaces."
  },
  {
    "question": "What is the difference between Predicate, Function, Consumer, and Supplier interfaces?",
    "answer": "These are core functional interfaces in java.util.function package: 1) Predicate<T>: represents boolean-valued functions, single method test(T t) returns boolean, used for filtering and condition checking, example: Predicate<String> isEmpty = String::isEmpty, 2) Function<T,R>: represents functions that take one argument and produce result, method apply(T t) returns R, used for transformations, example: Function<String, Integer> length = String::length, 3) Consumer<T>: represents operations that accept single input but return no result, method accept(T t), used for actions like printing, example: Consumer<String> printer = System.out::println, 4) Supplier<T>: represents suppliers of results with no input, method get() returns T, used for lazy evaluation and factory methods, example: Supplier<Date> dateSupplier = Date::new. These enable functional programming patterns and work seamlessly with Stream API."
  },
  {
    "question": "What are BiFunction, BiConsumer, and BiPredicate interfaces?",
    "answer": "These are two-argument versions of core functional interfaces: 1) BiFunction<T,U,R>: accepts two arguments and produces result, method apply(T t, U u) returns R, used for operations combining two inputs, example: BiFunction<String, String, String> concat = String::concat, 2) BiConsumer<T,U>: accepts two arguments and returns no result, method accept(T t, U u), used for actions on pairs of values, example: BiConsumer<String, Integer> printer = (name, age) -> System.out.println(name + \" is \" + age), 3) BiPredicate<T,U>: accepts two arguments and returns boolean, method test(T t, U u), used for conditions involving two inputs, example: BiPredicate<String, String> startsWith = String::startsWith, 4) These interfaces enable functional operations on pairs of values and are commonly used in map operations, comparisons, and binary operations throughout the Java API."
  },
  {
    "question": "What are UnaryOperator and BinaryOperator interfaces?",
    "answer": "UnaryOperator and BinaryOperator are specialized functional interfaces for operations where input and output types are the same: 1) UnaryOperator<T> extends Function<T,T>: represents operation on single operand producing result of same type, method apply(T t) returns T, example: UnaryOperator<String> toUpper = String::toUpperCase, 2) BinaryOperator<T> extends BiFunction<T,T,T>: represents operation on two operands of same type producing result of same type, method apply(T t1, T t2) returns T, example: BinaryOperator<Integer> sum = Integer::sum, 3) Common use cases: mathematical operations, string manipulations, accumulation operations in reduce(), 4) Provide static methods like identity() for UnaryOperator and minBy()/maxBy() for BinaryOperator, 5) Particularly useful with Stream reduce operations and method chaining where type consistency is important."
  },
  {
    "question": "How do you create custom functional interfaces in Java?",
    "answer": "Creating custom functional interfaces follows specific guidelines: 1) Annotate with @FunctionalInterface (optional but recommended), 2) Define exactly one abstract method (SAM - Single Abstract Method), 3) Can have multiple default and static methods, 4) Example: @FunctionalInterface interface Calculator<T> { T calculate(T a, T b); default T add(T a, T b) { return calculate(a, b); } }, 5) Benefits: type safety, clear intent, IDE support, compile-time verification, 6) Use cases: domain-specific operations, specialized transformations, callback patterns, event handling, 7) Best practices: meaningful names, clear documentation, consider existing functional interfaces first, avoid complex abstract methods. Custom functional interfaces should be created when existing ones don't fit your specific use case or when you need domain-specific naming for clarity."
  },
  {
    "question": "What is the Collector interface and how do you create custom collectors?",
    "answer": "The Collector interface defines how to accumulate stream elements into a final result: 1) Key methods: supplier() (creates result container), accumulator() (adds element to container), combiner() (merges containers for parallel processing), finisher() (final transformation), characteristics() (optimization hints), 2) Create custom collectors using Collector.of() factory method or by implementing Collector interface, 3) Example: Collector<String, StringBuilder, String> joining = Collector.of(StringBuilder::new, StringBuilder::append, StringBuilder::append, StringBuilder::toString), 4) Characteristics include CONCURRENT, UNORDERED, IDENTITY_FINISH for performance optimization, 5) Use cases: custom data structures, complex aggregations, specialized formatting, domain-specific accumulation. Custom collectors enable powerful, reusable accumulation logic for stream processing."
  },
  {
    "question": "What are the performance considerations when using Java 8 features?",
    "answer": "Java 8 features have specific performance implications: 1) Lambda expressions: minimal overhead for simple operations, but boxing/unboxing can impact primitive operations, 2) Streams: lazy evaluation is efficient, but overhead for simple operations on small collections, parallel streams aren't always faster due to thread overhead, 3) Method references: generally same performance as equivalent lambdas, 4) Optional: slight overhead compared to null checks, avoid in performance-critical loops, 5) Default methods: same performance as regular method calls, 6) Stream operations: stateful operations (sorted, distinct) require buffering, short-circuiting operations (findFirst, anyMatch) can improve performance, 7) Best practices: prefer primitive streams (IntStream, LongStream) for numerical data, avoid boxing/unboxing, test parallel vs sequential streams, use appropriate collection sizes for stream operations. Profile actual performance rather than assuming."
  },
  {
    "question": "What is CompletableFuture and how does it improve asynchronous programming?",
    "answer": "CompletableFuture is a powerful class for asynchronous programming that extends Future: 1) Improvements over Future: non-blocking operations, composable with method chaining, exception handling, manual completion, multiple combination methods, 2) Creation methods: supplyAsync() (with return value), runAsync() (without return value), completedFuture() (already completed), 3) Composition methods: thenApply() (transform result), thenCompose() (chain async operations), thenCombine() (combine two futures), thenAcceptBoth() (consume two results), 4) Exception handling: exceptionally(), handle(), whenComplete(), 5) Completion methods: complete(), completeExceptionally(), cancel(), 6) Example: CompletableFuture.supplyAsync(() -> fetchData()).thenApply(this::processData).thenAccept(System.out::println). CompletableFuture enables reactive programming patterns and simplifies complex asynchronous workflows."
  },
  {
    "question": "How do you handle exceptions in CompletableFuture?",
    "answer": "CompletableFuture provides several methods for exception handling: 1) exceptionally(): handles exceptions and provides alternative results, similar to catch block, example: future.exceptionally(throwable -> \"Default Value\"), 2) handle(): processes both successful results and exceptions, example: future.handle((result, throwable) -> throwable != null ? \"Error\" : result), 3) whenComplete(): performs actions on completion regardless of outcome, example: future.whenComplete((result, throwable) -> log(result, throwable)), 4) Exception propagation: uncaught exceptions in one stage propagate to dependent stages, 5) completeExceptionally(): manually complete with exception, 6) Best practices: always handle exceptions in async chains, use specific exception types, log appropriately, provide meaningful fallback values, avoid swallowing exceptions. Proper exception handling ensures robust asynchronous code that gracefully handles failures."
  },
  {
    "question": "What are the different ways to combine multiple CompletableFutures?",
    "answer": "CompletableFuture provides various methods for combining multiple asynchronous operations: 1) thenCombine(): combines two independent futures when both complete, example: future1.thenCombine(future2, (result1, result2) -> result1 + result2), 2) thenCompose(): chains dependent futures where second depends on first's result, example: future1.thenCompose(result -> getAnotherFuture(result)), 3) allOf(): waits for all futures to complete, returns CompletableFuture<Void>, 4) anyOf(): waits for any future to complete, returns first completed result, 5) thenAcceptBoth(): consumes results of two futures without returning value, 6) runAfterBoth(): runs action after both complete, 7) Static factory methods for combining: CompletableFuture.allOf(future1, future2, future3). These methods enable complex asynchronous workflows and parallel processing patterns."
  },
  {
    "question": "What is the difference between thenApply() and thenCompose() in CompletableFuture?",
    "answer": "thenApply() and thenCompose() are both transformation methods but handle nesting differently: 1) thenApply(): transforms the result using a function that returns a direct value, creates flat transformation, signature: thenApply(Function<T,U>), example: future.thenApply(string -> string.toUpperCase()), 2) thenCompose(): used when transformation function returns another CompletableFuture, flattens nested futures, signature: thenCompose(Function<T,CompletableFuture<U>>), example: future.thenCompose(id -> fetchUserById(id)), 3) Without thenCompose(), you'd get CompletableFuture<CompletableFuture<T>> instead of CompletableFuture<T>, 4) Use thenApply() for synchronous transformations, thenCompose() for chaining asynchronous operations, 5) Similar to map() vs flatMap() in streams. thenCompose() is essential for avoiding nested future structures when chaining async operations."
  },
  {
    "question": "What are ExecutorService and thread pools in Java?",
    "answer": "ExecutorService is a high-level interface for managing thread execution and lifecycle: 1) Benefits over direct thread creation: thread reuse, lifecycle management, task queuing, resource control, graceful shutdown, 2) Common implementations: ThreadPoolExecutor (configurable pools), ScheduledThreadPoolExecutor (scheduled tasks), ForkJoinPool (parallel processing), 3) Factory methods in Executors class: newFixedThreadPool() (fixed number of threads), newCachedThreadPool() (grows as needed), newSingleThreadExecutor() (single worker thread), newScheduledThreadPool() (scheduled execution), 4) Key methods: submit() (with return value), execute() (fire and forget), shutdown() (graceful shutdown), shutdownNow() (immediate shutdown), 5) Thread pools improve performance by reusing threads, provide better resource management, and offer structured concurrency control. Always shutdown executor services to prevent resource leaks."
  },
  {
    "question": "What is the ForkJoinPool and when should you use it?",
    "answer": "ForkJoinPool is a specialized thread pool for parallel processing using work-stealing algorithm: 1) Work-stealing: idle threads steal work from busy threads' queues, maximizing CPU utilization, 2) Designed for divide-and-conquer algorithms where tasks can be recursively split into smaller subtasks, 3) Used by parallel streams by default, 4) Key classes: ForkJoinTask (base class), RecursiveTask (returns result), RecursiveAction (no return value), 5) Process: fork() splits task, join() waits for completion, compute() contains actual work, 6) Use cases: parallel array processing, recursive algorithms, mathematical computations, image processing, 7) Benefits: optimal CPU utilization, handles varying task sizes well, built-in load balancing, 8) Common pool: ForkJoinPool.commonPool() used by parallel streams. Use ForkJoinPool for CPU-intensive, parallelizable tasks that can be broken down recursively."
  },
  {
    "question": "What are Semaphore, CountDownLatch, and CyclicBarrier in Java concurrency?",
    "answer": "These are synchronization utilities for coordinating thread execution: 1) Semaphore: controls access to shared resources by maintaining permits, acquire() gets permit, release() returns permit, useful for limiting concurrent access, example: database connections, 2) CountDownLatch: allows threads to wait until set of operations complete, initialized with count, countDown() decrements, await() blocks until zero, one-time use, example: waiting for services to start, 3) CyclicBarrier: synchronization point where threads wait for each other, reusable after all threads reach barrier, await() blocks until all arrive, optional barrier action executes when all threads meet, example: parallel processing phases. Use Semaphore for resource limiting, CountDownLatch for one-time coordination, CyclicBarrier for repeated synchronization points. Each addresses specific coordination patterns in concurrent programming."
  },
  {
    "question": "What is the volatile keyword in Java and when should it be used?",
    "answer": "The volatile keyword in Java ensures that reads and writes to a variable are directly performed on main memory, not CPU cache, providing visibility guarantees across threads. It prevents instruction reordering around volatile variables and ensures that changes made by one thread are immediately visible to other threads. Use volatile for: flags indicating state changes, double-checked locking patterns, and variables that are written by one thread and read by others. However, volatile doesn't provide atomicity for compound operations like increment, so use atomic classes for such operations."
  },
  {
    "question": "What is a race condition in Java multithreading and how can it be prevented?",
    "answer": "A race condition occurs when multiple threads access shared data concurrently and the final result depends on the timing of their execution. This can lead to unpredictable behavior and data corruption. Race conditions can be prevented by: 1) Using synchronization mechanisms like synchronized blocks/methods, 2) Using thread-safe collections from java.util.concurrent package, 3) Using atomic variables for simple operations, 4) Using locks like ReentrantLock for more complex scenarios, 5) Making objects immutable when possible, 6) Using proper synchronization primitives like CountDownLatch or CyclicBarrier for coordination."
  },
  {
    "question": "What is deadlock in Java and how can it be avoided?",
    "answer": "Deadlock occurs when two or more threads are blocked forever, each waiting for the other to release a resource they need. It happens when threads acquire locks in different orders. Deadlock can be avoided by: 1) Lock ordering - always acquire locks in the same order across all threads, 2) Lock timeout - use tryLock() with timeout instead of blocking indefinitely, 3) Avoiding nested locks when possible, 4) Using higher-level concurrency utilities from java.util.concurrent package, 5) Implementing deadlock detection mechanisms, 6) Using the banker's algorithm for resource allocation in complex scenarios."
  },
  {
    "question": "What is the difference between wait() and sleep() methods in Java?",
    "answer": "wait() and sleep() both pause thread execution but work differently: 1) wait() is called on an object and releases the lock/monitor, allowing other threads to acquire it. It must be called within a synchronized block/method and the thread waits until notify() or notifyAll() is called, 2) sleep() is a static method of Thread class that pauses the current thread for a specified time without releasing any locks. The thread automatically resumes after the sleep duration, 3) wait() is used for inter-thread communication, while sleep() is used for introducing delays, 4) wait() can be interrupted by notify()/notifyAll(), while sleep() continues for the full duration unless interrupted."
  },
  {
    "question": "What are notify() and notifyAll() methods and when should each be used?",
    "answer": "notify() and notifyAll() are methods used for inter-thread communication in Java: 1) notify() wakes up a single thread that is waiting on the object's monitor. If multiple threads are waiting, only one is awakened (chosen arbitrarily), 2) notifyAll() wakes up all threads that are waiting on the object's monitor. All awakened threads will compete for the lock, 3) Use notify() when only one thread needs to be awakened and all waiting threads are doing the same type of work, 4) Use notifyAll() when multiple threads might be waiting for different conditions or when you want to ensure all threads get a chance to check their condition. Both methods must be called from within a synchronized block/method."
  },
  {
    "question": "What is a thread pool and what are its advantages?",
    "answer": "A thread pool is a collection of pre-initialized threads that are ready to execute tasks. Instead of creating new threads for each task, tasks are submitted to the pool and executed by available threads. Advantages include: 1) Performance improvement - eliminates overhead of thread creation/destruction, 2) Resource management - limits the number of concurrent threads, preventing resource exhaustion, 3) Better responsiveness - threads are already created and ready to execute tasks, 4) Simplified thread lifecycle management, 5) Queue management for handling more tasks than available threads, 6) Better scalability for applications with many short-lived tasks. Java provides thread pools through ExecutorService and various factory methods in the Executors class."
  },
  {
    "question": "What are the different types of ExecutorService implementations?",
    "answer": "Java provides several ExecutorService implementations: 1) ThreadPoolExecutor - the most flexible implementation allowing custom configuration of core pool size, maximum pool size, keep-alive time, and work queue, 2) ScheduledThreadPoolExecutor - extends ThreadPoolExecutor to support delayed and periodic task execution, 3) ForkJoinPool - designed for parallel processing using work-stealing algorithm, ideal for divide-and-conquer tasks, 4) Factory methods in Executors class: newFixedThreadPool() (fixed number of threads), newCachedThreadPool() (creates threads as needed), newSingleThreadExecutor() (single worker thread), newScheduledThreadPool() (for scheduled tasks), newWorkStealingPool() (parallel processing). Each type is optimized for different use cases and workload patterns."
  },
  {
    "question": "What is the Fork/Join framework in Java?",
    "answer": "The Fork/Join framework is a specialized thread pool designed for parallel processing of recursive, divide-and-conquer algorithms. Key components include: 1) ForkJoinPool - the thread pool that manages worker threads using work-stealing algorithm, 2) ForkJoinTask - the base class for tasks, with two main subtypes: RecursiveTask (returns a result) and RecursiveAction (no return value), 3) Work-stealing - idle threads steal work from busy threads' queues, maximizing CPU utilization, 4) fork() method splits tasks into smaller subtasks, join() waits for subtask completion, 5) Ideal for problems like parallel array processing, mathematical computations, and tree traversals. The framework is used internally by parallel streams in Java 8+."
  },
  {
    "question": "What is the difference between Callable and Runnable interfaces?",
    "answer": "Callable and Runnable are both functional interfaces for defining tasks, but with key differences: 1) Return value - Callable's call() method returns a generic type V, while Runnable's run() method returns void, 2) Exception handling - Callable can throw checked exceptions, while Runnable cannot throw checked exceptions from run() method, 3) Usage - Callable is used with ExecutorService.submit() which returns a Future, while Runnable can be used with Thread constructor or ExecutorService.execute(), 4) Type safety - Callable provides type-safe return values through generics, 5) Callable enables retrieving results from asynchronous computations, making it more suitable for tasks that need to return values or may encounter checked exceptions."
  },
  {
    "question": "What is Future interface and how is it used?",
    "answer": "Future represents the result of an asynchronous computation, providing methods to check completion status and retrieve results. Key methods include: 1) get() - retrieves the result, blocking if necessary until computation completes, 2) get(timeout, timeunit) - retrieves result with timeout, 3) isDone() - returns true if computation completed, 4) isCancelled() - returns true if computation was cancelled, 5) cancel(mayInterruptIfRunning) - attempts to cancel the computation. Future is returned when submitting Callable tasks to ExecutorService. It enables non-blocking submission of tasks while allowing retrieval of results later. CompletableFuture (Java 8+) extends Future with additional capabilities for composing and chaining asynchronous operations."
  },
  {
    "question": "What are the different ways to handle exceptions in multithreaded Java applications?",
    "answer": "Exception handling in multithreaded applications requires special consideration: 1) UncaughtExceptionHandler - set default handler for uncaught exceptions using Thread.setDefaultUncaughtExceptionHandler() or per-thread using setUncaughtExceptionHandler(), 2) ExecutorService - exceptions in submitted tasks are captured and can be retrieved via Future.get(), which will throw ExecutionException wrapping the original exception, 3) try-catch in run() method - catch exceptions within the thread's run() method to prevent thread termination, 4) Callable interface - allows throwing checked exceptions that can be handled by the calling thread, 5) CompletableFuture - provides methods like exceptionally() and handle() for exception handling in asynchronous pipelines, 6) Thread-safe logging - use thread-safe logging mechanisms to record exceptions from multiple threads."
  },
  {
    "question": "What is ThreadLocal in Java and when should it be used?",
    "answer": "ThreadLocal provides thread-local variables where each thread has its own independent copy of the variable. Key characteristics: 1) Each thread accessing a ThreadLocal variable has its own isolated copy, 2) Changes made by one thread are not visible to other threads, 3) Useful for maintaining per-thread context like user sessions, database connections, or transaction information, 4) Helps avoid synchronization overhead when sharing state is not needed, 5) Common use cases include SimpleDateFormat (which is not thread-safe), storing user authentication information, and maintaining per-thread caches. Important considerations: always clean up ThreadLocal variables using remove() method to prevent memory leaks, especially in application servers where threads are reused. ThreadLocal should be declared as static final and properly managed to avoid memory leaks."
  },
  {
    "question": "What is the difference between synchronized and ReentrantLock?",
    "answer": "synchronized and ReentrantLock both provide mutual exclusion but with different capabilities: 1) Flexibility - ReentrantLock offers more control with tryLock(), lockInterruptibly(), and timed locking, while synchronized is simpler but less flexible, 2) Fairness - ReentrantLock can be configured for fair locking (longest-waiting thread gets lock first), synchronized doesn't guarantee fairness, 3) Condition variables - ReentrantLock supports multiple condition variables via newCondition(), synchronized only supports one implicit condition with wait()/notify(), 4) Lock acquisition - ReentrantLock allows attempting to acquire lock without blocking using tryLock(), 5) Performance - synchronized has lower overhead and better JVM optimization, ReentrantLock has slightly higher overhead but more features, 6) Exception handling - ReentrantLock requires explicit unlock() in finally block, synchronized automatically releases lock. Use synchronized for simple cases, ReentrantLock for advanced locking needs."
  },
  {
    "question": "What are atomic operations and how do atomic classes work in Java?",
    "answer": "Atomic operations are indivisible operations that complete entirely without interference from other threads. Java's atomic classes (AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference) provide lock-free thread-safe operations using low-level atomic hardware primitives. Key features: 1) Compare-and-swap (CAS) operations - atomically compare current value with expected value and update if they match, 2) Lock-free algorithms - avoid the overhead of acquiring/releasing locks, 3) Methods like compareAndSet(), incrementAndGet(), addAndGet() are atomic, 4) Better performance than synchronized blocks for simple operations, 5) ABA problem mitigation through versioning in some implementations, 6) Memory consistency - atomic operations provide proper memory visibility guarantees. Atomic classes are ideal for counters, flags, and simple state management where lock-free performance is desired."
  },
  {
    "question": "What is the producer-consumer problem and how can it be solved in Java?",
    "answer": "The producer-consumer problem involves synchronizing producers (threads that generate data) and consumers (threads that process data) sharing a bounded buffer. Solutions in Java include: 1) BlockingQueue - use implementations like ArrayBlockingQueue or LinkedBlockingQueue which handle synchronization automatically with put() (blocking add) and take() (blocking remove), 2) wait()/notify() with synchronized blocks - manually implement buffer with proper synchronization and condition checking, 3) Semaphore - use counting semaphores to control access to resources, 4) Condition variables with ReentrantLock - more flexible than wait/notify for complex conditions, 5) Java 8 streams - for some scenarios, parallel streams can naturally handle producer-consumer patterns. The key is ensuring thread safety while avoiding deadlock and ensuring efficiency. BlockingQueue is typically the preferred solution as it handles most complexity internally."
  },
  {
    "question": "What is the CountDownLatch and how is it used?",
    "answer": "CountDownLatch is a synchronization utility that allows one or more threads to wait until a set of operations being performed by other threads completes. Key characteristics: 1) Initialized with a count value, 2) await() method blocks until count reaches zero, 3) countDown() decrements the count, 4) Once count reaches zero, all waiting threads are released and latch cannot be reused, 5) Useful for scenarios like waiting for multiple services to start, coordinating parallel task completion, or implementing barriers. Example use cases: application startup coordination, waiting for multiple background tasks to complete before proceeding, test scenarios where main thread waits for worker threads. Unlike CyclicBarrier, CountDownLatch is one-time use and focuses on task completion rather than thread synchronization points."
  },
  {
    "question": "What is CyclicBarrier and how does it differ from CountDownLatch?",
    "answer": "CyclicBarrier is a synchronization point where a fixed number of threads wait for each other before proceeding. Differences from CountDownLatch: 1) Reusability - CyclicBarrier can be reused after all threads reach the barrier, CountDownLatch is one-time use, 2) Purpose - CyclicBarrier waits for threads to reach a synchronization point, CountDownLatch waits for events/tasks to complete, 3) Participants - CyclicBarrier has fixed number of parties that must reach barrier, CountDownLatch can have different numbers of threads counting down vs waiting, 4) Barrier action - CyclicBarrier can execute a Runnable when all threads reach barrier, 5) Reset capability - CyclicBarrier can be reset manually. Use CyclicBarrier for repetitive parallel processing phases where threads need to synchronize periodically, like parallel algorithms with multiple phases. Use CountDownLatch for one-time coordination events."
  },
  {
    "question": "What is Semaphore in Java concurrency?",
    "answer": "Semaphore is a counting synchronization primitive that maintains a set of permits. Threads can acquire and release permits, and if no permits are available, threads block until one becomes available. Key features: 1) acquire() - acquires a permit, blocking if none available, 2) release() - releases a permit back to the semaphore, 3) tryAcquire() - attempts to acquire permit without blocking, 4) Constructor takes initial number of permits, 5) Can be fair or unfair (fair ensures FIFO ordering), 6) Useful for controlling access to limited resources like connection pools, limiting concurrent operations, or implementing bounded buffers. Example: limiting concurrent downloads to 5 using Semaphore(5). Unlike locks, semaphores don't require the same thread to acquire and release - any thread can release permits. Binary semaphore (permit count 1) acts like a mutex."
  },
  {
    "question": "What are ReadWriteLock and StampedLock in Java?",
    "answer": "ReadWriteLock allows multiple concurrent readers or one exclusive writer, improving performance for read-heavy scenarios. StampedLock (Java 8+) is an advanced lock providing optimistic reading capabilities. ReadWriteLock features: 1) readLock() allows multiple concurrent readers, 2) writeLock() provides exclusive access, 3) Readers block writers and vice versa, 4) ReentrantReadWriteLock is the main implementation. StampedLock features: 1) Optimistic reading - tryOptimisticRead() returns a stamp, validate() checks if stamp is still valid, 2) Better performance than ReadWriteLock for read-heavy workloads, 3) Three modes: reading, writing, and optimistic reading, 4) Not reentrant, simpler than ReadWriteLock, 5) Optimistic reads don't block writers, providing better throughput. Use ReadWriteLock for scenarios with many readers and few writers. Use StampedLock for maximum performance in read-heavy scenarios where optimistic reading is beneficial."
  },
  {
    "question": "What is the Phaser class in Java concurrency?",
    "answer": "Phaser is a flexible synchronization barrier that supports dynamic registration of parties and multiple phases of execution. It's more advanced than CountDownLatch and CyclicBarrier. Key features: 1) Dynamic party registration/deregistration using register() and arriveAndDeregister(), 2) Phase-based coordination - supports multiple phases of computation, 3) arrive() - signals arrival at current phase, 4) arriveAndAwaitAdvance() - arrives and waits for other parties, 5) awaitAdvance() - waits for specific phase completion, 6) Can be hierarchically structured with parent-child relationships, 7) Supports termination when no registered parties remain. Use cases include: parallel algorithms with multiple phases, fork-join computations, coordinating dynamic sets of threads. Phaser is more complex but more flexible than other synchronization utilities, suitable for sophisticated parallel algorithms where the number of participants may change during execution."
  },
  {
    "question": "What is the Exchanger class and when would you use it?",
    "answer": "Exchanger is a synchronization point where two threads can exchange objects. Each thread presents an object and receives the object presented by the other thread. Key characteristics: 1) Exactly two threads participate in each exchange, 2) exchange() method blocks until partner thread arrives, 3) Thread-safe way to swap data between two threads, 4) Supports timeout with exchange(object, timeout, timeunit), 5) Useful for producer-consumer scenarios where roles switch, or pipeline patterns where threads need to hand off data. Example use cases: genetic algorithms where two parent solutions exchange genetic material, pipeline processing where one thread processes odd positions and another processes even positions then they exchange results, or buffer swapping between producer and consumer. Exchanger is specialized for two-party data exchange and provides an elegant solution for symmetric thread cooperation patterns."
  },
  {
    "question": "What are the best practices for writing thread-safe code in Java?",
    "answer": "Best practices for thread-safe code include: 1) Prefer immutable objects - they're inherently thread-safe and eliminate many concurrency issues, 2) Use thread-safe collections from java.util.concurrent package instead of synchronized wrappers, 3) Minimize shared mutable state - design with thread-local variables and message passing when possible, 4) Use atomic operations for simple state changes instead of synchronization, 5) Follow the principle of least privilege for locking - synchronize only critical sections, 6) Avoid nested locks to prevent deadlock, always acquire locks in same order, 7) Use higher-level concurrency utilities (ExecutorService, CountDownLatch) instead of raw threads, 8) Make fields final when possible, use volatile for flags and simple state, 9) Document thread-safety guarantees in your classes, 10) Test thoroughly with concurrent stress tests, 11) Use lock-free algorithms when performance is critical, 12) Proper exception handling to ensure locks are released."
  },
  {
    "question": "What is the difference between parallelism and concurrency in Java?",
    "answer": "Concurrency and parallelism are related but distinct concepts: Concurrency is about dealing with multiple tasks at once - it's about structure and design, allowing multiple threads to make progress by interleaving execution on available CPU cores. Parallelism is about doing multiple tasks simultaneously - it's about execution, requiring multiple CPU cores to literally execute tasks at the same time. Key differences: 1) Concurrency can exist on single-core systems through time-slicing, parallelism requires multiple cores, 2) Concurrency focuses on managing multiple tasks and their interactions, parallelism focuses on simultaneous execution for performance, 3) Concurrent programs may not be parallel (single core), parallel programs are inherently concurrent, 4) Java provides concurrency through threads, synchronization, and concurrent collections; parallelism through parallel streams, Fork/Join framework, and parallel algorithms. In practice, modern Java applications use both concepts together to achieve responsive, scalable, and high-performance systems."
  },
  {
    "question": "What is Java Memory Model (JMM) and why is it important?",
    "answer": "Java Memory Model defines how threads interact through memory and specifies the rules for visibility of shared data across threads. Key aspects: 1) Main memory vs thread-local caches - each thread may have cached copies of variables, changes must be synchronized to main memory, 2) Happens-before relationship - defines ordering guarantees between operations across threads, 3) Volatile semantics - volatile reads/writes create happens-before relationships ensuring visibility, 4) Synchronization effects - synchronized blocks establish happens-before relationships and memory barriers, 5) Final field semantics - final fields are visible to all threads after constructor completion, 6) Memory barriers - prevent reordering of operations across barrier points. JMM is crucial for: understanding when changes made by one thread become visible to others, preventing compiler and CPU optimizations from breaking concurrent programs, ensuring correct behavior of synchronization primitives, and writing portable concurrent code that works across different JVM implementations and hardware architectures."
  },
  {
    "question": "What are CompletableFuture's main methods for handling asynchronous operations?",
    "answer": "CompletableFuture provides extensive API for asynchronous programming: Creation methods - supplyAsync() (with return value), runAsync() (void), completedFuture() (already completed). Transformation methods - thenApply() (transform result), thenApplyAsync() (async transformation), thenCompose() (chain async operations), thenCombine() (combine two futures). Action methods - thenAccept() (consume result), thenRun() (run action after completion), thenAcceptBoth() (consume two results). Exception handling - exceptionally() (handle exceptions), handle() (handle both result and exception), whenComplete() (observe completion). Combination methods - allOf() (wait for all to complete), anyOf() (wait for any to complete). Completion methods - complete() (manually complete), completeExceptionally() (complete with exception), cancel() (cancel execution). Each method typically has Async variants for execution on different thread pools, enabling flexible asynchronous programming patterns."
  },
  {
    "question": "How do you implement a custom thread-safe singleton pattern?",
    "answer": "Several approaches exist for thread-safe singleton implementation: 1) Synchronized method - simple but performance overhead: `public static synchronized Singleton getInstance()`, 2) Double-checked locking - reduces synchronization overhead: check instance null twice with synchronized inner block, 3) Eager initialization - thread-safe by JVM guarantees: `private static final Singleton INSTANCE = new Singleton()`, 4) Initialization-on-demand holder idiom - lazy and thread-safe: inner static class holds instance, 5) Enum singleton - inherently thread-safe and serialization-safe: `public enum Singleton { INSTANCE; }`. Best practice is usually enum approach for simplicity or holder idiom for lazy initialization. Key considerations: handle serialization by implementing readResolve(), consider reflection attacks, ensure proper handling of clone() method, use volatile keyword for double-checked locking to prevent instruction reordering issues. The choice depends on whether you need lazy initialization and performance requirements."
  },
  {
    "question": "What is the difference between ConcurrentHashMap and Collections.synchronizedMap()?",
    "answer": "ConcurrentHashMap and Collections.synchronizedMap() both provide thread-safe maps but with different approaches: ConcurrentHashMap features: 1) Lock striping/segmentation - only portions of map are locked during updates, allowing concurrent reads and limited concurrent writes, 2) Non-blocking reads - read operations don't require locks, 3) Better scalability - performance scales better with thread count, 4) Atomic operations - putIfAbsent(), replace(), compute() methods are atomic, 5) Fail-safe iterators - don't throw ConcurrentModificationException. Collections.synchronizedMap() features: 1) Full synchronization - entire map is locked for any modification, 2) Manual synchronization required for iteration to avoid ConcurrentModificationException, 3) Lower performance under contention due to coarse-grained locking, 4) Simple wrapper around any Map implementation. ConcurrentHashMap is generally preferred for high-concurrency scenarios due to better performance and built-in thread-safe iteration. Use synchronizedMap() only when you need to synchronize a specific Map implementation that doesn't have a concurrent variant."
  },
  {
    "question": "What is the Executor framework and its components?",
    "answer": "The Executor framework provides high-level APIs for managing thread execution and lifecycle. Key components: 1) Executor interface - simple execute(Runnable) method for task submission, 2) ExecutorService - extends Executor with lifecycle management (shutdown(), submit() methods, Future handling), 3) ScheduledExecutorService - extends ExecutorService for delayed/periodic task execution, 4) ThreadPoolExecutor - configurable thread pool implementation with core pool size, maximum pool size, keep-alive time, and work queue, 5) ScheduledThreadPoolExecutor - scheduled task execution with thread pool, 6) Executors factory class - provides convenient factory methods for common executor configurations, 7) Future and CompletableFuture - represent pending results of asynchronous computations. Benefits include: decoupling task submission from task execution, automatic thread lifecycle management, built-in queuing and scheduling capabilities, better resource utilization, and simplified concurrent programming model. The framework promotes best practices and reduces common threading errors."
  },
  {
    "question": "What are the different thread states in Java and their transitions?",
    "answer": "Java threads have six states defined in Thread.State enum: 1) NEW - thread created but not started, 2) RUNNABLE - thread is executing or ready to execute (includes both running and ready states), 3) BLOCKED - thread blocked waiting for monitor lock, 4) WAITING - thread waiting indefinitely for another thread (wait(), join() without timeout, LockSupport.park()), 5) TIMED_WAITING - thread waiting for specified time (sleep(), wait(timeout), join(timeout)), 6) TERMINATED - thread execution completed. State transitions: NEW → RUNNABLE (start()), RUNNABLE → BLOCKED (trying to acquire lock), BLOCKED → RUNNABLE (lock acquired), RUNNABLE → WAITING (wait(), join()), WAITING → RUNNABLE (notify(), thread completion), RUNNABLE → TIMED_WAITING (sleep(), wait(timeout)), TIMED_WAITING → RUNNABLE (timeout expired, notify()), RUNNABLE → TERMINATED (run() completion). Understanding states helps in debugging thread issues and optimizing concurrent applications."
  },
  {
    "question": "What is thread starvation and how can it be prevented?",
    "answer": "Thread starvation occurs when a thread is unable to gain regular access to shared resources and is unable to make progress, typically because other threads monopolize the resource. Causes include: 1) Unfair scheduling - some threads consistently get priority over others, 2) Inappropriate thread priorities - high-priority threads starving low-priority ones, 3) Poorly designed synchronization - some threads hold locks for too long, 4) Inefficient algorithms - causing some threads to wait indefinitely. Prevention strategies: 1) Use fair locks - ReentrantLock(true) ensures FIFO ordering, 2) Avoid inappropriate thread priorities - use default priorities unless specifically needed, 3) Minimize lock holding time - keep synchronized blocks small and efficient, 4) Use timeout-based operations - tryLock(timeout) instead of blocking indefinitely, 5) Design for fairness - ensure all threads get equal opportunity to access resources, 6) Monitor thread behavior - use profiling tools to identify starvation patterns, 7) Use high-level concurrency utilities that handle fairness internally."
  },
  {
    "question": "What is the difference between preemptive and cooperative multitasking?",
    "answer": "Preemptive and cooperative multitasking are different approaches to thread scheduling: Preemptive multitasking: 1) Operating system controls thread scheduling, 2) Threads can be interrupted (preempted) at any time by the scheduler, 3) Time slicing gives each thread a time quantum to execute, 4) No thread can monopolize CPU indefinitely, 5) Modern JVMs use preemptive scheduling, 6) Better for responsiveness and fairness, 7) Protection against poorly behaved threads. Cooperative multitasking: 1) Threads voluntarily yield control to other threads, 2) No forced preemption - threads run until they explicitly yield, 3) Requires threads to be well-behaved and cooperative, 4) One thread can block entire system if it doesn't yield, 5) Less overhead as no forced context switching, 6) Simpler to implement but less robust. Java uses preemptive multitasking at the OS level, but provides cooperative elements through methods like Thread.yield() and sleep(). Modern systems favor preemptive scheduling for better system responsiveness and stability."
  },
  {
    "question": "What is context switching and what is its impact on performance?",
    "answer": "Context switching is the process of storing and restoring thread state when switching between threads on a CPU core. Process involves: 1) Saving current thread's state (registers, program counter, stack pointer), 2) Loading next thread's state from memory, 3) Updating memory management structures, 4) Flushing CPU caches if necessary. Performance impacts: 1) Direct overhead - CPU time spent switching instead of useful work, 2) Cache misses - new thread may not benefit from cached data, 3) Memory bandwidth consumption - loading/storing thread state, 4) Pipeline stalls - CPU instruction pipeline may be disrupted. Factors affecting cost: 1) Number of threads - more threads = more context switches, 2) Thread switching frequency - depends on time slicing and synchronization, 3) Working set size - larger memory footprint increases cache misses, 4) CPU architecture - some CPUs handle context switches more efficiently. Optimization strategies: use appropriate number of threads (typically CPU cores + 1), minimize unnecessary synchronization, use thread pools to reduce thread creation overhead, and consider thread affinity for CPU-intensive tasks."
  },
  {
    "question": "What are the different approaches to thread communication in Java?",
    "answer": "Java provides several mechanisms for inter-thread communication: 1) wait()/notify()/notifyAll() - classic approach using object monitors, threads wait for conditions and notify when conditions change, 2) BlockingQueue - producer-consumer communication through thread-safe queues like ArrayBlockingQueue, LinkedBlockingQueue, 3) Condition variables - more flexible than wait/notify, multiple conditions per lock using ReentrantLock.newCondition(), 4) CountDownLatch - one-time signaling when tasks complete, 5) CyclicBarrier - threads wait for each other at synchronization points, 6) Semaphore - controlling access to limited resources through permits, 7) Exchanger - two threads exchange objects at synchronization point, 8) CompletableFuture - asynchronous communication through future composition, 9) Shared memory with synchronization - using volatile variables, atomic classes, 10) Message passing - through concurrent collections or dedicated messaging frameworks. Choice depends on communication pattern: one-time events (CountDownLatch), producer-consumer (BlockingQueue), barrier synchronization (CyclicBarrier), or complex async workflows (CompletableFuture)."
  },
  {
    "question": "What are daemon threads in Java and when should they be used?",
    "answer": "Daemon threads are threads that run in the background and don't prevent JVM from exiting when all non-daemon (user) threads complete. Characteristics: 1) JVM terminates when only daemon threads remain running, 2) Set using setDaemon(true) before starting thread, 3) Child threads inherit daemon status from parent thread, 4) Cannot prevent JVM shutdown - may be terminated abruptly, 5) Typically used for background services and housekeeping tasks. Common use cases: 1) Garbage collection - GC runs in daemon threads, 2) Background cleanup tasks - temporary file cleanup, cache eviction, 3) Monitoring and logging services, 4) Keep-alive connections maintenance, 5) Background data processing that's not critical for application. Important considerations: daemon threads may not complete their work if JVM shuts down, avoid using daemon threads for critical operations like writing to files or databases, ensure proper cleanup if daemon thread manages resources. Use daemon threads for non-essential background services that should not prevent application shutdown."
  },
  {
    "question": "What is thread local storage and how does ThreadLocal work internally?",
    "answer": "ThreadLocal provides thread-local variables where each thread has its own independent copy. Internal implementation: 1) Each Thread object has a ThreadLocalMap field storing thread-local variables, 2) ThreadLocalMap uses WeakReference keys (ThreadLocal objects) to prevent memory leaks, 3) get() method retrieves value from current thread's ThreadLocalMap, 4) set() method stores value in current thread's map, 5) remove() cleans up the variable to prevent memory leaks. Key characteristics: 1) Values are isolated per thread - no synchronization needed, 2) Initial value can be set by overriding initialValue() method, 3) Suitable for per-thread context like user sessions, database connections, 4) Performance benefit - no synchronization overhead. Memory considerations: 1) ThreadLocal variables may cause memory leaks if not cleaned up properly, 2) In application servers with thread pools, threads are reused so ThreadLocal values persist, 3) Always call remove() when done, especially in web applications, 4) Use static final ThreadLocal instances when possible. Common use cases: SimpleDateFormat (thread-unsafe), per-request context in web applications, connection management."
  },
  {
    "question": "What are the performance implications of different synchronization mechanisms?",
    "answer": "Different synchronization mechanisms have varying performance characteristics: 1) synchronized blocks/methods - moderate overhead, optimized by JVM with biased locking, lightweight locking, but can cause thread blocking, 2) ReentrantLock - slightly higher overhead than synchronized but more flexible, supports try-lock and timed operations, 3) volatile variables - very low overhead, ensures visibility but no atomicity for compound operations, 4) Atomic classes (AtomicInteger, etc.) - low overhead using CAS operations, lock-free but may spin under high contention, 5) concurrent collections - optimized for specific use cases, ConcurrentHashMap uses segment locking for better scalability, 6) ThreadLocal - no synchronization overhead, highest performance for per-thread data, but memory overhead per thread. Performance factors: 1) Contention level - high contention degrades performance more for blocking mechanisms, 2) Critical section size - smaller sections reduce blocking time, 3) CPU architecture - different CPUs handle atomic operations differently, 4) JVM optimizations - escape analysis, lock coarsening, lock elision can optimize synchronized code. General rule: use simplest mechanism that meets requirements, prefer non-blocking approaches for high-contention scenarios."
  },
  {
    "question": "What is lock-free programming and when is it beneficial?",
    "answer": "Lock-free programming uses atomic operations and compare-and-swap (CAS) to achieve thread safety without explicit locking. Key concepts: 1) Compare-and-swap - atomically compare value and update if unchanged, 2) Memory ordering - ensuring correct visibility of operations across threads, 3) ABA problem - value changes from A to B and back to A, appearing unchanged, 4) Retry loops - operations may fail and need retry due to concurrent modifications. Benefits: 1) No blocking - threads never wait for locks, potentially better performance, 2) No deadlock - impossible since no locks are acquired, 3) Better scalability - performance may scale better with thread count, 4) Progress guarantee - at least one thread makes progress (lock-free property). Challenges: 1) Complexity - much harder to implement correctly than lock-based code, 2) ABA problem - requires careful design or generation counters, 3) Memory management - more complex in garbage-collected languages, 4) Platform dependency - relies on hardware atomic operations. Java support: atomic classes (AtomicInteger, AtomicReference), concurrent collections use lock-free techniques internally, sun.misc.Unsafe (deprecated) provides low-level atomic operations. Use when: very high performance requirements, lock contention is bottleneck, and you have expertise in concurrent programming."
  },
  {
    "question": "What are the common threading anti-patterns and how to avoid them?",
    "answer": "Common threading anti-patterns and their solutions: 1) Creating too many threads - causes context switching overhead and resource exhaustion. Solution: use thread pools with appropriate sizing, 2) Not handling InterruptedException properly - ignoring interrupts prevents proper thread shutdown. Solution: restore interrupt status or propagate exception, 3) Sharing mutable state without synchronization - causes race conditions. Solution: use proper synchronization or immutable objects, 4) Nested locking with different orders - causes deadlock. Solution: consistent lock ordering or use lock timeouts, 5) Using Thread.stop(), suspend(), resume() - deprecated and unsafe methods. Solution: use interrupt mechanism and cooperative cancellation, 6) Not releasing resources in finally blocks - causes resource leaks. Solution: use try-with-resources or proper finally cleanup, 7) Busy waiting with while loops - wastes CPU cycles. Solution: use proper blocking operations like wait(), BlockingQueue, 8) Catching Exception in thread run() method - may hide important errors. Solution: catch specific exceptions and use UncaughtExceptionHandler, 9) Not making fields volatile when accessed by multiple threads - visibility issues. Solution: use volatile or proper synchronization, 10) Using double-checked locking incorrectly - without volatile can break on some platforms. Solution: use volatile or initialization-on-demand holder pattern."
  },
  {
    "question": "What is the difference between fail-fast and fail-safe iterators in concurrent programming?",
    "answer": "Fail-fast and fail-safe iterators handle concurrent modifications differently: Fail-fast iterators: 1) Throw ConcurrentModificationException if collection is modified during iteration, 2) Work on original collection, detecting modifications via modification count, 3) Used by ArrayList, HashMap, HashSet iterators, 4) Fast detection of concurrent modification but don't allow modifications during iteration, 5) Must synchronize externally if concurrent access is needed. Fail-safe iterators: 1) Work on copy or snapshot of collection, never throw ConcurrentModificationException, 2) Allow modifications during iteration but may not reflect latest changes, 3) Used by ConcurrentHashMap, CopyOnWriteArrayList, 4) Thread-safe but may have stale data, 5) Higher memory overhead due to copying or snapshotting. When to use: 1) Fail-fast for single-threaded scenarios or when you want early detection of concurrent modifications, 2) Fail-safe for concurrent scenarios where iteration must proceed despite modifications, 3) Consider weakly consistent iterators (like ConcurrentHashMap) that provide middle ground - don't fail but may reflect some recent changes. Choose based on whether you need strong consistency vs. availability during concurrent modifications."
  },
  {
    "question": "What are the different types of thread pools and when to use each?",
    "answer": "Java provides several thread pool types through Executors factory methods: 1) FixedThreadPool - fixed number of threads, good for stable workloads with predictable resource requirements, threads are reused for multiple tasks, 2) CachedThreadPool - creates threads as needed, suitable for many short-lived asynchronous tasks, may grow unbounded under load, 3) SingleThreadExecutor - single worker thread, ensures tasks execute sequentially, good for ordered processing, 4) ScheduledThreadPool - supports delayed and periodic execution, replaces Timer for better concurrency, 5) WorkStealingPool - uses ForkJoinPool with work-stealing, good for parallel processing and divide-conquer algorithms. Custom ThreadPoolExecutor allows fine-tuning: core pool size (minimum threads), maximum pool size, keep-alive time, work queue type. Queue types affect behavior: 1) LinkedBlockingQueue (unbounded) - may cause memory issues, 2) ArrayBlockingQueue (bounded) - may reject tasks when full, 3) SynchronousQueue - direct handoff, creates threads as needed. Choosing guidelines: CPU-intensive tasks use pool size = CPU cores, I/O-intensive tasks can use larger pools, consider queue size and task characteristics, monitor pool metrics for optimization."
  },
  {
    "question": "What is the difference between intrinsic locks and explicit locks in Java?",
    "answer": "Intrinsic locks (synchronized) and explicit locks (ReentrantLock) provide different locking mechanisms: Intrinsic locks: 1) Built into Java language using synchronized keyword, 2) Automatically acquired and released by JVM, 3) Block-structured - must release in same scope where acquired, 4) Cannot be interrupted while waiting for lock, 5) Simple syntax but limited flexibility, 6) JVM can optimize with techniques like lock coarsening, biased locking, 7) Support single condition variable with wait()/notify(). Explicit locks: 1) Provided through java.util.concurrent.locks package, 2) Manual acquisition and release (try/finally required), 3) More flexible - can acquire in one method and release in another, 4) Support interruption with lockInterruptibly(), 5) Timed lock attempts with tryLock(timeout), 6) Fair vs unfair locking options, 7) Multiple condition variables per lock, 8) Can query lock state and waiting threads. When to use: intrinsic locks for simple synchronization needs, better JVM optimization; explicit locks for advanced features like fairness, timeouts, multiple conditions, or complex locking patterns. Performance is generally comparable, with intrinsic locks having slight edge due to JVM optimizations."
  },
  {
    "question": "What are the memory consistency effects of volatile keyword?",
    "answer": "The volatile keyword provides memory consistency effects beyond simple visibility: 1) Visibility guarantee - writes to volatile variable are immediately visible to all threads, reads always get latest value from main memory, 2) Ordering guarantee - prevents reordering of operations around volatile operations, 3) Happens-before relationship - write to volatile variable happens-before any subsequent read of same variable, 4) Memory barrier effects - volatile write creates store-store and store-load barriers, volatile read creates load-load and load-store barriers, 5) Transitivity - if thread A writes volatile variable seen by thread B, then all variables visible to A before volatile write are visible to B after volatile read. What volatile does NOT provide: 1) Atomicity for compound operations (increment, check-then-act), 2) Mutual exclusion - multiple threads can access volatile variable simultaneously, 3) Protection for non-volatile variables accessed in same context. Use cases: 1) Status flags (isRunning, isComplete), 2) Simple state variables, 3) Double-checked locking pattern (with proper implementation), 4) Publishing objects safely. Volatile is lightweight alternative to synchronization when only visibility and ordering are needed, not mutual exclusion."
  },
  {
    "question": "What is the Fork/Join framework's work-stealing algorithm?",
    "answer": "Work-stealing is the core algorithm in Fork/Join framework that optimizes parallel task execution: Algorithm mechanics: 1) Each worker thread has its own deque (double-ended queue) of tasks, 2) Threads add new tasks to tail of their own deque, 3) Threads take tasks from head of their own deque (LIFO for better cache locality), 4) When thread's deque is empty, it 'steals' tasks from tail of other threads' deques (FIFO to avoid conflicts), 5) Stealing continues until no more tasks exist. Benefits: 1) Load balancing - idle threads automatically help busy threads, 2) Cache efficiency - threads primarily work on their own tasks, 3) Reduced contention - stealing from tail while owner works from head, 4) Dynamic adaptation - automatically adjusts to varying task sizes and thread performance. Fork/Join task patterns: 1) fork() - splits task and adds subtasks to current thread's deque, 2) join() - waits for subtask completion, may steal and execute other tasks while waiting, 3) Recursive decomposition continues until tasks reach base case. Best practices: 1) Use for recursive, divide-and-conquer algorithms, 2) Ensure tasks are CPU-intensive enough to justify overhead, 3) Avoid blocking operations in tasks, 4) Balance task granularity - not too fine or coarse. The algorithm maximizes CPU utilization and minimizes synchronization overhead."
  },
  {
    "question": "What are the best practices for exception handling in multithreaded applications?",
    "answer": "Exception handling in multithreaded applications requires special considerations: 1) UncaughtExceptionHandler - set handlers for threads using Thread.setUncaughtExceptionHandler() or Thread.setDefaultUncaughtExceptionHandler() to handle exceptions that escape run() method, 2) ExecutorService exception handling - exceptions in submitted tasks are captured and available via Future.get() as ExecutionException, use try-catch around get() calls, 3) CompletableFuture exceptions - use exceptionally(), handle(), or whenComplete() methods for asynchronous exception handling, 4) Don't let exceptions escape run() method - always catch and handle exceptions within thread's run() method to prevent thread termination, 5) Thread-safe logging - use thread-safe logging frameworks and avoid shared mutable state in exception handlers, 6) Graceful shutdown - design threads to handle interruption properly, check Thread.interrupted() status and exit cleanly, 7) Resource cleanup - ensure finally blocks or try-with-resources are used to clean up resources even when exceptions occur, 8) Avoid catching generic Exception - catch specific exceptions and handle appropriately, 9) Propagate interruption - if catching InterruptedException, restore interrupt status with Thread.currentThread().interrupt(), 10) Monitor and alert - implement proper monitoring for thread failures and exceptions in production systems."
  },
  {
    "question": "What is the difference between cooperative and preemptive multitasking in Java?",
    "answer": "Java primarily uses preemptive multitasking but provides some cooperative elements: Preemptive multitasking: 1) JVM/OS controls thread scheduling, can interrupt threads at any time, 2) Time slicing ensures fair CPU distribution among threads, 3) Threads cannot monopolize CPU indefinitely, 4) Better system responsiveness and fault tolerance, 5) No dependence on thread cooperation for scheduling, 6) Used by default in modern JVMs. Cooperative elements in Java: 1) Thread.yield() - suggests thread should yield CPU to others, 2) Thread.sleep() - voluntarily gives up CPU for specified time, 3) Object.wait() - thread voluntarily waits until notified, 4) Blocking I/O operations - thread yields CPU while waiting for I/O, 5) Lock acquisition - thread may yield while waiting for locks. Benefits of preemptive: 1) Prevents poorly behaved threads from blocking system, 2) Automatic fairness without programmer intervention, 3) Better system stability and responsiveness, 4) Protection against infinite loops in one thread. Cooperative benefits: 1) Lower overhead when used appropriately, 2) More predictable scheduling in some scenarios, 3) Can improve overall throughput when threads cooperate well. Modern Java applications benefit from understanding both models to write efficient concurrent code that works well with the underlying scheduling system."
  },
  {
    "question": "What are the common concurrent design patterns in Java?",
    "answer": "Common concurrent design patterns help solve recurring concurrency problems: 1) Producer-Consumer - producers generate data, consumers process it, typically using BlockingQueue for coordination, handles different production/consumption rates, 2) Reader-Writer - multiple readers can access resource simultaneously, writers need exclusive access, implemented using ReadWriteLock or StampedLock, 3) Thread Pool - reuse threads for multiple tasks to avoid creation overhead, implemented via ExecutorService, 4) Future/Promise - represents result of asynchronous computation, allows non-blocking task submission with later result retrieval, 5) Master-Worker - master distributes work to worker threads, collects results, good for parallel processing of independent tasks, 6) Pipeline - tasks flow through stages processed by different threads, each stage adds value to the data, 7) Fork-Join - recursively divide problem into smaller subproblems, process in parallel, then combine results, 8) Active Object - encapsulates method requests as objects, executes them asynchronously in separate thread, 9) Guarded Suspension - thread waits until condition becomes true before proceeding, implemented with wait/notify or Condition, 10) Double-Checked Locking - optimized singleton pattern with lazy initialization and minimal synchronization. Choose patterns based on problem characteristics: data flow, synchronization needs, performance requirements."
  },
  {
    "question": "What are the key considerations when designing thread-safe classes?",
    "answer": "Designing thread-safe classes requires careful consideration of multiple factors: 1) Identify shared mutable state - determine which fields will be accessed by multiple threads and need protection, 2) Choose synchronization strategy - synchronized methods/blocks, explicit locks, atomic variables, or immutability, 3) Ensure atomicity - compound operations (check-then-act, read-modify-write) must be atomic, 4) Guarantee visibility - use volatile, synchronization, or atomic variables to ensure changes are visible across threads, 5) Prevent data races - ensure consistent view of object state across all threads, 6) Document thread safety guarantees - clearly specify what level of thread safety the class provides, 7) Consider performance implications - balance safety with performance, use appropriate synchronization granularity, 8) Handle state dependencies - ensure invariants are maintained when multiple fields are related, 9) Design for composition - consider how class will be used with other thread-safe/unsafe classes, 10) Minimize synchronization scope - synchronize only what's necessary to reduce contention, 11) Use immutable objects when possible - they're inherently thread-safe, 12) Consider using concurrent collections instead of synchronizing regular collections, 13) Test thoroughly - use stress testing and concurrent testing frameworks to verify thread safety under load."
  },
  {
    "question": "When would you use TreeSet over HashSet in Java?",
    "answer": "Use TreeSet when you need to maintain a sorted order of elements automatically. TreeSet stores elements in a sorted order using a red-black tree (balanced binary search tree), providing O(log n) time complexity for basic operations. It's ideal for scenarios like: maintaining a leaderboard with scores in sorted order, storing unique words alphabetically, implementing range queries where you need elements between certain values, or when you need navigational methods like first(), last(), higher(), lower(). Use HashSet when you only need uniqueness without caring about order, as it provides O(1) average time complexity for basic operations."
  },
  {
    "question": "What is the difference between HashMap and TreeMap in Java?",
    "answer": "HashMap and TreeMap are both implementations of the Map interface but with different characteristics: HashMap uses a hash table for storage, provides O(1) average time complexity for basic operations, does not maintain any order of keys, allows one null key and multiple null values, and is not thread-safe. TreeMap uses a red-black tree structure, provides O(log n) time complexity for basic operations, maintains keys in sorted order (natural ordering or custom comparator), does not allow null keys but allows null values, and is also not thread-safe. Use HashMap for fast access when order doesn't matter, and TreeMap when you need sorted keys or range operations."
  },
  {
    "question": "What is the difference between ArrayList and Vector in Java?",
    "answer": "ArrayList and Vector are both resizable array implementations of the List interface, but they differ in several key aspects: ArrayList is not synchronized (not thread-safe) and faster, while Vector is synchronized (thread-safe) but slower due to synchronization overhead. ArrayList grows by 50% when capacity is exceeded, while Vector doubles its size. Vector is legacy from Java 1.0, while ArrayList was introduced in Java 1.2 as part of the Collections Framework. ArrayList is preferred in single-threaded environments for better performance, while Vector can be used in multi-threaded scenarios, though modern alternatives like Collections.synchronizedList() or concurrent collections are generally preferred."
  },
  {
    "question": "What is the difference between Enumeration and Iterator in Java?",
    "answer": "Enumeration and Iterator are both interfaces for traversing collections, but Iterator is more advanced: Enumeration is older (Java 1.0) and provides only hasMoreElements() and nextElement() methods for forward-only traversal without element removal capability. Iterator is newer (Java 1.2) and provides hasNext(), next(), and remove() methods, allowing element removal during iteration. Iterator is fail-fast and throws ConcurrentModificationException if the collection is modified during iteration (except through iterator's remove method), while Enumeration is not fail-fast. Iterator is preferred for modern code as it's more flexible and safer."
  },
  {
    "question": "What is the difference between fail-fast and fail-safe iterators?",
    "answer": "Fail-fast and fail-safe iterators handle concurrent modifications differently: Fail-fast iterators (used by ArrayList, HashMap, HashSet) throw ConcurrentModificationException if the collection is modified during iteration by another thread or method (except through iterator's own methods). They work on the original collection and detect modifications via modification count. Fail-safe iterators (used by ConcurrentHashMap, CopyOnWriteArrayList) work on a copy or snapshot of the collection and never throw ConcurrentModificationException. They allow concurrent modifications but may not reflect the latest changes. Choose fail-fast for single-threaded scenarios or when you want early detection of concurrent modifications, and fail-safe for concurrent scenarios where iteration must continue despite modifications."
  },
  {
    "question": "What is the difference between Comparable and Comparator interfaces?",
    "answer": "Comparable and Comparator are both used for sorting objects but serve different purposes: Comparable is implemented by the class whose objects need to be sorted, defining natural ordering through the compareTo() method. It provides a single way to compare objects of that class. Comparator is a separate functional interface that defines custom comparison logic and can be implemented externally without modifying the original class. It allows multiple sorting strategies for the same class. Use Comparable for natural ordering (like String's alphabetical order), and Comparator for custom sorting criteria or when you can't modify the original class. Comparator can be implemented as lambda expressions: (a, b) -> a.getName().compareTo(b.getName())."
  },
  {
    "question": "How do you sort a List in Java using different criteria?",
    "answer": "You can sort a List in Java using several approaches: 1) Collections.sort(list) for objects implementing Comparable, 2) Collections.sort(list, comparator) with a custom Comparator, 3) list.sort(comparator) method available since Java 8, 4) Using streams: list.stream().sorted().collect(Collectors.toList()). For custom criteria, create Comparator using lambda expressions: list.sort((a, b) -> a.getName().compareTo(b.getName())), or method references: list.sort(Comparator.comparing(Person::getName)). You can chain comparators: list.sort(Comparator.comparing(Person::getAge).thenComparing(Person::getName)). For reverse order, use Comparator.reverseOrder() or comparing().reversed()."
  },
  {
    "question": "What is the Properties class in Java and how is it used?",
    "answer": "Properties is a subclass of Hashtable that represents a persistent set of properties, typically used for configuration files. It stores key-value pairs where both keys and values are strings. Common uses include: storing application configuration, reading .properties files, system properties access. Key methods include: getProperty(key), setProperty(key, value), load(InputStream), store(OutputStream, comments), propertyNames(). Example: Properties props = new Properties(); props.load(new FileInputStream(\"config.properties\")); String dbUrl = props.getProperty(\"database.url\", \"defaultValue\");. Properties files use format: key=value or key:value, support line comments with # or !, and can include Unicode escapes."
  },
  {
    "question": "What is the difference between HashMap and Hashtable?",
    "answer": "HashMap and Hashtable are both hash table implementations but differ significantly: HashMap is not synchronized (not thread-safe), allows one null key and multiple null values, is faster due to no synchronization overhead, was introduced in Java 1.2 as part of Collections Framework, and has fail-fast iterators. Hashtable is synchronized (thread-safe), doesn't allow null keys or values, is slower due to synchronization, is legacy from Java 1.0, and has fail-safe enumerators. HashMap is preferred for single-threaded applications, while for thread safety, use ConcurrentHashMap instead of Hashtable as it provides better performance through segment-based locking."
  },
  {
    "question": "What is ConcurrentHashMap and how does it achieve thread safety?",
    "answer": "ConcurrentHashMap is a thread-safe implementation of Map that provides better concurrency than synchronized maps. It achieves thread safety through: 1) Segment-based locking (Java 7 and earlier) - divides the map into segments, each with its own lock, 2) Node-based locking (Java 8+) - uses synchronized blocks on individual nodes and CAS operations, 3) Lock-free reads - read operations don't require locks, 4) Atomic operations for basic operations like get, put, remove. Key features: allows concurrent reads, limited concurrent writes, fail-safe iterators, null values and keys not allowed, and putIfAbsent(), replace(), remove() atomic operations. It provides much better scalability than Hashtable or Collections.synchronizedMap() in multi-threaded environments."
  },
  {
    "question": "What is WeakHashMap and when would you use it?",
    "answer": "WeakHashMap is a Map implementation that uses weak references for keys, allowing keys to be garbage collected when they're no longer strongly referenced elsewhere in the application. When a key is garbage collected, its corresponding entry is automatically removed from the map. Use cases include: implementing caches where entries should be removed when keys are no longer used, preventing memory leaks in scenarios where you need to associate data with objects temporarily, creating observer patterns where observers can be garbage collected. Important considerations: values are strongly referenced, so if values reference keys, it prevents garbage collection. WeakHashMap is not thread-safe and requires external synchronization for concurrent access."
  },
  {
    "question": "What is the difference between Array and ArrayList?",
    "answer": "Arrays and ArrayList differ in several fundamental ways: Arrays have fixed size determined at creation time, while ArrayList is dynamically resizable. Arrays can store primitives directly (int[], double[]), while ArrayList can only store objects (ArrayList<Integer>). Arrays provide faster access and use less memory overhead, while ArrayList offers more functionality with methods like add(), remove(), contains(). Arrays use array[index] syntax, while ArrayList uses get(index) and set(index, value) methods. Arrays are part of core Java language, while ArrayList is part of Collections Framework. Choose arrays for fixed-size collections of primitives or when performance is critical, and ArrayList for dynamic collections requiring frequent modifications."
  },
  {
    "question": "What are the different ways to iterate over a collection in Java?",
    "answer": "Java provides several ways to iterate over collections: 1) Enhanced for-loop (for-each): for(String item : list) - simple and readable, 2) Traditional for-loop with index: for(int i=0; i<list.size(); i++) - allows index access, 3) Iterator: while(iterator.hasNext()) iterator.next() - allows safe removal during iteration, 4) ListIterator: provides bidirectional traversal for Lists, 5) forEach method with lambda: list.forEach(System.out::println) - functional style, 6) Streams: list.stream().forEach(System.out::println) - enables further processing, 7) While loop with Iterator for custom control. Choose based on needs: for-each for simple iteration, Iterator for safe removal, forEach for functional style, streams for complex processing."
  },
  {
    "question": "What is the Collections utility class and its important methods?",
    "answer": "Collections is a utility class providing static methods for common collection operations: Sorting: sort(), reverseOrder(), binarySearch() for searching sorted collections. Modification: reverse(), shuffle(), rotate(), swap() for rearranging elements. Thread safety: synchronizedList(), synchronizedSet(), synchronizedMap() for creating thread-safe wrappers. Immutability: unmodifiableList(), unmodifiableSet(), unmodifiableMap() for read-only views. Factory methods: emptyList(), singletonList(), nCopies() for creating special collections. Search and replace: min(), max(), frequency(), replaceAll() for finding and modifying elements. These methods work with any collection implementing the appropriate interface, providing consistent behavior across different collection types."
  },
  {
    "question": "What is the difference between Collections.emptyList() and new ArrayList()?",
    "answer": "Collections.emptyList() returns a singleton immutable empty list that cannot be modified, saves memory by reusing the same instance across the application, and throws UnsupportedOperationException if you try to modify it. new ArrayList() creates a new mutable empty list instance that can be modified by adding/removing elements. Use Collections.emptyList() when returning an empty list that won't be modified (following the pattern of returning empty collections instead of null), and new ArrayList() when you need a mutable list that will be populated later. Collections.emptyList() is more memory-efficient and prevents accidental modifications, while new ArrayList() provides full list functionality."
  },
  {
    "question": "What are the different ways to convert an Array to a List in Java?",
    "answer": "Several methods exist to convert arrays to lists: 1) Arrays.asList(array) - creates a fixed-size list backed by the array, modifications reflect in both, 2) new ArrayList<>(Arrays.asList(array)) - creates a mutable copy of the array, 3) Collections.addAll(list, array) - adds array elements to existing list, 4) Stream API: Arrays.stream(array).collect(Collectors.toList()) - functional approach, 5) Manual iteration with for-loop adding elements. For primitive arrays, use specialized methods or streams: Arrays.stream(intArray).boxed().collect(Collectors.toList()). Choose Arrays.asList() for simple conversion where mutability isn't needed, ArrayList constructor for mutable lists, or streams for additional processing during conversion."
  },
  {
    "question": "What is the difference between List.of() and Arrays.asList()?",
    "answer": "List.of() (Java 9+) and Arrays.asList() both create lists from elements but have key differences: List.of() creates an immutable list that cannot be modified (no add, remove, set operations), doesn't allow null elements, and is not backed by an array. Arrays.asList() creates a fixed-size list backed by the original array, allows modifications to existing elements via set(), allows null elements, and changes reflect in both list and original array. List.of() is preferred for creating immutable lists with compile-time safety, while Arrays.asList() is used when you need a list view of an array with limited mutability. Both throw exceptions for unsupported operations but with different modification capabilities."
  },
  {
    "question": "What is the difference between peek() and poll() methods in Queue?",
    "answer": "peek() and poll() are both Queue methods for accessing the head element but behave differently: peek() returns the head element without removing it from the queue, returns null if the queue is empty, and doesn't modify the queue state. poll() returns and removes the head element from the queue, returns null if the queue is empty, and modifies the queue by removing the element. Similarly, element() throws NoSuchElementException if queue is empty (instead of returning null like peek()), and remove() throws NoSuchElementException if queue is empty (instead of returning null like poll()). Use peek() for inspection without modification, and poll() for consumption of queue elements."
  },
  {
    "question": "What is PriorityQueue and how does it work?",
    "answer": "PriorityQueue is a heap-based priority queue implementation where elements are ordered by their priority, not insertion order. It uses a binary heap data structure (array-based) for efficient insertion and removal. Elements are ordered by natural ordering (if Comparable) or by a provided Comparator. Key characteristics: head element is always the smallest (or highest priority), not thread-safe, doesn't allow null elements, and provides O(log n) time for insertion and removal, O(1) for peek. Common methods: offer() to add, poll() to remove head, peek() to view head, and comparator() to get ordering. Use cases include task scheduling, finding top K elements, implementing Dijkstra's algorithm, or any scenario requiring ordered processing by priority."
  },
  {
    "question": "What is Deque interface and its implementations?",
    "answer": "Deque (Double Ended Queue) extends Queue interface and allows insertion and removal of elements from both ends. It provides methods for both ends: addFirst(), addLast(), removeFirst(), removeLast(), peekFirst(), peekLast(), and corresponding offer/poll variants. Main implementations are ArrayDeque (resizable array) and LinkedList (doubly-linked list). ArrayDeque is generally preferred due to better performance and memory efficiency - it provides O(1) operations at both ends, no capacity restrictions, and is not thread-safe. Deque can function as both stack (LIFO) using push()/pop() and queue (FIFO) using offer()/poll(). Use ArrayDeque for general deque operations, LinkedList when you also need List interface functionality."
  },
  {
    "question": "What is NavigableSet and NavigableMap in Java?",
    "answer": "NavigableSet extends SortedSet and NavigableMap extends SortedMap, providing navigation methods for finding closest matches in sorted collections. NavigableSet methods include: lower(e) - greatest element less than e, floor(e) - greatest element ≤ e, ceiling(e) - smallest element ≥ e, higher(e) - smallest element greater than e, descendingSet() - reverse view, and pollFirst()/pollLast() for retrieval and removal. NavigableMap provides similar navigation methods plus firstEntry(), lastEntry(), pollFirstEntry(), pollLastEntry(). TreeSet and TreeMap implement these interfaces respectively. These interfaces enable efficient range queries, finding nearest elements, and iteration in both directions, making them ideal for applications like range searches, finding predecessors/successors, and implementing algorithms requiring sorted navigation."
  },
  {
    "question": "What is the difference between capacity and size in ArrayList?",
    "answer": "Size is the number of elements currently stored in the ArrayList, returned by size() method and represents the logical size. Capacity is the length of the internal array that stores the elements, representing the physical storage space available. Capacity is always greater than or equal to size. When capacity is reached and a new element is added, ArrayList creates a larger array (typically 50% larger) and copies existing elements. You can manage capacity using: ArrayList(int initialCapacity) constructor to set initial capacity, ensureCapacity(int minCapacity) to increase capacity before bulk operations, and trimToSize() to reduce capacity to current size. Understanding this distinction helps optimize performance by avoiding frequent reallocations during bulk insertions."
  },
  {
    "question": "What are the performance characteristics of different List implementations?",
    "answer": "Different List implementations have varying performance characteristics: ArrayList provides O(1) random access via get()/set(), O(1) amortized insertion at end, O(n) insertion/deletion in middle due to shifting elements, and good memory locality for iteration. LinkedList provides O(n) random access, O(1) insertion/deletion at known positions (with iterator), O(1) insertion/deletion at ends, but higher memory overhead due to node pointers. Vector has similar performance to ArrayList but with synchronization overhead. CopyOnWriteArrayList has O(1) reads, expensive writes (O(n) as it copies entire array), suitable for read-heavy scenarios. Choose based on usage patterns: ArrayList for general use with frequent random access, LinkedList for frequent insertions/deletions, CopyOnWriteArrayList for concurrent read-heavy scenarios."
  },
  {
    "question": "What is the diamond problem in Java and how does it relate to interfaces?",
    "answer": "The diamond problem occurs when a class inherits the same method from multiple sources, creating ambiguity about which implementation to use. Java avoided this with classes by allowing only single inheritance, but interfaces can create similar issues with default methods. When a class implements multiple interfaces with conflicting default methods, Java resolution rules apply: 1) Class methods override interface defaults, 2) More specific interface defaults override general ones, 3) Explicit override required for ambiguity. Example: if Interface A and B both have default method foo(), implementing class must override foo() to resolve ambiguity. Use InterfaceName.super.methodName() to call specific interface implementation. This design maintains interface evolution capability while preventing ambiguity."
  },
  {
    "question": "What are marker interfaces in Java and provide examples?",
    "answer": "Marker interfaces are interfaces with no methods that serve as markers or tags to indicate that a class has certain properties or capabilities. They provide metadata about the class to the JVM or frameworks. Examples include: Serializable - indicates that objects can be serialized, Cloneable - indicates that objects can be cloned using clone() method, RandomAccess - indicates that list supports fast random access (like ArrayList), and Remote - indicates that an object can be used for RMI. Modern Java tends to use annotations instead of marker interfaces for similar purposes, as annotations are more flexible and can carry additional metadata. However, marker interfaces are still used for core JVM functionality where compile-time type checking is important."
  },
  {
    "question": "What is the Builder pattern and how is it implemented in Java?",
    "answer": "The Builder pattern is a creational design pattern used to construct complex objects step by step. It's particularly useful when creating objects with many optional parameters or when object construction requires multiple steps. Implementation involves: 1) A static nested Builder class inside the main class, 2) Private constructor in main class that takes Builder as parameter, 3) Builder methods that return the Builder instance for method chaining, 4) build() method that creates and returns the final object. Benefits include: avoiding telescoping constructor anti-pattern, creating immutable objects, clear and readable object creation, and validation before object creation. Example: Person person = new Person.Builder().setName(\"John\").setAge(30).setEmail(\"john@example.com\").build(); The pattern is commonly used in libraries like StringBuilder, Lombok @Builder annotation, and API clients."
  },
  {
    "question": "What is the Factory pattern and its variations in Java?",
    "answer": "The Factory pattern is a creational design pattern that provides an interface for creating objects without specifying their exact classes. Variations include: 1) Simple Factory - static method that returns objects based on parameters, 2) Factory Method - abstract method in base class overridden by subclasses to create specific objects, 3) Abstract Factory - interface for creating families of related objects. Benefits include: decoupling object creation from usage, centralized object creation logic, easier testing with mock objects, and adherence to Open/Closed principle. Example: DatabaseConnectionFactory.createConnection(\"MySQL\") could return MySQLConnection instance. Java uses factory patterns extensively: Collections.emptyList(), Executors.newFixedThreadPool(), Files.newBufferedReader(), etc. The pattern promotes loose coupling and makes code more maintainable and testable."
  },
  {
    "question": "What is the Observer pattern and how is it implemented in Java?",
    "answer": "The Observer pattern defines a one-to-many dependency between objects so that when one object (Subject) changes state, all dependents (Observers) are notified automatically. Implementation involves: 1) Observer interface with update() method, 2) Subject interface with attach(), detach(), and notify() methods, 3) Concrete Subject maintaining list of observers and notifying them of changes, 4) Concrete Observers implementing update() to respond to notifications. Java provided built-in support with Observable class and Observer interface (now deprecated). Modern implementations use: custom interfaces, event listeners, reactive streams (RxJava), or Java 9+ Flow API. Benefits include: loose coupling between subject and observers, dynamic relationships, and broadcast communication. Common in GUI frameworks, model-view architectures, and event-driven systems."
  },
  {
    "question": "What is the Singleton pattern and what are its different implementations?",
    "answer": "Singleton pattern ensures a class has only one instance and provides global access point. Implementation approaches: 1) Eager initialization - instance created at class loading: private static final Singleton INSTANCE = new Singleton(); 2) Lazy initialization - instance created when first needed, but not thread-safe, 3) Thread-safe lazy - using synchronized getInstance() method, slower due to synchronization, 4) Double-checked locking - checks instance twice with synchronization only during creation, 5) Bill Pugh solution - using static inner class for lazy loading with thread safety, 6) Enum singleton - most robust, handles serialization and reflection automatically. Considerations include thread safety, serialization, reflection attacks, and performance. Enum approach is generally recommended for its simplicity and built-in protections."
  },
  {
    "question": "What is the Strategy pattern and how does it promote flexibility?",
    "answer": "The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable at runtime. It consists of: 1) Strategy interface defining common method signature, 2) Concrete strategies implementing different algorithms, 3) Context class that uses Strategy and can switch between them. Benefits include: eliminating conditional statements (if-else or switch), easy addition of new algorithms without modifying existing code, runtime algorithm selection, and improved testability. Example: PaymentStrategy interface with CreditCardPayment, PayPalPayment implementations, allowing PaymentContext to switch payment methods dynamically. Java's Collections.sort() uses strategy pattern by accepting Comparator. The pattern promotes Open/Closed principle and composition over inheritance, making code more flexible and maintainable."
  },
  {
    "question": "What is the Decorator pattern and how is it used in Java I/O?",
    "answer": "The Decorator pattern allows behavior to be added to objects dynamically without altering their structure. It involves: 1) Component interface defining common methods, 2) Concrete Component implementing basic functionality, 3) Decorator base class implementing Component and holding Component reference, 4) Concrete Decorators extending base decorator and adding specific functionality. Java I/O extensively uses this pattern: FileInputStream (concrete component), BufferedInputStream (decorator adding buffering), DataInputStream (decorator adding data type methods). You can chain decorators: new DataInputStream(new BufferedInputStream(new FileInputStream(\"file.txt\"))). Benefits include: flexible alternative to subclassing, runtime composition of behaviors, and adherence to Single Responsibility Principle. The pattern enables building complex functionality by combining simple components."
  },
  {
    "question": "What is the Command pattern and its use cases?",
    "answer": "The Command pattern encapsulates a request as an object, allowing you to parameterize clients with different requests, queue operations, and support undo functionality. Components include: 1) Command interface with execute() method, 2) Concrete Commands implementing specific operations, 3) Receiver objects that perform actual work, 4) Invoker that calls command execution, 5) Client that creates and configures commands. Benefits include: decoupling invoker from receiver, queuing and logging requests, supporting undo/redo operations, and implementing macros. Use cases: GUI buttons and menu items, macro recording, undo/redo functionality, queuing requests, remote procedure calls, and transaction processing. Example: Button (invoker) executes SaveCommand (command) that calls Document.save() (receiver). The pattern enables flexible request handling and supports complex operations like batching and rollback."
  },
  {
    "question": "What is the Template Method pattern?",
    "answer": "The Template Method pattern defines the skeleton of an algorithm in a base class, letting subclasses override specific steps without changing the algorithm's structure. Implementation involves: 1) Abstract class with template method containing algorithm skeleton, 2) Abstract methods that subclasses must implement, 3) Hook methods (optional) that subclasses can override for customization, 4) Final template method preventing algorithm structure changes. Benefits include: code reuse through inheritance, controlled extension points, and inversion of control (Hollywood Principle). Example: AbstractDataProcessor with process() template method calling readData(), processData(), writeData() steps, where subclasses implement specific data handling. Java examples include Collections.sort() using Comparable.compareTo(), servlet lifecycle methods, and stream processing pipelines. The pattern promotes code reuse while maintaining algorithmic integrity."
  },
  {
    "question": "What is the Adapter pattern and when would you use it?",
    "answer": "The Adapter pattern allows incompatible interfaces to work together by creating a wrapper that translates one interface to another. Types include: 1) Object Adapter - uses composition to wrap adaptee, 2) Class Adapter - uses inheritance (multiple inheritance required). Structure involves: Target interface (what client expects), Adaptee (existing incompatible interface), Adapter (implements Target and wraps Adaptee). Use cases: integrating third-party libraries, legacy code integration, making incompatible APIs work together, and creating reusable components. Example: adapting older java.util.Enumeration to newer java.util.Iterator interface. Benefits include: enabling code reuse without modification, integrating disparate systems, and providing clean interfaces. Java examples include InputStreamReader (adapts InputStream to Reader), Arrays.asList() (adapts arrays to List interface)."
  },
  {
    "question": "What is dependency injection and how is it implemented in Java?",
    "answer": "Dependency Injection (DI) is a design pattern where objects receive their dependencies from external sources rather than creating them internally. Types include: 1) Constructor injection - dependencies passed through constructor, 2) Setter injection - dependencies set through setter methods, 3) Interface injection - dependencies provided through interface methods. Benefits include: loose coupling, easier testing with mock objects, improved maintainability, and separation of concerns. Manual implementation involves: dependency interfaces, concrete implementations, and injection configuration. Framework implementations include Spring (@Autowired, @Component), Google Guice (@Inject), and CDI (@Inject). Example: class UserService { private UserRepository repo; public UserService(UserRepository repo) { this.repo = repo; } }. DI promotes testable, maintainable code by inverting control of dependency creation."
  },
  {
    "question": "What is the Model-View-Controller (MVC) pattern?",
    "answer": "MVC is an architectural pattern that separates application into three interconnected components: 1) Model - represents data and business logic, manages state and notifies views of changes, 2) View - represents presentation layer, displays data to user and sends user input to controller, 3) Controller - handles user input, processes requests, updates model, and selects appropriate view. Benefits include: separation of concerns, multiple views for same model, easier testing and maintenance, and parallel development. Java implementations include Spring MVC (web applications), JavaFX (desktop applications), and JSF. Example flow: user clicks button → controller processes request → controller updates model → model notifies view → view refreshes display. Variations include MVP (Model-View-Presenter) and MVVM (Model-View-ViewModel). MVC promotes organized, maintainable code architecture."
  },
  {
    "question": "What is the DAO (Data Access Object) pattern?",
    "answer": "DAO pattern abstracts and encapsulates all access to a data source, providing a clean separation between business logic and data access logic. Components include: 1) DAO interface defining data access methods, 2) Concrete DAO implementation for specific data source, 3) Model/Entity objects representing data, 4) DAO Factory for creating DAO instances. Benefits include: database independence, centralized data access logic, easier testing with mock DAOs, and consistent data access patterns. Example: UserDAO interface with methods like findById(), save(), delete(), implemented by UserDAOImpl for specific database. Modern alternatives include JPA repositories (@Repository), Spring Data repositories, and ORM frameworks. The pattern promotes maintainable code by isolating data access concerns and enabling easy database migration or testing with different data sources."
  },
  {
    "question": "What is the Front Controller pattern?",
    "answer": "Front Controller pattern provides a centralized entry point for handling all requests in a web application. A single controller handles all incoming requests, performs common processing, and dispatches to appropriate handlers. Components include: 1) Front Controller - single entry point handling all requests, 2) Dispatcher - routes requests to specific handlers, 3) View Manager - manages view selection and rendering, 4) Context - maintains request state. Benefits include: centralized control, consistent request handling, easier implementation of cross-cutting concerns (authentication, logging), and improved security. Java implementations include Spring DispatcherServlet, Struts ActionServlet, and servlet filters. Example: all requests go through DispatcherServlet which routes to appropriate controllers based on URL patterns. The pattern simplifies web application architecture and promotes consistent request processing."
  },
  {
    "question": "What is the difference between composition and inheritance?",
    "answer": "Composition and inheritance are two fundamental ways to establish relationships between classes: Inheritance represents 'is-a' relationship where subclass inherits properties and behaviors from superclass, enables code reuse through class hierarchy, supports polymorphism, but creates tight coupling and fragile base class problem. Composition represents 'has-a' relationship where class contains instances of other classes, promotes loose coupling, enables runtime behavior changes, supports multiple inheritance-like behavior, and provides better encapsulation. Example: inheritance - Dog extends Animal, composition - Car has Engine. Benefits of composition: easier testing, more flexible, avoids inheritance limitations. Favor composition over inheritance principle suggests using composition when possible, as it leads to more maintainable and flexible designs. Both have their place, but composition often provides better long-term maintainability."
  },
  {
    "question": "What is the Law of Demeter (Principle of Least Knowledge)?",
    "answer": "The Law of Demeter states that an object should only communicate with its immediate friends and not with strangers. Specifically, a method should only call methods on: 1) itself (this), 2) objects passed as parameters, 3) objects it creates locally, 4) direct component objects (instance variables). Violations look like: object.getX().getY().getZ().doSomething() (train wreck). Benefits of following this law: reduced coupling, improved maintainability, easier testing, and less fragile code. Solutions include: creating facade methods, using delegation, dependency injection, and proper encapsulation. Example: instead of customer.getWallet().getMoney(), use customer.pay(amount) which internally handles wallet operations. The principle promotes loose coupling and prevents classes from knowing too much about internal structure of other classes."
  },
  {
    "question": "What is SOLID principles in object-oriented design?",
    "answer": "SOLID is an acronym for five design principles: 1) Single Responsibility Principle (SRP) - a class should have only one reason to change, one responsibility, 2) Open/Closed Principle (OCP) - software entities should be open for extension but closed for modification, 3) Liskov Substitution Principle (LSP) - objects of superclass should be replaceable with objects of subclass without breaking functionality, 4) Interface Segregation Principle (ISP) - clients should not be forced to depend on interfaces they don't use, 5) Dependency Inversion Principle (DIP) - depend on abstractions, not concretions. Benefits include: maintainable code, reduced coupling, easier testing, and better design. These principles guide object-oriented design decisions and help create robust, flexible software architectures."
  },
  {
    "question": "What is the difference between tight coupling and loose coupling?",
    "answer": "Coupling refers to the degree of interdependence between software modules: Tight coupling occurs when classes are highly dependent on each other's internal implementation details, making changes in one class require changes in dependent classes. Characteristics include: direct object instantiation, accessing internal state directly, and hard-coded dependencies. Loose coupling occurs when classes interact through well-defined interfaces with minimal knowledge of each other's implementation. Achieved through: dependency injection, interfaces/abstractions, event-driven communication, and proper encapsulation. Benefits of loose coupling: easier testing, better maintainability, reduced change impact, and improved reusability. Examples: tight - class directly creates dependencies, loose - dependencies injected through constructor. Loose coupling is preferred as it leads to more flexible and maintainable systems."
  },
  {
    "question": "What is cohesion in software design and why is it important?",
    "answer": "Cohesion refers to how closely related and focused the elements within a module (class or method) are on a single, well-defined task. Types of cohesion from highest to lowest: 1) Functional - elements contribute to single, well-defined task, 2) Sequential - output of one element is input to next, 3) Communicational - elements operate on same data, 4) Procedural - elements follow specific sequence, 5) Temporal - elements executed at same time, 6) Logical - elements perform similar activities, 7) Coincidental - elements grouped arbitrarily. High cohesion benefits: easier understanding, better maintainability, increased reusability, and improved testability. Aim for functional cohesion where each class has a single, clear responsibility. Example: high cohesion - Calculator class only handles mathematical operations; low cohesion - Calculator class that also handles file I/O and networking."
  },
  {
    "question": "What is the difference between aggregation and composition?",
    "answer": "Aggregation and composition are both forms of association but differ in ownership and lifecycle: Aggregation represents 'has-a' relationship with weak ownership where contained objects can exist independently of the container. Example: Department has Employees - employees can exist without the department. Composition represents 'part-of' relationship with strong ownership where contained objects cannot exist without the container. Example: House has Rooms - rooms cannot exist without the house. Key differences: lifecycle dependency (composition objects are destroyed with container, aggregation objects are not), ownership strength (composition implies strong ownership, aggregation implies weak), and independence (aggregation allows independent existence, composition doesn't). In UML, composition is shown with filled diamond, aggregation with empty diamond. Choose based on real-world relationship between objects."
  },
  {
    "question": "What are design patterns and why are they important?",
    "answer": "Design patterns are reusable solutions to commonly occurring problems in software design. They represent best practices and provide templates for solving design problems. Categories include: 1) Creational patterns - object creation mechanisms (Singleton, Factory, Builder), 2) Structural patterns - object composition (Adapter, Decorator, Facade), 3) Behavioral patterns - object interaction and responsibility (Observer, Strategy, Command). Benefits include: proven solutions to common problems, improved communication among developers, faster development, better code organization, and easier maintenance. Patterns provide vocabulary for discussing design solutions and help avoid reinventing the wheel. However, avoid overusing patterns or forcing them where they don't fit naturally. Understanding patterns helps in making better design decisions and writing more maintainable code."
  },
  {
    "question": "What is the Facade pattern and how does it simplify complex systems?",
    "answer": "The Facade pattern provides a unified, simplified interface to a complex subsystem, hiding its complexity from clients. It involves: 1) Facade class providing simple methods, 2) Complex subsystem classes with detailed functionality, 3) Client interacting only with facade. Benefits include: simplified interface, reduced coupling between client and subsystem, easier subsystem evolution, and improved usability. Example: ComputerFacade with startComputer() method that internally coordinates CPU, Memory, and HardDrive components. The facade doesn't encapsulate subsystem classes but provides convenient access. Java examples include java.net.URL (hides complex networking), javax.faces.context.FacesContext (JSF), and various API wrappers. Use when you need to provide simple interface to complex subsystem, reduce dependencies, or layer subsystems. The pattern promotes loose coupling and makes complex systems more accessible."
  },
  {
    "question": "What is the Proxy pattern and its different types?",
    "answer": "The Proxy pattern provides a placeholder or surrogate that controls access to another object. Types include: 1) Virtual Proxy - delays expensive object creation until needed, 2) Protection Proxy - controls access based on permissions, 3) Remote Proxy - represents object in different address space, 4) Cache Proxy - provides caching functionality. Structure involves: Subject interface, Real Subject implementing actual functionality, and Proxy implementing same interface and controlling access to Real Subject. Benefits include: lazy initialization, access control, caching, and remote access management. Java examples include java.lang.reflect.Proxy for dynamic proxies, RMI stubs for remote objects, and lazy loading in ORM frameworks. Implementation can be static (compile-time) or dynamic (runtime). Use when you need to control access, add functionality transparently, or manage resource-intensive objects efficiently."
  },
  {
    "question": "What is inversion of control (IoC) and how does it relate to dependency injection?",
    "answer": "Inversion of Control (IoC) is a design principle where the control of object creation and dependency management is transferred from the application code to an external framework or container. Traditional approach has objects creating their own dependencies, while IoC has external entity managing dependencies. Benefits include: loose coupling, easier testing, better maintainability, and separation of concerns. Dependency Injection is a specific implementation of IoC where dependencies are 'injected' into objects rather than created by them. Types of DI: constructor injection, setter injection, and interface injection. IoC containers (Spring, Guice) manage object lifecycle and dependency resolution. Example: instead of UserService creating UserRepository, container injects UserRepository into UserService. This promotes testable, flexible code by removing hard-coded dependencies and enabling easy substitution of implementations."
  },
  {
    "question": "What is the difference between FileInputStream and FileOutputStream in Java?",
    "answer": "FileInputStream is used for reading binary data from files, working with bytes and providing methods like read() to retrieve data from a file. FileOutputStream is used for writing binary data to files, providing methods like write() to store data in a file. FileInputStream reads data sequentially from the beginning of a file, while FileOutputStream can write data to a file, either appending to existing content or overwriting it. Both classes work with raw bytes and are suitable for handling binary files like images, videos, or any non-text files. They are part of the java.io package and implement the InputStream and OutputStream interfaces respectively."
  },
  {
    "question": "What is the difference between FileReader and FileWriter in Java?",
    "answer": "FileReader and FileWriter are character-based I/O classes designed specifically for reading and writing text files. FileReader extends InputStreamReader and is used for reading character data from files, automatically handling character encoding conversion from bytes to characters. FileWriter extends OutputStreamWriter and is used for writing character data to files, converting characters to bytes using the default character encoding. Both classes are more suitable for text files compared to FileInputStream/FileOutputStream which work with raw bytes. FileReader provides methods like read() for reading characters, while FileWriter provides write() methods for writing characters and strings to files."
  },
  {
    "question": "How do you read a file line by line in Java?",
    "answer": "There are several ways to read a file line by line in Java: 1) Using BufferedReader with FileReader: BufferedReader br = new BufferedReader(new FileReader(\"file.txt\")); String line; while ((line = br.readLine()) != null) { System.out.println(line); }, 2) Using Files.readAllLines() (Java 7+): List<String> lines = Files.readAllLines(Paths.get(\"file.txt\")); for (String line : lines) { System.out.println(line); }, 3) Using Scanner: Scanner scanner = new Scanner(new File(\"file.txt\")); while (scanner.hasNextLine()) { System.out.println(scanner.nextLine()); }, 4) Using Stream API (Java 8+): Files.lines(Paths.get(\"file.txt\")).forEach(System.out::println). Always use try-with-resources for proper resource management."
  },
  {
    "question": "What is the Scanner class in Java and how is it used?",
    "answer": "Scanner is a utility class in Java that can parse primitive types and strings using regular expressions. It's commonly used for reading input from various sources like keyboard input (System.in), files, or strings. Key features include: 1) Input parsing with methods like nextInt(), nextDouble(), nextLine(), next(), 2) Delimiter customization using useDelimiter(), 3) Pattern matching capabilities, 4) Built-in validation with hasNextInt(), hasNextDouble(), etc. Example usage: Scanner scanner = new Scanner(System.in); System.out.print(\"Enter your name: \"); String name = scanner.nextLine(); Scanner is convenient for simple input operations but BufferedReader is more efficient for reading large amounts of text data."
  },
  {
    "question": "How do you handle file not found exceptions in Java?",
    "answer": "FileNotFoundException is a checked exception that must be handled when working with file operations. Ways to handle it include: 1) Using try-catch blocks: try { FileReader file = new FileReader(\"file.txt\"); } catch (FileNotFoundException e) { System.out.println(\"File not found: \" + e.getMessage()); }, 2) Using throws declaration: public void readFile() throws FileNotFoundException { FileReader file = new FileReader(\"file.txt\"); }, 3) Checking file existence first: File file = new File(\"file.txt\"); if (file.exists()) { FileReader reader = new FileReader(file); } else { System.out.println(\"File does not exist\"); }, 4) Using try-with-resources for automatic resource management: try (FileReader file = new FileReader(\"file.txt\")) { // file operations } catch (FileNotFoundException e) { // handle exception }."
  },
  {
    "question": "What is the RandomAccessFile class in Java?",
    "answer": "RandomAccessFile allows both reading and writing to a file at any position, unlike sequential file access provided by other I/O classes. Key features include: 1) Random access using seek() method to position the file pointer, 2) Both reading and writing capabilities in a single class, 3) Methods like readInt(), writeInt(), readLine(), writeBytes(), 4) getFilePointer() to get current position and length() to get file size, 5) Modes: \"r\" (read-only), \"rw\" (read-write), \"rws\" (read-write with synchronous metadata updates), \"rwd\" (read-write with synchronous data updates). Example: RandomAccessFile file = new RandomAccessFile(\"data.txt\", \"rw\"); file.seek(100); file.writeBytes(\"Hello\"); file.seek(0); String data = file.readLine(); It's useful for database-like operations where you need to access specific parts of large files efficiently."
  },
  {
    "question": "How do you copy files in Java?",
    "answer": "There are several ways to copy files in Java: 1) Using Files.copy() (Java 7+): Files.copy(Paths.get(\"source.txt\"), Paths.get(\"destination.txt\"), StandardCopyOption.REPLACE_EXISTING); 2) Using FileInputStream and FileOutputStream: try (FileInputStream fis = new FileInputStream(\"source.txt\"); FileOutputStream fos = new FileOutputStream(\"dest.txt\")) { byte[] buffer = new byte[1024]; int length; while ((length = fis.read(buffer)) > 0) { fos.write(buffer, 0, length); } }, 3) Using FileChannel: try (FileChannel sourceChannel = new FileInputStream(\"source.txt\").getChannel(); FileChannel destChannel = new FileOutputStream(\"dest.txt\").getChannel()) { destChannel.transferFrom(sourceChannel, 0, sourceChannel.size()); }, 4) Using Apache Commons IO: FileUtils.copyFile(new File(\"source.txt\"), new File(\"dest.txt\")). Files.copy() is generally the most convenient and efficient approach."
  },
  {
    "question": "What is the difference between absolute and relative paths in Java?",
    "answer": "Absolute paths specify the complete location of a file or directory from the root of the file system, while relative paths are specified relative to the current working directory. Absolute paths start with the root directory (/ on Unix/Linux, C:\\ on Windows) and provide the full path: /home/user/documents/file.txt or C:\\Users\\User\\Documents\\file.txt. Relative paths don't start with the root and are relative to the current directory: documents/file.txt or ../parent/file.txt. In Java: File absoluteFile = new File(\"/home/user/file.txt\"); File relativeFile = new File(\"file.txt\"); You can convert between them using getAbsolutePath() and getCanonicalPath() methods. Relative paths are more portable across different systems but absolute paths provide exact locations regardless of the current working directory."
  },
  {
    "question": "How do you create directories in Java?",
    "answer": "Java provides several methods to create directories: 1) Using File.mkdir(): File dir = new File(\"newDirectory\"); boolean created = dir.mkdir(); // creates single directory, 2) Using File.mkdirs(): File dirs = new File(\"parent/child/grandchild\"); boolean created = dirs.mkdirs(); // creates entire directory hierarchy, 3) Using Files.createDirectory() (Java 7+): Path dir = Files.createDirectory(Paths.get(\"newDirectory\")); // throws exception if parent doesn't exist, 4) Using Files.createDirectories() (Java 7+): Path dirs = Files.createDirectories(Paths.get(\"parent/child/grandchild\")); // creates entire hierarchy. The mkdir() returns false if directory already exists or creation fails, while Files methods throw exceptions. Always check return values or handle exceptions appropriately. Use mkdirs() or createDirectories() when you need to create nested directory structures."
  },
  {
    "question": "How do you delete files and directories in Java?",
    "answer": "Java provides several methods to delete files and directories: 1) Using File.delete(): File file = new File(\"file.txt\"); boolean deleted = file.delete(); // returns false if deletion fails, 2) Using File.deleteOnExit(): file.deleteOnExit(); // deletes when JVM exits, 3) Using Files.delete() (Java 7+): Files.delete(Paths.get(\"file.txt\")); // throws exception if file doesn't exist, 4) Using Files.deleteIfExists() (Java 7+): boolean deleted = Files.deleteIfExists(Paths.get(\"file.txt\")); // returns false if file doesn't exist. For directories, they must be empty before deletion. To delete non-empty directories, you need to recursively delete contents first: Files.walk(Paths.get(\"directory\")).sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete); Files.delete() methods provide better error reporting through exceptions compared to File.delete() which only returns boolean."
  },
  {
    "question": "What is the difference between text and binary files in Java I/O?",
    "answer": "Text files contain human-readable characters and are processed using character-based I/O classes (Reader/Writer), while binary files contain raw bytes and are processed using byte-based I/O classes (InputStream/OutputStream). Text files: use FileReader/FileWriter, BufferedReader/BufferedWriter, handle character encoding automatically, suitable for .txt, .csv, .xml files. Binary files: use FileInputStream/FileOutputStream, BufferedInputStream/BufferedOutputStream, work with raw bytes, suitable for images, videos, executables, serialized objects. Key differences: 1) Text files are platform-dependent due to line ending differences (\\n, \\r\\n), binary files are platform-independent, 2) Text files can be opened in text editors, binary files require specific applications, 3) Text I/O handles character encoding/decoding, binary I/O works with raw data, 4) Text files may have encoding-related issues, binary files preserve exact byte sequences."
  },
  {
    "question": "How do you check if a file exists in Java?",
    "answer": "There are several ways to check if a file exists in Java: 1) Using File.exists(): File file = new File(\"file.txt\"); if (file.exists()) { System.out.println(\"File exists\"); }, 2) Using Files.exists() (Java 7+): if (Files.exists(Paths.get(\"file.txt\"))) { System.out.println(\"File exists\"); }, 3) Additional File methods: file.isFile() (checks if it's a file), file.isDirectory() (checks if it's a directory), file.canRead()/canWrite() (checks permissions), 4) Files class methods: Files.isRegularFile(), Files.isDirectory(), Files.isReadable(), Files.isWritable(). Files.exists() is generally preferred as it provides better performance and more detailed options: Files.exists(path, LinkOption.NOFOLLOW_LINKS) to not follow symbolic links. You can also check file properties like size: file.length() or Files.size(path), and last modified time: file.lastModified() or Files.getLastModifiedTime(path)."
  },
  {
    "question": "What is buffered I/O and why is it important?",
    "answer": "Buffered I/O uses an internal buffer to reduce the number of system calls by reading/writing data in chunks rather than one byte/character at a time. This significantly improves performance, especially for small, frequent I/O operations. BufferedInputStream/BufferedOutputStream for byte streams and BufferedReader/BufferedWriter for character streams provide buffering capabilities. Benefits include: 1) Reduced system calls - instead of many small I/O operations, fewer large operations are performed, 2) Better performance - buffering can be 10-100 times faster than unbuffered I/O, 3) Efficient use of system resources. Example: BufferedReader br = new BufferedReader(new FileReader(\"file.txt\")); BufferedWriter bw = new BufferedWriter(new FileWriter(\"output.txt\")); Default buffer size is typically 8192 bytes/characters, but can be customized: new BufferedReader(reader, 16384). Always flush() BufferedWriter to ensure data is written, or use try-with-resources for automatic flushing and closing."
  },
  {
    "question": "How do you handle different character encodings in Java I/O?",
    "answer": "Character encoding determines how characters are converted to bytes and vice versa. Java provides several ways to handle different encodings: 1) Using InputStreamReader/OutputStreamWriter with specific charset: FileInputStream fis = new FileInputStream(\"file.txt\"); InputStreamReader isr = new InputStreamReader(fis, \"UTF-8\"); BufferedReader br = new BufferedReader(isr); 2) Using Files methods with Charset (Java 7+): List<String> lines = Files.readAllLines(Paths.get(\"file.txt\"), StandardCharsets.UTF_8); Files.write(Paths.get(\"output.txt\"), data.getBytes(StandardCharsets.UTF_8)); 3) Common encodings: UTF-8 (most common), UTF-16, ISO-8859-1, ASCII. Always specify encoding explicitly to avoid platform-dependent behavior. Default encoding varies by system and can cause issues when moving applications between environments. Use StandardCharsets constants instead of string literals for better type safety and performance."
  },
  {
    "question": "What is the File class in Java and what are its main methods?",
    "answer": "The File class represents file and directory pathnames in a system-independent way. It provides methods to interact with the file system without actually reading or writing file contents. Key methods include: 1) File information: exists(), isFile(), isDirectory(), canRead(), canWrite(), canExecute(), length(), lastModified(), 2) File operations: createNewFile(), delete(), deleteOnExit(), renameTo(), 3) Directory operations: mkdir(), mkdirs(), list(), listFiles(), 4) Path methods: getName(), getParent(), getAbsolutePath(), getCanonicalPath(), 5) File system methods: listRoots(), getFreeSpace(), getTotalSpace(). Example: File file = new File(\"document.txt\"); if (file.exists() && file.isFile()) { System.out.println(\"Size: \" + file.length() + \" bytes\"); String[] files = new File(\".\").list(); // list current directory }. Note: File class doesn't perform actual I/O operations, it only provides file system metadata and operations."
  },
  {
    "question": "What is JDBC and how does it work in Java?",
    "answer": "JDBC (Java Database Connectivity) is a Java API that provides a standard way to interact with relational databases. It allows Java applications to execute SQL statements and retrieve results from databases in a database-independent manner. JDBC architecture includes: 1) JDBC API - interfaces and classes in java.sql package, 2) JDBC Driver Manager - manages database drivers, 3) JDBC Drivers - database-specific implementations. Basic JDBC workflow: 1) Load driver: Class.forName(\"com.mysql.cj.jdbc.Driver\"), 2) Establish connection: Connection conn = DriverManager.getConnection(url, username, password), 3) Create statement: Statement stmt = conn.createStatement() or PreparedStatement pstmt = conn.prepareStatement(sql), 4) Execute query: ResultSet rs = stmt.executeQuery(\"SELECT * FROM users\"), 5) Process results: while(rs.next()) { String name = rs.getString(\"name\"); }, 6) Close resources: rs.close(), stmt.close(), conn.close(). Modern applications use connection pooling and frameworks like Hibernate or MyBatis for easier database operations."
  },
  {
    "question": "What are the different types of JDBC drivers?",
    "answer": "JDBC drivers are categorized into four types based on their implementation: 1) Type 1 (JDBC-ODBC Bridge): Uses ODBC driver to connect to database, requires ODBC driver installation, platform-dependent, deprecated since Java 8, 2) Type 2 (Native API Driver): Partly written in Java and partly in native code, uses database vendor's native client libraries, better performance than Type 1 but still platform-dependent, 3) Type 3 (Network Protocol Driver): Pure Java driver that communicates with middleware server, which then connects to database, provides database independence, good for web applications, 4) Type 4 (Thin Driver): Pure Java driver that communicates directly with database using vendor-specific network protocol, most popular type, platform-independent, best performance, no additional installation required. Examples: MySQL Connector/J (Type 4), Oracle OCI driver (Type 2), PostgreSQL JDBC driver (Type 4). Type 4 drivers are preferred for most applications due to their pure Java implementation and direct database communication."
  },
  {
    "question": "What is the difference between Statement and PreparedStatement in JDBC?",
    "answer": "Statement and PreparedStatement are used to execute SQL queries, but PreparedStatement offers significant advantages: Statement: 1) SQL query is compiled each time it's executed, 2) Vulnerable to SQL injection attacks, 3) Cannot handle parameters efficiently, 4) Suitable for static queries that don't change. PreparedStatement: 1) SQL query is pre-compiled, improving performance for repeated executions, 2) Protects against SQL injection through parameterized queries, 3) Supports input parameters using placeholders (?), 4) Better for dynamic queries with user input. Example comparison: Statement: stmt.executeQuery(\"SELECT * FROM users WHERE id = \" + userId); // SQL injection risk. PreparedStatement: PreparedStatement pstmt = conn.prepareStatement(\"SELECT * FROM users WHERE id = ?\"); pstmt.setInt(1, userId); ResultSet rs = pstmt.executeQuery(); // Safe from SQL injection. PreparedStatement is generally preferred for security, performance, and maintainability reasons, especially when dealing with user input or repeated query execution."
  },
  {
    "question": "How do you handle transactions in JDBC?",
    "answer": "JDBC transactions ensure that a group of SQL operations either all succeed or all fail, maintaining data consistency. Transaction management involves: 1) Disable auto-commit: conn.setAutoCommit(false), 2) Execute multiple SQL operations, 3) Commit on success: conn.commit(), 4) Rollback on failure: conn.rollback(), 5) Restore auto-commit: conn.setAutoCommit(true). Example: try { conn.setAutoCommit(false); PreparedStatement stmt1 = conn.prepareStatement(\"UPDATE account SET balance = balance - ? WHERE id = ?\"); stmt1.setDouble(1, amount); stmt1.setInt(2, fromAccount); stmt1.executeUpdate(); PreparedStatement stmt2 = conn.prepareStatement(\"UPDATE account SET balance = balance + ? WHERE id = ?\"); stmt2.setDouble(1, amount); stmt2.setInt(2, toAccount); stmt2.executeUpdate(); conn.commit(); } catch (SQLException e) { conn.rollback(); throw e; } finally { conn.setAutoCommit(true); }. Transactions provide ACID properties: Atomicity, Consistency, Isolation, Durability. Use try-with-resources for automatic resource management."
  },
  {
    "question": "What is a ResultSet in JDBC and how do you navigate through it?",
    "answer": "ResultSet is an interface that represents the result of a database query, providing access to data row by row. It maintains a cursor that points to the current row. Navigation methods include: 1) next() - moves to next row, returns false when no more rows, 2) previous() - moves to previous row (scrollable ResultSet only), 3) first() - moves to first row, 4) last() - moves to last row, 5) absolute(int row) - moves to specific row number, 6) relative(int rows) - moves relative to current position. Data retrieval methods: getString(columnName), getInt(columnIndex), getDate(\"date_column\"), etc. Example: ResultSet rs = stmt.executeQuery(\"SELECT id, name, email FROM users\"); while (rs.next()) { int id = rs.getInt(\"id\"); String name = rs.getString(\"name\"); String email = rs.getString(3); // by column index System.out.println(id + \": \" + name + \" - \" + email); }. ResultSet types: TYPE_FORWARD_ONLY (default), TYPE_SCROLL_INSENSITIVE, TYPE_SCROLL_SENSITIVE determine navigation capabilities."
  },
  {
    "question": "How do you handle database metadata in JDBC?",
    "answer": "Database metadata provides information about the database structure, capabilities, and content. JDBC offers two types: 1) DatabaseMetaData - information about database itself: DatabaseMetaData dbmd = conn.getMetaData(); System.out.println(\"Database: \" + dbmd.getDatabaseProductName()); System.out.println(\"Version: \" + dbmd.getDatabaseProductVersion()); System.out.println(\"Driver: \" + dbmd.getDriverName()); ResultSet tables = dbmd.getTables(null, null, \"%\", new String[]{\"TABLE\"}); 2) ResultSetMetaData - information about ResultSet structure: ResultSet rs = stmt.executeQuery(\"SELECT * FROM users\"); ResultSetMetaData rsmd = rs.getMetaData(); int columnCount = rsmd.getColumnCount(); for (int i = 1; i <= columnCount; i++) { System.out.println(\"Column \" + i + \": \" + rsmd.getColumnName(i) + \" (\" + rsmd.getColumnTypeName(i) + \")\"); }. Metadata is useful for creating generic database tools, generating reports, or building dynamic queries based on database structure."
  },
  {
    "question": "What is connection pooling in JDBC and why is it important?",
    "answer": "Connection pooling is a technique that maintains a cache of database connections that can be reused across multiple requests, rather than creating and closing connections for each database operation. Benefits include: 1) Improved performance - eliminates overhead of creating/destroying connections, 2) Better resource utilization - controls number of concurrent connections, 3) Scalability - handles high-load scenarios efficiently, 4) Connection management - handles connection timeouts and recovery. Popular connection pooling libraries: HikariCP (fastest), DBCP, C3P0, Tomcat JDBC Pool. Example with HikariCP: HikariConfig config = new HikariConfig(); config.setJdbcUrl(\"jdbc:mysql://localhost:3306/mydb\"); config.setUsername(\"user\"); config.setPassword(\"password\"); config.setMaximumPoolSize(20); HikariDataSource dataSource = new HikariDataSource(config); Connection conn = dataSource.getConnection(); // use connection conn.close(); // returns to pool, doesn't actually close. Connection pooling is essential for production applications as it significantly improves performance and resource management in multi-user environments."
  },
  {
    "question": "How do you handle SQL exceptions in JDBC?",
    "answer": "SQL exceptions in JDBC are handled through the SQLException class and its subclasses. Exception handling strategies include: 1) Basic try-catch: try { Connection conn = DriverManager.getConnection(url, user, pass); // database operations } catch (SQLException e) { System.err.println(\"SQL Error: \" + e.getMessage()); System.err.println(\"SQL State: \" + e.getSQLState()); System.err.println(\"Error Code: \" + e.getErrorCode()); }, 2) Specific exception types: SQLIntegrityConstraintViolationException, SQLTimeoutException, SQLTransientException, SQLNonTransientException, 3) Exception chaining: SQLException ex = ...; while (ex != null) { System.out.println(\"Exception: \" + ex.getMessage()); ex = ex.getNextException(); }, 4) Resource cleanup in finally or try-with-resources: try (Connection conn = DriverManager.getConnection(...); PreparedStatement stmt = conn.prepareStatement(...)) { // operations } catch (SQLException e) { // handle exception } // resources auto-closed. Always log exceptions appropriately, handle specific error cases (connection timeout, constraint violations), and ensure proper resource cleanup to prevent connection leaks."
  },
  {
    "question": "What is batch processing in JDBC?",
    "answer": "JDBC batch processing allows executing multiple SQL statements as a single batch, improving performance when performing multiple similar operations. Benefits include reduced network round trips, better database performance, and transactional consistency. Two types: 1) Statement batching: Statement stmt = conn.createStatement(); stmt.addBatch(\"INSERT INTO users VALUES (1, 'John')\"); stmt.addBatch(\"INSERT INTO users VALUES (2, 'Jane')\"); stmt.addBatch(\"UPDATE users SET name='Updated' WHERE id=1\"); int[] results = stmt.executeBatch(); 2) PreparedStatement batching (preferred): PreparedStatement pstmt = conn.prepareStatement(\"INSERT INTO users VALUES (?, ?)\"); for (User user : users) { pstmt.setInt(1, user.getId()); pstmt.setString(2, user.getName()); pstmt.addBatch(); } int[] results = pstmt.executeBatch(); Best practices: disable auto-commit for better performance, handle BatchUpdateException for partial failures, use appropriate batch size (typically 100-1000 statements), and commit after successful batch execution. Batch processing can be 10-100 times faster than individual statement execution for bulk operations."
  },
  {
    "question": "What are callable statements in JDBC?",
    "answer": "CallableStatement is used to execute stored procedures and functions in the database. It extends PreparedStatement and provides additional methods for handling output parameters and return values. Usage: 1) Simple stored procedure: CallableStatement cstmt = conn.prepareCall(\"{call getUserById(?)}\"); cstmt.setInt(1, userId); ResultSet rs = cstmt.executeQuery(); 2) Procedure with output parameters: CallableStatement cstmt = conn.prepareCall(\"{call getUserCount(?)}\"); cstmt.registerOutParameter(1, Types.INTEGER); cstmt.execute(); int count = cstmt.getInt(1); 3) Function calls: CallableStatement cstmt = conn.prepareCall(\"{? = call calculateBonus(?, ?)}\"); cstmt.registerOutParameter(1, Types.DECIMAL); cstmt.setInt(2, employeeId); cstmt.setDecimal(3, salary); cstmt.execute(); BigDecimal bonus = cstmt.getBigDecimal(1); CallableStatement supports IN, OUT, and INOUT parameters, enabling complex database operations. It's useful for encapsulating business logic in the database, improving performance through reduced network traffic, and leveraging database-specific optimizations."
  },
  {
    "question": "What is a servlet in Java and how does it work?",
    "answer": "A servlet is a Java class that extends the functionality of a web server by handling HTTP requests and generating responses. Servlets run on the server side and are managed by a servlet container (like Tomcat). Key characteristics: 1) Extends HttpServlet class, 2) Overrides doGet(), doPost(), doPut(), doDelete() methods, 3) Handles HTTP requests and responses, 4) Maintains state between requests using sessions. Servlet lifecycle: 1) Loading and instantiation by container, 2) Initialization via init() method, 3) Request handling through service() method, 4) Destruction via destroy() method. Example: @WebServlet(\"/hello\") public class HelloServlet extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\"text/html\"); PrintWriter out = response.getWriter(); out.println(\"<h1>Hello World!</h1>\"); } }. Servlets provide platform independence, performance advantages over CGI, access to Java APIs, and integration with other Java EE technologies. They form the foundation for Java web applications and frameworks like Spring MVC."
  },
  {
    "question": "What is the difference between doGet() and doPost() methods in servlets?",
    "answer": "doGet() and doPost() are HTTP method handlers in servlets that serve different purposes: doGet(): 1) Handles HTTP GET requests, 2) Used for retrieving data from server, 3) Parameters visible in URL query string, 4) Limited data size (URL length restrictions), 5) Can be bookmarked and cached, 6) Idempotent operation (safe to repeat), 7) Used for search, navigation, data retrieval. doPost(): 1) Handles HTTP POST requests, 2) Used for sending data to server, 3) Parameters sent in request body (not visible in URL), 4) No size limitations for data, 5) Cannot be bookmarked, not cached by default, 6) Non-idempotent (may have side effects), 7) Used for form submissions, file uploads, data creation/modification. Example: protected void doGet(HttpServletRequest request, HttpServletResponse response) { String name = request.getParameter(\"name\"); // from URL ?name=value } protected void doPost(HttpServletRequest request, HttpServletResponse response) { String formData = request.getParameter(\"data\"); // from form body }. Choose GET for data retrieval and POST for data modification operations following REST principles."
  },
  {
    "question": "What is the servlet lifecycle in Java?",
    "answer": "The servlet lifecycle defines how a servlet is created, initialized, used, and destroyed by the servlet container. Lifecycle phases: 1) Loading: Container loads servlet class when first requested or at startup, 2) Instantiation: Container creates single instance of servlet (singleton pattern), 3) Initialization: init() method called once to initialize servlet, perform one-time setup like database connections, loading configuration, 4) Request Handling: service() method called for each request, which delegates to appropriate doXxx() methods (doGet, doPost, etc.), multiple threads may execute concurrently, 5) Destruction: destroy() method called when container shuts down or redeploys, used for cleanup operations. Example: public class MyServlet extends HttpServlet { public void init() throws ServletException { // One-time initialization System.out.println(\"Servlet initialized\"); } protected void service(HttpServletRequest req, HttpServletResponse resp) { // Handle each request } public void destroy() { // Cleanup resources System.out.println(\"Servlet destroyed\"); } }. The servlet instance is shared among all requests, so instance variables must be thread-safe."
  },
  {
    "question": "How do you handle sessions in Java servlets?",
    "answer": "HTTP sessions provide a way to maintain user state across multiple requests since HTTP is stateless. Session management in servlets: 1) Getting session: HttpSession session = request.getSession(); // creates if doesn't exist HttpSession session = request.getSession(false); // returns null if doesn't exist, 2) Storing data: session.setAttribute(\"username\", \"john\"); session.setAttribute(\"cart\", shoppingCart); 3) Retrieving data: String username = (String) session.getAttribute(\"username\"); ShoppingCart cart = (ShoppingCart) session.getAttribute(\"cart\"); 4) Session management: session.invalidate(); // destroy session session.setMaxInactiveInterval(1800); // 30 minutes timeout String sessionId = session.getId(); boolean isNew = session.isNew(); Session tracking mechanisms: 1) Cookies (default and most common), 2) URL rewriting as fallback, 3) SSL session tracking. Example: HttpSession session = request.getSession(); Integer visitCount = (Integer) session.getAttribute(\"visitCount\"); if (visitCount == null) visitCount = 0; session.setAttribute(\"visitCount\", ++visitCount); Sessions are essential for user authentication, shopping carts, and maintaining user preferences across requests."
  },
  {
    "question": "What is JSP (JavaServer Pages) and how does it differ from servlets?",
    "answer": "JSP (JavaServer Pages) is a technology for creating dynamic web pages using HTML mixed with Java code. JSP pages are compiled into servlets by the container, but provide a more convenient way to create web content. Key differences: JSP: 1) HTML-centric with embedded Java code, 2) Better for presentation layer, 3) Easier for web designers to work with, 4) Scriptlets (<% %>), expressions (<%= %>), declarations (<%! %>), 5) Built-in objects like request, response, session, 6) Custom tags and JSTL support. Servlets: 1) Java-centric with HTML generated in code, 2) Better for business logic, 3) More programmatic control, 4) Pure Java classes, 5) Manual handling of HTTP objects, 6) More verbose for generating HTML. Example JSP: <html><body><h1>Welcome <%= request.getParameter(\"name\") %>!</h1><p>Visit count: ${sessionScope.visitCount}</p></body></html>. Modern practice uses MVC pattern: servlets handle business logic (Controller), JSP handles presentation (View), and JavaBeans/POJOs represent data (Model). JSP is compiled to servlet code, so performance is similar after initial compilation."
  },
  {
    "question": "What are JSP implicit objects?",
    "answer": "JSP implicit objects are pre-defined objects available in JSP pages without explicit declaration. These objects provide access to servlet API functionality: 1) request (HttpServletRequest) - access request parameters, headers, attributes: <%= request.getParameter(\"name\") %>, 2) response (HttpServletResponse) - control response headers, redirects: <% response.setContentType(\"text/html\"); %>, 3) session (HttpSession) - manage user sessions: <%= session.getAttribute(\"user\") %>, 4) application (ServletContext) - application-wide data: <%= application.getInitParameter(\"dbUrl\") %>, 5) out (JspWriter) - write content to response: <% out.println(\"Hello\"); %>, 6) config (ServletConfig) - servlet configuration: <%= config.getInitParameter(\"param\") %>, 7) pageContext (PageContext) - access all scopes and objects: <% pageContext.setAttribute(\"data\", value); %>, 8) page (Object) - reference to current servlet instance: <% if (page instanceof HttpServlet) %>, 9) exception (Throwable) - available only in error pages: <%= exception.getMessage() %>. These objects enable JSP pages to interact with the web container and access HTTP functionality without explicit object creation or casting."
  },
  {
    "question": "What are JSTL (JSP Standard Tag Library) and custom tags?",
    "answer": "JSTL provides standard tags for common JSP operations, reducing the need for scriptlets and improving code maintainability. JSTL tag libraries: 1) Core tags (c:) - iteration, conditionals, URL handling: <c:forEach var=\"item\" items=\"${list}\"><c:out value=\"${item}\"/></c:forEach>, <c:if test=\"${user != null}\">Welcome ${user.name}</c:if>, 2) Formatting tags (fmt:) - internationalization, number/date formatting: <fmt:formatDate value=\"${date}\" pattern=\"yyyy-MM-dd\"/>, 3) SQL tags (sql:) - database operations (rarely used in modern apps), 4) XML tags (x:) - XML processing, 5) Functions (fn:) - string manipulation: ${fn:length(list)}. Custom tags extend JSP functionality by creating reusable components. Creating custom tags: 1) Tag handler class: public class MyTag extends SimpleTagSupport { public void doTag() throws JspException, IOException { getJspContext().getOut().write(\"Custom content\"); } }, 2) Tag Library Descriptor (TLD): <tag><name>myTag</name><tag-class>com.example.MyTag</tag-class></tag>, 3) Usage: <my:myTag/>. JSTL and custom tags promote separation of presentation and logic, improve code reusability, and make JSP pages more maintainable."
  },
  {
    "question": "What is the Model-View-Controller (MVC) pattern in Java web development?",
    "answer": "MVC is an architectural pattern that separates application logic into three interconnected components, promoting organized and maintainable code. In Java web development: Model: 1) Represents data and business logic, 2) JavaBeans, POJOs, Entity classes, 3) Database operations, validation, business rules, 4) Independent of presentation layer. View: 1) Handles presentation layer, 2) JSP pages, HTML, templates, 3) Displays data from Model, 4) User interface components. Controller: 1) Handles user input and coordinates between Model and View, 2) Servlets, Action classes, 3) Request processing, navigation logic, 4) Updates Model and forwards to appropriate View. MVC workflow: 1) User request goes to Controller (servlet), 2) Controller processes request, interacts with Model, 3) Controller forwards request to appropriate View (JSP), 4) View renders response using Model data, 5) Response sent back to user. Benefits: separation of concerns, code reusability, easier testing, maintainability, parallel development. Example: Servlet (Controller) processes form, calls business logic (Model), forwards to JSP (View) for display. Modern frameworks like Spring MVC implement this pattern with additional features and annotations."
  },
  {
    "question": "What are filters in Java servlets?",
    "answer": "Servlet filters are Java components that intercept requests and responses between client and servlet, allowing preprocessing and postprocessing. Filters implement the Filter interface and provide cross-cutting functionality. Filter lifecycle: 1) init() - called once when filter is instantiated, 2) doFilter() - called for each request matching filter mapping, 3) destroy() - called when filter is removed. Common use cases: 1) Authentication and authorization, 2) Logging and auditing, 3) Input validation and sanitization, 4) Compression and encoding, 5) CORS handling, 6) Caching. Example: @WebFilter(\"/*\") public class AuthenticationFilter implements Filter { public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) request; HttpSession session = req.getSession(false); if (session == null || session.getAttribute(\"user\") == null) { ((HttpServletResponse) response).sendRedirect(\"/login\"); return; } chain.doFilter(request, response); // continue to next filter/servlet } }. Filter chain allows multiple filters to process requests in order. Filters are configured via annotations or web.xml with URL patterns. They provide a clean way to implement cross-cutting concerns without modifying servlet code."
  },
  {
    "question": "What is the difference between forward and redirect in servlets?",
    "answer": "Forward and redirect are two ways to transfer control from one servlet to another resource, but they work differently: Forward (server-side): 1) Happens entirely on server side, 2) Same request/response objects used, 3) URL doesn't change in browser, 4) Faster (no additional HTTP round trip), 5) Request attributes preserved, 6) Client unaware of transfer. Usage: RequestDispatcher dispatcher = request.getRequestDispatcher(\"/target.jsp\"); dispatcher.forward(request, response); Redirect (client-side): 1) Server sends redirect response to client, 2) Client makes new request to new URL, 3) URL changes in browser address bar, 4) Slower (requires additional HTTP round trip), 5) Request attributes lost (new request), 6) Client aware of redirect. Usage: response.sendRedirect(\"/newpage.jsp\"); When to use: Forward - internal navigation, passing data between servlets/JSPs, error pages, maintaining request context. Redirect - after POST operations (PRG pattern), external URLs, when URL should change, preventing duplicate form submissions. Example: after form submission, redirect to confirmation page to prevent resubmission on browser refresh. Forward is more efficient for internal transfers, redirect is necessary when URL should change or for external resources."
  },
  {
    "question": "How do you handle file uploads in Java servlets?",
    "answer": "File uploads in servlets are handled using multipart/form-data encoding and the Servlet 3.0+ API or third-party libraries. Servlet 3.0+ approach: 1) Enable multipart support: @WebServlet(value=\"/upload\") @MultipartConfig(maxFileSize=1024*1024*5, maxRequestSize=1024*1024*10) public class FileUploadServlet extends HttpServlet { protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Collection<Part> parts = request.getParts(); for (Part part : parts) { if (part.getName().equals(\"file\")) { String fileName = part.getSubmittedFileName(); InputStream fileContent = part.getInputStream(); // Save file part.write(\"/uploads/\" + fileName); } } } }, 2) HTML form: <form method=\"post\" action=\"/upload\" enctype=\"multipart/form-data\"><input type=\"file\" name=\"file\"><input type=\"submit\" value=\"Upload\"></form>. Apache Commons FileUpload (older approach): FileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); List<FileItem> items = upload.parseRequest(request); Best practices: validate file types and sizes, use secure file names, store files outside web root, implement virus scanning, handle multiple files, provide progress feedback for large uploads, use streaming for memory efficiency."
  },
  {
    "question": "What are listeners in Java web applications?",
    "answer": "Listeners are components that respond to specific events in the lifecycle of web application objects (requests, sessions, servlet context). They implement specific listener interfaces and are registered in web.xml or via annotations. Types of listeners: 1) ServletContextListener - application startup/shutdown: @WebListener public class AppContextListener implements ServletContextListener { public void contextInitialized(ServletContextEvent event) { // Initialize resources, database connections System.out.println(\"Application started\"); } public void contextDestroyed(ServletContextEvent event) { // Cleanup resources System.out.println(\"Application stopped\"); } }, 2) HttpSessionListener - session creation/destruction: public class SessionListener implements HttpSessionListener { public void sessionCreated(HttpSessionEvent event) { // Track active sessions } }, 3) ServletRequestListener - request creation/destruction, 4) Attribute listeners - detect attribute changes: ServletContextAttributeListener, HttpSessionAttributeListener, ServletRequestAttributeListener. Common use cases: initialize application resources, track active users, cleanup resources, audit logging, performance monitoring. Listeners provide a clean way to handle application lifecycle events without coupling to specific servlets or JSPs."
  },
  {
    "question": "What is AJAX and how do you handle AJAX requests in Java servlets?",
    "answer": "AJAX (Asynchronous JavaScript and XML) allows web pages to send and receive data asynchronously without refreshing the entire page, creating more responsive user interfaces. Handling AJAX in servlets: 1) Client-side JavaScript: function loadData() { var xhr = new XMLHttpRequest(); xhr.open('GET', '/servlet/data', true); xhr.onreadystatechange = function() { if (xhr.readyState === 4 && xhr.status === 200) { document.getElementById('result').innerHTML = xhr.responseText; } }; xhr.send(); } or using fetch(): fetch('/servlet/data').then(response => response.json()).then(data => console.log(data)); 2) Servlet handling: @WebServlet(\"/data\") public class AjaxServlet extends HttpServlet { protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.setContentType(\"application/json\"); response.setCharacterEncoding(\"UTF-8\"); PrintWriter out = response.getWriter(); out.print(\"{\\\"message\\\":\\\"Hello from servlet\\\"}\"); } }. Best practices: set appropriate content types (JSON, XML, HTML), handle CORS for cross-origin requests, use proper HTTP status codes, implement error handling, validate input data, use libraries like Jackson or Gson for JSON processing. AJAX enables dynamic content updates, form validation, autocomplete features, and single-page applications."
  },
  {
    "question": "What is JSON and how do you work with JSON in Java?",
    "answer": "JSON (JavaScript Object Notation) is a lightweight, text-based data interchange format that's easy for humans to read and write, and easy for machines to parse and generate. JSON is language-independent and widely used in web APIs. Working with JSON in Java: 1) Using Jackson library: // Object to JSON ObjectMapper mapper = new ObjectMapper(); Person person = new Person(\"John\", 30); String json = mapper.writeValueAsString(person); // JSON to Object Person person = mapper.readValue(json, Person.class); 2) Using Gson library: Gson gson = new Gson(); String json = gson.toJson(person); Person person = gson.fromJson(json, Person.class); 3) Using org.json library: JSONObject obj = new JSONObject(); obj.put(\"name\", \"John\"); obj.put(\"age\", 30); String json = obj.toString(); 4) In servlets for AJAX responses: response.setContentType(\"application/json\"); PrintWriter out = response.getWriter(); out.print(\"{\\\"status\\\":\\\"success\\\",\\\"data\\\":\\\"result\\\"}\"); JSON is preferred over XML for web APIs due to its simplicity, smaller size, and native JavaScript support. Modern REST APIs typically use JSON for request/response payloads."
  },
  {
    "question": "What are web services and what types exist in Java?",
    "answer": "Web services are software systems designed to support interoperable machine-to-machine interaction over a network. They provide a standardized way for applications to communicate regardless of platform or programming language. Types of web services in Java: 1) SOAP (Simple Object Access Protocol) Web Services: XML-based, uses WSDL for interface definition, supports complex operations and security (WS-Security), heavyweight protocol, built-in error handling. Java support: JAX-WS API, annotations like @WebService, @WebMethod. Example: @WebService public class CalculatorService { @WebMethod public int add(int a, int b) { return a + b; } } 2) RESTful Web Services: Uses HTTP methods (GET, POST, PUT, DELETE), lightweight JSON/XML format, stateless, resource-based URLs, easier to consume. Java support: JAX-RS API, frameworks like Jersey, Spring Boot. Example: @Path(\"/users\") public class UserResource { @GET @Produces(MediaType.APPLICATION_JSON) public List<User> getUsers() { return userService.getAllUsers(); } }. REST is more popular for modern web APIs due to simplicity and better performance. SOAP is still used in enterprise environments requiring strict contracts and advanced security features."
  },
  {
    "question": "What is RESTful web service and what are REST principles?",
    "answer": "REST (Representational State Transfer) is an architectural style for designing networked applications, particularly web services. RESTful web services follow REST principles to create scalable, maintainable APIs. REST principles: 1) Statelessness - each request contains all information needed, server doesn't store client state between requests, 2) Client-Server Architecture - separation of concerns, client handles UI, server handles data storage, 3) Uniform Interface - consistent way to interact with resources using standard HTTP methods, 4) Resource-Based - everything is a resource identified by URLs, 5) Cacheable - responses should indicate if they can be cached, 6) Layered System - architecture can have multiple layers (proxies, gateways, load balancers). HTTP methods mapping: GET (retrieve), POST (create), PUT (update/replace), DELETE (remove), PATCH (partial update). URL design: /users (collection), /users/123 (specific resource), /users/123/orders (nested resources). Example RESTful API: GET /api/users - get all users, POST /api/users - create user, GET /api/users/123 - get specific user, PUT /api/users/123 - update user, DELETE /api/users/123 - delete user. Benefits: simplicity, scalability, performance, platform independence, easier testing and caching."
  },
  {
    "question": "What are servlets and how do they handle HTTP requests in Java web applications?",
    "answer": "Servlets are Java classes that extend the functionality of web servers by handling HTTP requests and generating responses. They run on the server side and are managed by a servlet container like Tomcat. Key characteristics include: extending HttpServlet class, overriding doGet(), doPost(), doPut(), doDelete() methods for different HTTP methods, maintaining state between requests using sessions, and providing a platform-independent way to build web applications. The servlet lifecycle consists of loading and instantiation, initialization via init(), request handling through service(), and destruction via destroy(). Servlets form the foundation for Java web applications and frameworks."
  },
  {
    "question": "What is the difference between doGet() and doPost() methods in servlets?",
    "answer": "doGet() handles HTTP GET requests used for retrieving data from the server. Parameters are visible in URL query string, have limited data size due to URL length restrictions, can be bookmarked and cached, represent idempotent operations safe to repeat, and are used for search, navigation, and data retrieval. doPost() handles HTTP POST requests used for sending data to the server. Parameters are sent in request body (not visible in URL), have no size limitations, cannot be bookmarked or cached by default, represent non-idempotent operations that may have side effects, and are used for form submissions, file uploads, and data creation/modification. Choose GET for data retrieval and POST for data modification following REST principles."
  },
  {
    "question": "What is the servlet lifecycle and what happens in each phase?",
    "answer": "The servlet lifecycle defines how servlets are created, initialized, used, and destroyed by the servlet container. Phases include: 1) Loading - container loads servlet class when first requested or at startup, 2) Instantiation - container creates single instance using singleton pattern, 3) Initialization - init() method called once to initialize servlet, perform setup like database connections and load configuration, 4) Request Handling - service() method called for each request, delegates to appropriate doXxx() methods with multiple threads executing concurrently, 5) Destruction - destroy() method called when container shuts down or redeploys, used for cleanup operations. The servlet instance is shared among all requests, so instance variables must be thread-safe."
  },
  {
    "question": "How do you handle sessions in Java web applications?",
    "answer": "HTTP sessions maintain user state across multiple requests since HTTP is stateless. Session management involves: 1) Getting session using HttpSession session = request.getSession() (creates if doesn't exist) or request.getSession(false) (returns null if doesn't exist), 2) Storing data with session.setAttribute(\"key\", value), 3) Retrieving data with session.getAttribute(\"key\"), 4) Managing sessions with session.invalidate() to destroy, session.setMaxInactiveInterval() for timeout, session.getId() for unique identifier. Session tracking uses cookies (default), URL rewriting as fallback, or SSL session tracking. Sessions are essential for user authentication, shopping carts, and maintaining user preferences across requests."
  },
  {
    "question": "What is JSP (JavaServer Pages) and how does it differ from servlets?",
    "answer": "JSP is a technology for creating dynamic web pages using HTML mixed with Java code. JSP pages are compiled into servlets but provide more convenient presentation layer development. Key differences: JSP is HTML-centric with embedded Java code using scriptlets (<% %>), expressions (<%= %>), and declarations (<%! %>), has built-in objects like request, response, session, and supports custom tags and JSTL. Servlets are Java-centric with HTML generated in code, provide more programmatic control, are pure Java classes with manual HTTP object handling, and are more verbose for HTML generation. Modern practice uses MVC pattern where servlets handle business logic (Controller), JSP handles presentation (View), and JavaBeans represent data (Model)."
  },
  {
    "question": "What are JSP implicit objects and how are they used?",
    "answer": "JSP implicit objects are pre-defined objects available in JSP pages without explicit declaration, providing access to servlet API functionality: 1) request (HttpServletRequest) - access parameters, headers, attributes, 2) response (HttpServletResponse) - control response headers and redirects, 3) session (HttpSession) - manage user sessions, 4) application (ServletContext) - application-wide data, 5) out (JspWriter) - write content to response, 6) config (ServletConfig) - servlet configuration, 7) pageContext (PageContext) - access all scopes and objects, 8) page (Object) - reference to current servlet instance, 9) exception (Throwable) - available only in error pages. These objects enable JSP pages to interact with web container and access HTTP functionality without explicit object creation."
  },
  {
    "question": "What is JSTL (JSP Standard Tag Library) and how does it improve JSP development?",
    "answer": "JSTL provides standard tags for common JSP operations, reducing scriptlets and improving maintainability. Tag libraries include: 1) Core tags (c:) for iteration, conditionals, URL handling like <c:forEach>, <c:if>, <c:out>, 2) Formatting tags (fmt:) for internationalization and number/date formatting, 3) SQL tags (sql:) for database operations (rarely used in modern apps), 4) XML tags (x:) for XML processing, 5) Functions (fn:) for string manipulation. Custom tags can be created by extending SimpleTagSupport and defining Tag Library Descriptor (TLD). JSTL and custom tags promote separation of presentation and logic, improve code reusability, and make JSP pages more maintainable by eliminating Java code in presentation layer."
  },
  {
    "question": "How does the Model-View-Controller (MVC) pattern work in Java web development?",
    "answer": "MVC separates application logic into three interconnected components for organized, maintainable code. In Java web development: Model represents data and business logic using JavaBeans, POJOs, Entity classes, handles database operations, validation, business rules, and is independent of presentation. View handles presentation layer using JSP pages, HTML, templates, displays data from Model, and manages user interface. Controller handles user input and coordinates between Model and View using servlets or Action classes, processes requests, performs navigation logic, updates Model, and forwards to appropriate View. Workflow: user request goes to Controller → Controller processes request and interacts with Model → Controller forwards to appropriate View → View renders response using Model data → response sent to user."
  },
  {
    "question": "What are filters in Java web applications and how are they used?",
    "answer": "Servlet filters intercept requests and responses between client and servlet, allowing preprocessing and postprocessing. Filters implement Filter interface with lifecycle methods: init() called once when instantiated, doFilter() called for each matching request, destroy() called when removed. Common use cases include authentication and authorization, logging and auditing, input validation and sanitization, compression and encoding, CORS handling, and caching. Filter chain allows multiple filters to process requests in order. Configuration via annotations (@WebFilter) or web.xml with URL patterns. Filters provide clean way to implement cross-cutting concerns without modifying servlet code, enabling separation of concerns and reusable functionality across multiple servlets."
  },
  {
    "question": "What is the difference between forward and redirect in servlets?",
    "answer": "Forward and redirect transfer control differently: Forward (server-side) happens entirely on server, uses same request/response objects, URL doesn't change in browser, is faster (no additional HTTP round trip), preserves request attributes, and client is unaware of transfer. Implementation: RequestDispatcher dispatcher = request.getRequestDispatcher(\"/target\"); dispatcher.forward(request, response). Redirect (client-side) sends redirect response to client, client makes new request to new URL, URL changes in browser, is slower (additional HTTP round trip), request attributes are lost (new request), and client is aware of redirect. Implementation: response.sendRedirect(\"/newpage\"). Use forward for internal navigation, passing data between servlets/JSPs, error pages. Use redirect after POST operations (PRG pattern), external URLs, when URL should change, preventing duplicate form submissions."
  },
  {
    "question": "How do you handle file uploads in Java web applications?",
    "answer": "File uploads use multipart/form-data encoding with Servlet 3.0+ API or third-party libraries. Servlet 3.0+ approach: enable multipart support with @MultipartConfig annotation, use request.getParts() to get file parts, process each part with getSubmittedFileName(), getInputStream(), and write files using part.write(). HTML form requires method=\"post\" and enctype=\"multipart/form-data\". Best practices include validating file types and sizes, using secure file names, storing files outside web root, implementing virus scanning, handling multiple files, providing progress feedback, and using streaming for memory efficiency. Consider using Apache Commons FileUpload for older servlet versions or more advanced features like progress monitoring and temporary file handling."
  },
  {
    "question": "What are listeners in Java web applications and when are they used?",
    "answer": "Listeners respond to specific events in web application object lifecycles (requests, sessions, servlet context). Types include: 1) ServletContextListener for application startup/shutdown - initialize resources, database connections, cleanup on shutdown, 2) HttpSessionListener for session creation/destruction - track active sessions, user analytics, 3) ServletRequestListener for request creation/destruction - request logging, performance monitoring, 4) Attribute listeners for detecting changes - ServletContextAttributeListener, HttpSessionAttributeListener, ServletRequestAttributeListener for audit logging. Registration via @WebListener annotation or web.xml. Common use cases include initializing application resources, tracking active users, cleanup operations, audit logging, and performance monitoring. Listeners provide clean separation of concerns for lifecycle management without coupling to specific servlets or JSPs."
  },
  {
    "question": "What is AJAX and how do you handle AJAX requests in Java servlets?",
    "answer": "AJAX (Asynchronous JavaScript and XML) allows web pages to send/receive data asynchronously without full page refresh, creating responsive user interfaces. Client-side uses XMLHttpRequest or fetch() API to send requests. Server-side servlet handling: set appropriate content type (application/json), process request parameters, return data in JSON/XML format, handle CORS for cross-origin requests, use proper HTTP status codes. Best practices include input validation, error handling, using JSON libraries (Jackson, Gson) for serialization, implementing proper security measures, and providing meaningful error responses. AJAX enables dynamic content updates, form validation, autocomplete features, single-page applications, and improved user experience by eliminating full page reloads."
  },
  {
    "question": "What is JSON and how do you work with it in Java web applications?",
    "answer": "JSON (JavaScript Object Notation) is lightweight, text-based data interchange format that's human-readable and language-independent. Working with JSON in Java: 1) Jackson library for object-to-JSON conversion using ObjectMapper, 2) Gson library for simple JSON operations, 3) org.json library for manual JSON object creation, 4) In servlets, set content type to application/json and write JSON strings to response. JSON is preferred over XML for web APIs due to smaller size, native JavaScript support, and simplicity. Modern REST APIs typically use JSON for request/response payloads. Benefits include reduced bandwidth usage, faster parsing, better readability, and excellent browser support making it ideal for AJAX applications and web services."
  },
  {
    "question": "What are web services and what types exist in Java?",
    "answer": "Web services enable interoperable machine-to-machine communication over networks, providing standardized way for applications to communicate regardless of platform. Types in Java: 1) SOAP Web Services - XML-based, uses WSDL for interface definition, supports complex operations and security (WS-Security), heavyweight protocol with built-in error handling, Java support via JAX-WS API with @WebService annotations, 2) RESTful Web Services - uses HTTP methods (GET, POST, PUT, DELETE), lightweight JSON/XML format, stateless, resource-based URLs, Java support via JAX-RS API and frameworks like Jersey, Spring Boot. REST is more popular for modern APIs due to simplicity and performance. SOAP still used in enterprise environments requiring strict contracts and advanced security. Choice depends on requirements for complexity, security, and interoperability."
  },
  {
    "question": "What is RESTful web service and what are the REST principles?",
    "answer": "REST (Representational State Transfer) is architectural style for designing networked applications, particularly web services. REST principles: 1) Statelessness - each request contains all needed information, server doesn't store client state, 2) Client-Server Architecture - separation of concerns, client handles UI, server handles data, 3) Uniform Interface - consistent interaction using standard HTTP methods, 4) Resource-Based - everything is a resource identified by URLs, 5) Cacheable - responses indicate if they can be cached, 6) Layered System - architecture can have multiple layers (proxies, gateways). HTTP methods mapping: GET (retrieve), POST (create), PUT (update/replace), DELETE (remove), PATCH (partial update). URL design follows /collection and /collection/id patterns. Benefits include simplicity, scalability, performance, platform independence, and easier testing and caching."
  },
  {
    "question": "How do you create RESTful web services using JAX-RS in Java?",
    "answer": "JAX-RS (Java API for RESTful Web Services) uses annotations to define REST endpoints. Key annotations: @Path for URL mapping, @GET/@POST/@PUT/@DELETE for HTTP methods, @Produces/@Consumes for content types, @PathParam for URL parameters, @QueryParam for query parameters. Implementation involves creating resource classes with annotated methods, configuring JAX-RS application, and deploying to servlet container. Example resource class handles CRUD operations with proper HTTP status codes, content negotiation, and exception handling. Popular implementations include Jersey (reference implementation) and RESTEasy. Modern development often uses Spring Boot with Spring MVC for REST services due to simplified configuration, embedded servers, and extensive ecosystem integration."
  },
  {
    "question": "What is Spring Framework and what are its core features?",
    "answer": "Spring Framework is comprehensive Java framework for enterprise application development, promoting loose coupling and testability. Core features: 1) Inversion of Control (IoC) Container - manages object lifecycle and dependencies, 2) Dependency Injection - constructor, setter, and field injection, 3) Aspect-Oriented Programming (AOP) - cross-cutting concerns like logging, security, transactions, 4) Data Access abstraction - JDBC template, ORM integration, transaction management, 5) Web MVC framework - model-view-controller pattern for web applications, 6) Security framework - authentication, authorization, method-level security, 7) Integration support - JMS, JMX, email, scheduling. Benefits include reduced boilerplate code, improved testability, modular architecture, extensive ecosystem, and comprehensive documentation. Spring promotes POJO-based development and convention-over-configuration principles."
  },
  {
    "question": "What is dependency injection in Spring and how does it work?",
    "answer": "Dependency Injection (DI) is core Spring feature where framework manages object dependencies rather than objects creating them manually. Types: 1) Constructor Injection - dependencies passed through constructor (recommended), 2) Setter Injection - dependencies set through setter methods, 3) Field Injection - dependencies injected directly into fields using @Autowired. Spring IoC container manages bean lifecycle, resolves dependencies, and injects them at runtime. Configuration approaches include XML configuration, Java configuration with @Configuration classes, and annotation-based with @Component, @Service, @Repository. Benefits include loose coupling, easier testing with mock objects, better separation of concerns, and improved maintainability. DI enables testable, flexible applications by inverting control of dependency creation to the framework."
  },
  {
    "question": "What are Spring annotations and how do they simplify configuration?",
    "answer": "Spring annotations reduce XML configuration and enable convention-over-configuration approach. Key annotations: 1) @Component, @Service, @Repository, @Controller for automatic bean discovery, 2) @Autowired for dependency injection, 3) @Configuration for Java-based configuration, 4) @Bean for method-level bean definition, 5) @Value for property injection, 6) @Qualifier for disambiguation when multiple beans exist, 7) @Scope for bean scope definition, 8) @PostConstruct/@PreDestroy for lifecycle callbacks. Benefits include reduced boilerplate code, improved readability, type safety, IDE support for refactoring, and faster development. Annotations work with component scanning (@ComponentScan) to automatically discover and register beans, eliminating need for extensive XML configuration files."
  },
  {
    "question": "What is Spring Boot and how does it differ from Spring Framework?",
    "answer": "Spring Boot is opinionated framework built on top of Spring Framework that simplifies application development through auto-configuration and convention-over-configuration. Key differences: Spring Boot provides embedded servers (Tomcat, Jetty), auto-configuration based on classpath, production-ready features (metrics, health checks), starter dependencies for common functionality, and minimal configuration requirements. Spring Framework requires manual configuration, external server deployment, extensive XML/Java configuration, and more setup overhead. Spring Boot benefits include rapid application development, microservices-friendly architecture, standalone JAR deployment, integrated development tools, and reduced boilerplate configuration. Spring Boot maintains all Spring Framework capabilities while adding convenience features for faster development and deployment."
  },
  {
    "question": "What is Spring MVC and how does it implement the MVC pattern?",
    "answer": "Spring MVC is web framework implementing Model-View-Controller pattern for building web applications. Architecture components: 1) DispatcherServlet - front controller handling all requests, 2) HandlerMapping - maps requests to controllers, 3) Controller - handles business logic and returns ModelAndView, 4) ViewResolver - resolves logical view names to actual views, 5) View - renders response (JSP, Thymeleaf, JSON). Request flow: client request → DispatcherServlet → HandlerMapping → Controller → ViewResolver → View → response. Annotations include @Controller for controller classes, @RequestMapping for URL mapping, @RequestParam for parameters, @ModelAttribute for model binding. Benefits include flexible configuration, easy testing, extensive validation support, REST support, and integration with Spring ecosystem."
  },
  {
    "question": "What are Spring Data JPA and how does it simplify database operations?",
    "answer": "Spring Data JPA provides abstraction layer over JPA (Java Persistence API) to simplify data access operations. Key features: 1) Repository pattern with CrudRepository, JpaRepository interfaces providing basic CRUD operations, 2) Query methods derived from method names (findByFirstName, findByAgeGreaterThan), 3) Custom queries using @Query annotation with JPQL or native SQL, 4) Pagination and sorting support, 5) Auditing capabilities with @CreatedDate, @LastModifiedDate, 6) Transaction management integration. Benefits include reduced boilerplate code, type-safe queries, automatic implementation generation, consistent API across different data stores, and integration with Spring transaction management. Spring Data JPA eliminates need to write repetitive DAO implementations while providing powerful querying capabilities and maintaining JPA compatibility."
  },
  {
    "question": "What is Spring Security and what security features does it provide?",
    "answer": "Spring Security is comprehensive security framework providing authentication, authorization, and protection against common attacks. Core features: 1) Authentication - username/password, LDAP, OAuth, JWT token-based, 2) Authorization - URL-based, method-level, expression-based access control, 3) Protection against attacks - CSRF, session fixation, clickjacking, 4) Password encoding with BCrypt, SCrypt, Argon2, 5) Remember-me functionality, 6) Session management and concurrent session control. Configuration approaches include Java configuration with @EnableWebSecurity, annotation-based with @PreAuthorize/@PostAuthorize, and method-level security. Integration with Spring ecosystem provides seamless security implementation. Features like security filters, authentication providers, and access decision managers provide flexible, customizable security architecture for enterprise applications."
  },
  {
    "question": "What is Hibernate and how does it work as an ORM framework?",
    "answer": "Hibernate is Object-Relational Mapping (ORM) framework that maps Java objects to database tables, eliminating need for manual SQL and JDBC code. Core concepts: 1) Entity classes annotated with JPA annotations (@Entity, @Table, @Id), 2) SessionFactory for creating database sessions, 3) Session for performing database operations, 4) HQL (Hibernate Query Language) for object-oriented queries, 5) Criteria API for dynamic query building, 6) Caching mechanisms (first-level, second-level, query cache). Features include automatic table generation, lazy loading, dirty checking, transaction management, and database independence. Benefits include reduced development time, database portability, automatic SQL generation, caching for performance, and object-oriented database operations. Hibernate simplifies data persistence by handling object-relational impedance mismatch."
  },
  {
    "question": "What is the difference between Hibernate and JPA?",
    "answer": "JPA (Java Persistence API) is specification defining standard for ORM in Java, while Hibernate is implementation of JPA specification (along with being standalone ORM framework). Key differences: JPA provides standard annotations (@Entity, @Table, @OneToMany), interfaces (EntityManager, EntityManagerFactory), and JPQL query language. Hibernate implements JPA specification plus additional features like HQL, Criteria API, custom data types, caching strategies, and Hibernate-specific annotations. Using JPA provides vendor independence - can switch between Hibernate, EclipseLink, OpenJPA without code changes. Hibernate-specific features offer more functionality but create vendor lock-in. Modern applications typically use JPA annotations with Hibernate as implementation provider, gaining standards compliance while leveraging Hibernate's mature feature set and performance optimizations."
  },
  {
    "question": "What are the different types of associations in Hibernate/JPA?",
    "answer": "Hibernate/JPA supports four types of associations for mapping relationships between entities: 1) @OneToOne - one entity instance relates to one instance of another entity, can be unidirectional or bidirectional, uses @JoinColumn for foreign key, 2) @OneToMany - one entity relates to multiple instances of another, typically mapped with @JoinColumn or @JoinTable, often bidirectional with @ManyToOne on other side, 3) @ManyToOne - multiple instances relate to one instance of another entity, uses @JoinColumn for foreign key, most common association type, 4) @ManyToMany - multiple instances relate to multiple instances, requires junction table, uses @JoinTable annotation. Each association can be configured for fetch type (LAZY/EAGER), cascade operations, and orphan removal. Understanding associations is crucial for proper database design and avoiding N+1 query problems."
  },
  {
    "question": "What is lazy loading in Hibernate and why is it important?",
    "answer": "Lazy loading is Hibernate feature that defers loading of associated entities until they are actually accessed, improving performance by avoiding unnecessary database queries. By default, @OneToMany and @ManyToMany associations are lazy loaded, while @ManyToOne and @OneToOne are eagerly loaded. Benefits include reduced memory usage, faster initial query execution, and loading data only when needed. Lazy loading uses proxy objects that trigger database queries when accessed. Common issues include LazyInitializationException when accessing lazy properties outside Hibernate session, and N+1 query problem with improper usage. Solutions include using fetch joins, entity graphs, or converting to eager loading when appropriate. Proper lazy loading configuration is essential for application performance and memory efficiency."
  },
  {
    "question": "What is the N+1 query problem in Hibernate and how can it be solved?",
    "answer": "N+1 query problem occurs when Hibernate executes one query to fetch N parent entities, then executes N additional queries to fetch associated entities for each parent, resulting in poor performance. Example: loading list of authors and their books executes one query for authors plus one query per author for books. Solutions include: 1) Fetch joins using 'JOIN FETCH' in HQL/JPQL, 2) Entity graphs with @NamedEntityGraph and @EntityGraph, 3) Batch fetching with @BatchSize annotation, 4) Subselect fetching with @Fetch(FetchMode.SUBSELECT), 5) Converting lazy associations to eager when appropriate. Hibernate statistics and query logging help identify N+1 problems. Proper association mapping and query optimization are crucial for application performance."
  },
  {
    "question": "What are Hibernate caching mechanisms and how do they improve performance?",
    "answer": "Hibernate provides multi-level caching to reduce database access and improve performance: 1) First-level cache (Session cache) - automatic, stores entities within single session, prevents repeated queries for same entity, 2) Second-level cache - optional, shared across sessions, stores entities and collections, requires cache provider like EHCache or Hazelcast, 3) Query cache - stores query results, works with second-level cache, useful for repeated queries with same parameters. Configuration involves enabling cache in hibernate.cfg.xml, annotating entities with @Cache, and configuring cache provider. Benefits include reduced database load, improved response times, and better application scalability. Cache eviction strategies and expiration policies ensure data consistency. Proper caching strategy significantly improves application performance, especially for read-heavy applications."
  },
  {
    "question": "What is Maven and how does it help in Java project management?",
    "answer": "Maven is build automation and project management tool for Java projects, providing standardized project structure, dependency management, and build lifecycle. Key features: 1) Project Object Model (POM) - XML file defining project configuration, dependencies, and build settings, 2) Dependency management - automatic download and management of JAR files from repositories, 3) Standard directory layout - consistent project structure (src/main/java, src/test/java), 4) Build lifecycle - predefined phases (compile, test, package, install, deploy), 5) Plugin architecture - extensible build process with plugins for various tasks. Benefits include simplified dependency management, consistent project structure, automated builds, integration with IDEs, and central repository system. Maven eliminates manual JAR management, provides reproducible builds, and enables easy project sharing and collaboration."
  },
  {
    "question": "What is the Maven build lifecycle and what are its phases?",
    "answer": "Maven build lifecycle consists of predefined phases executed in order to build and deploy projects. Default lifecycle phases: 1) validate - validate project structure and configuration, 2) compile - compile source code, 3) test - run unit tests, 4) package - create JAR/WAR files, 5) verify - run integration tests and quality checks, 6) install - copy artifacts to local repository, 7) deploy - copy artifacts to remote repository. Each phase executes all previous phases automatically. Goals are specific tasks bound to phases (compiler:compile, surefire:test). Clean lifecycle (clean) removes build artifacts, Site lifecycle (site) generates project documentation. Maven plugins provide goals that execute during phases. Understanding lifecycle helps in customizing build process and troubleshooting build issues."
  },
  {
    "question": "What is Gradle and how does it differ from Maven?",
    "answer": "Gradle is build automation tool that combines best features of Maven and Ant while providing more flexibility and performance. Key differences from Maven: 1) Build scripts - Gradle uses Groovy/Kotlin DSL instead of XML, more readable and flexible, 2) Performance - incremental builds, build cache, and daemon process make Gradle faster, 3) Flexibility - imperative programming model allows custom build logic, 4) Dependency management - similar to Maven but with more advanced conflict resolution, 5) Multi-project builds - better support for complex project hierarchies. Gradle advantages include faster builds, more expressive build scripts, better IDE integration, and compatibility with Maven repositories. Maven advantages include larger ecosystem, more mature tooling, and simpler learning curve. Choice depends on project complexity, team preferences, and performance requirements."
  },
  {
    "question": "What is Apache Tomcat and how does it serve Java web applications?",
    "answer": "Apache Tomcat is open-source servlet container and web server that implements Java Servlet, JSP, and WebSocket specifications. Architecture components: 1) Catalina - servlet container engine, 2) Coyote - HTTP connector handling client requests, 3) Jasper - JSP engine compiling JSP pages to servlets. Key features include servlet/JSP support, connection pooling, security realms, clustering capabilities, and JMX management. Tomcat serves web applications by receiving HTTP requests, routing to appropriate servlets/JSPs, executing application code, and returning responses. Configuration through server.xml, web.xml, and context.xml files. Deployment options include WAR files, exploded directories, and context descriptors. Tomcat is lightweight, easy to configure, and widely used for development and production environments. It provides essential servlet container functionality without full Java EE complexity."
  },
  {
    "question": "What is the difference between Apache Tomcat and full Java EE application servers?",
    "answer": "Tomcat is servlet container (web container) implementing only web-related Java specifications, while full Java EE servers provide complete enterprise platform. Tomcat supports: Servlet API, JSP, WebSocket, JNDI (limited), basic security realms. Full Java EE servers (WildFly, WebLogic, WebSphere) additionally support: EJB (Enterprise JavaBeans), JMS (Java Message Service), JTA (Java Transaction API), full JNDI, JCA (Java Connector Architecture), JAX-WS, JPA, CDI (Contexts and Dependency Injection). Trade-offs: Tomcat offers lightweight deployment, faster startup, lower resource usage, simpler configuration, and sufficient for web applications. Java EE servers provide comprehensive enterprise services, standardized APIs, better scalability for complex applications, but with higher complexity and resource requirements. Choice depends on application requirements - use Tomcat for web applications, Java EE servers for complex enterprise applications requiring advanced services."
  },
  {
    "question": "What is JUnit and how do you write unit tests in Java?",
    "answer": "JUnit is popular testing framework for Java providing annotations, assertions, and test runners for unit testing. Key features: 1) @Test annotation marks test methods, 2) Assertions (assertEquals, assertTrue, assertNull) verify expected outcomes, 3) @Before/@After for setup/teardown, @BeforeClass/@AfterClass for class-level setup, 4) @Ignore to skip tests, 5) Test runners execute tests and report results. JUnit 5 improvements include @BeforeEach/@AfterEach, @DisplayName for readable test names, parameterized tests with @ParameterizedTest, and modular architecture. Best practices include writing focused tests, using descriptive names, following AAA pattern (Arrange-Act-Assert), testing edge cases, and maintaining test independence. Benefits include early bug detection, code quality improvement, refactoring confidence, and documentation of expected behavior. Unit testing is essential for reliable, maintainable software development."
  },
  {
    "question": "What is Mockito and how does it help in unit testing?",
    "answer": "Mockito is mocking framework for Java unit tests that creates mock objects to simulate dependencies and isolate units under test. Key features: 1) Mock creation with @Mock annotation or Mockito.mock(), 2) Behavior stubbing with when().thenReturn(), 3) Verification with verify() to check method calls, 4) Argument matchers (any(), eq(), argThat()) for flexible matching, 5) Spy objects for partial mocking, 6) @InjectMocks for automatic dependency injection. Benefits include isolating units under test, controlling dependency behavior, testing error scenarios, and improving test performance by avoiding expensive operations. Common patterns include mocking external services, databases, and complex dependencies. Mockito enables writing focused unit tests that test specific functionality without relying on external systems, leading to faster, more reliable tests."
  },
  {
    "question": "What is log4j and how do you configure logging in Java applications?",
    "answer": "Log4j is popular logging framework for Java applications providing flexible, configurable logging capabilities. Core components: 1) Logger - creates log messages, 2) Appender - defines output destination (file, console, database), 3) Layout - formats log messages, 4) Level - controls logging verbosity (TRACE, DEBUG, INFO, WARN, ERROR, FATAL). Configuration approaches include XML, properties files, or programmatic configuration. Key features include hierarchical loggers, multiple appenders per logger, filtering capabilities, and rolling file appenders for log rotation. Best practices include using appropriate log levels, structured logging with meaningful messages, avoiding string concatenation in log statements, and configuring different levels for different environments. Modern alternatives include Logback and SLF4J (Simple Logging Facade) providing abstraction over logging implementations. Proper logging is essential for debugging, monitoring, and maintaining applications."
  },
  {
    "question": "What is SLF4J and why is it preferred over direct logging frameworks?",
    "answer": "SLF4J (Simple Logging Facade for Java) is abstraction layer for various logging frameworks (Log4j, Logback, java.util.logging), allowing applications to be independent of specific logging implementation. Benefits: 1) Framework independence - can switch logging implementations without code changes, 2) Parameterized messages - efficient string formatting with placeholders, 3) MDC (Mapped Diagnostic Context) for contextual information, 4) Better performance - lazy evaluation of log messages, 5) Type-safe API with compile-time checking. Usage involves adding SLF4J API dependency plus binding for specific implementation (slf4j-log4j12, logback-classic). Advantages include avoiding vendor lock-in, improved performance with parameterized logging, cleaner API, and ability to choose best logging implementation for specific requirements. SLF4J has become standard logging facade in Java ecosystem, used by most frameworks and libraries."
  },
  {
    "question": "What is Apache Commons and what utilities does it provide?",
    "answer": "Apache Commons is collection of reusable Java components providing utility libraries for common programming tasks. Key libraries: 1) Commons Lang - utilities for String, Object, Array manipulation, reflection helpers, 2) Commons IO - file and stream utilities, file monitoring, input/output operations, 3) Commons Collections - extended collection types, predicates, transformers, 4) Commons Configuration - configuration file reading/writing, 5) Commons Codec - encoding/decoding utilities (Base64, URL encoding), 6) Commons Validator - validation framework for forms and data, 7) Commons CLI - command-line argument parsing, 8) Commons Math - mathematical and statistical functions. Benefits include reduced development time, well-tested implementations, consistent APIs, and avoiding reinventing common functionality. Apache Commons libraries are widely used in enterprise applications and provide foundation for many frameworks. They follow best practices and provide robust, efficient implementations of common programming patterns."
  },
  {
    "question": "What is Jackson library and how is it used for JSON processing?",
    "answer": "Jackson is high-performance JSON processing library for Java providing data binding, tree model, and streaming APIs. Core components: 1) ObjectMapper - main class for JSON serialization/deserialization, 2) JsonGenerator/JsonParser for streaming API, 3) JsonNode for tree model representation. Key features include automatic POJO binding, custom serializers/deserializers, annotation-based configuration (@JsonProperty, @JsonIgnore, @JsonFormat), polymorphic type handling, and support for various data formats (JSON, XML, YAML). Usage patterns: convert objects to JSON with writeValueAsString(), convert JSON to objects with readValue(), handle collections and generic types. Configuration options include property naming strategies, date formats, and null handling. Jackson is widely used in REST APIs, web services, and data processing applications due to its performance, flexibility, and comprehensive feature set."
  },
  {
    "question": "What is Apache HTTP Client and when would you use it?",
    "answer": "Apache HTTP Client (HttpComponents) is comprehensive HTTP client library for Java providing advanced features beyond basic URL connections. Key features: 1) Connection pooling and reuse, 2) HTTP protocol support (HTTP/1.1, HTTP/2), 3) Authentication mechanisms (Basic, Digest, NTLM, Kerberos), 4) Proxy support, 5) SSL/TLS configuration, 6) Request/response interceptors, 7) Automatic redirect handling, 8) Cookie management. Use cases include: REST API consumption, web scraping, testing HTTP services, integration with external services, and scenarios requiring advanced HTTP features. Benefits over basic HTTP connections include better performance through connection pooling, comprehensive protocol support, advanced authentication, and extensive configuration options. Modern alternatives include OkHttp and Java 11's HTTP Client, but Apache HTTP Client remains popular for enterprise applications requiring robust HTTP communication capabilities."
  },
  {
    "question": "What is Docker and how does it help in Java application deployment?",
    "answer": "Docker is containerization platform that packages applications with their dependencies into lightweight, portable containers. For Java applications, Docker benefits include: 1) Consistent environments across development, testing, production, 2) Simplified deployment with container images, 3) Isolation from host system dependencies, 4) Scalability with container orchestration, 5) Version control for application environments. Java-specific considerations include choosing appropriate base images (OpenJDK, Alpine), optimizing JAR packaging, handling JVM memory settings in containers, and using multi-stage builds to reduce image size. Docker Compose manages multi-container applications (application + database). Kubernetes orchestrates containers in production. Benefits include eliminated 'works on my machine' problems, simplified CI/CD pipelines, efficient resource utilization, and easy scaling. Docker has revolutionized application deployment by providing consistent, reproducible environments."
  },
  {
    "question": "What is microservices architecture and how does it relate to Java development?",
    "answer": "Microservices architecture decomposes monolithic applications into small, independent services that communicate over network protocols. Each service owns its data, can be developed and deployed independently, and focuses on specific business capability. Java ecosystem support includes: Spring Boot for rapid service development, Spring Cloud for distributed system patterns (service discovery, circuit breakers, configuration management), Docker for containerization, Kubernetes for orchestration. Benefits include independent deployment, technology diversity, fault isolation, scalability, and team autonomy. Challenges include distributed system complexity, network latency, data consistency, service discovery, and operational overhead. Communication patterns include REST APIs, messaging (RabbitMQ, Kafka), and event-driven architectures. Microservices suit large, complex applications with multiple teams but may be overkill for simple applications. Proper design, monitoring, and DevOps practices are essential for successful microservices implementation."
  },
  {
    "question": "What is API Gateway pattern and why is it used in microservices?",
    "answer": "API Gateway is single entry point for all client requests in microservices architecture, acting as reverse proxy that routes requests to appropriate services. Key functions: 1) Request routing and composition, 2) Authentication and authorization, 3) Rate limiting and throttling, 4) Request/response transformation, 5) Logging and monitoring, 6) Load balancing, 7) Circuit breaking for fault tolerance. Benefits include simplified client interaction (single endpoint), centralized cross-cutting concerns, reduced client-service coupling, and protocol translation. Popular Java-based solutions include Spring Cloud Gateway, Netflix Zuul, and Kong. Challenges include potential single point of failure, performance bottleneck, and operational complexity. Best practices include keeping gateway lightweight, implementing health checks, using circuit breakers, and designing for high availability. API Gateway is essential pattern for managing complexity in microservices architectures while providing unified client interface."
  },
  {
    "question": "What is Circuit Breaker pattern and how is it implemented in Java?",
    "answer": "Circuit Breaker pattern prevents cascading failures in distributed systems by monitoring service calls and 'opening' the circuit when failure threshold is reached. Three states: 1) Closed - normal operation, requests pass through, 2) Open - requests fail immediately without calling service, 3) Half-Open - limited requests allowed to test service recovery. Implementation in Java: Netflix Hystrix (deprecated but widely used), Resilience4j (modern alternative), Spring Cloud Circuit Breaker abstraction. Configuration includes failure threshold, timeout duration, retry attempts, and fallback methods. Benefits include preventing cascade failures, faster failure detection, improved system resilience, and graceful degradation. Use cases include external service calls, database operations, and any potentially failing operations. Circuit breaker is essential pattern for building fault-tolerant microservices that can handle partial system failures gracefully."
  },
  {
    "question": "What is Spring Cloud and what distributed system patterns does it provide?",
    "answer": "Spring Cloud provides tools and patterns for building distributed systems and microservices on top of Spring Boot. Key components: 1) Service Discovery (Eureka, Consul) - services register and discover each other, 2) Configuration Management (Config Server) - centralized configuration across services, 3) Circuit Breaker (Hystrix, Resilience4j) - fault tolerance patterns, 4) API Gateway (Spring Cloud Gateway) - single entry point for requests, 5) Load Balancing (Ribbon) - client-side load balancing, 6) Distributed Tracing (Sleuth, Zipkin) - request tracing across services, 7) Message Bus (Spring Cloud Bus) - configuration refresh across services. Benefits include simplified microservices development, proven patterns implementation, Spring ecosystem integration, and comprehensive distributed system toolkit. Spring Cloud abstracts complexity of distributed systems while providing production-ready solutions for common microservices challenges."
  },
  {
    "question": "What is Enterprise JavaBeans (EJB) and what are its main types?",
    "answer": "Enterprise JavaBeans (EJB) is a server-side component architecture for building distributed, enterprise-class applications in Java. EJB provides a framework for developing scalable, transactional, and secure applications. The main types of EJBs are: 1) Session Beans - encapsulate business logic and can be stateless (no client state between method calls) or stateful (maintain client state), 2) Entity Beans - represent persistent data objects (deprecated in EJB 3.0, replaced by JPA entities), 3) Message-Driven Beans (MDBs) - handle asynchronous messages from JMS queues or topics. EJBs run in an EJB container that provides services like transaction management, security, concurrency, and lifecycle management. Modern applications often use Spring Framework instead of EJB for simpler development and testing."
  },
  {
    "question": "What is the difference between stateful and stateless session beans?",
    "answer": "Stateful and stateless session beans differ in how they manage client state: Stateful Session Beans maintain conversational state with clients across multiple method calls, have dedicated instances per client, use @Stateful annotation, are removed when client session ends or explicitly removed, and are suitable for shopping carts, user sessions, or multi-step processes. Stateless Session Beans don't maintain client state between method calls, are pooled and shared among clients, use @Stateless annotation, are more scalable due to pooling, and are suitable for business operations that don't require state maintenance. Stateless beans offer better performance and scalability because the container can pool and reuse instances efficiently, while stateful beans provide conversational context but consume more resources per client."
  },
  {
    "question": "What are Message-Driven Beans (MDBs) and how do they work?",
    "answer": "Message-Driven Beans (MDBs) are specialized EJBs that process asynchronous messages from JMS (Java Message Service) destinations like queues or topics. Key characteristics: 1) Asynchronous processing - messages are processed independently of the sender, 2) No direct client interface - clients don't invoke MDBs directly, 3) Automatic message consumption - container automatically delivers messages to MDB instances, 4) Transaction support - can participate in container-managed or bean-managed transactions, 5) Concurrency - multiple MDB instances can process messages concurrently. MDBs implement MessageListener interface and are annotated with @MessageDriven. They're ideal for decoupling systems, handling background processing, implementing event-driven architectures, and processing high-volume asynchronous operations. The EJB container manages the message delivery and bean lifecycle automatically."
  },
  {
    "question": "What is JMS (Java Message Service) and what are its messaging models?",
    "answer": "JMS (Java Message Service) is a Java API for sending messages between distributed applications, enabling asynchronous communication and decoupling of system components. JMS supports two messaging models: 1) Point-to-Point (Queue) - messages are sent to a specific queue where only one consumer receives each message, suitable for task distribution and load balancing, 2) Publish-Subscribe (Topic) - messages are published to topics where multiple subscribers can receive the same message, suitable for event notifications and broadcasting. Key JMS concepts include ConnectionFactory (creates connections), Destination (queue or topic), MessageProducer (sends messages), MessageConsumer (receives messages), and various message types (TextMessage, ObjectMessage, BytesMessage). JMS provides reliable, asynchronous communication essential for enterprise integration, microservices communication, and event-driven architectures."
  },
  {
    "question": "What is SOAP and how does it differ from REST?",
    "answer": "SOAP (Simple Object Access Protocol) is a protocol for exchanging structured information in web services using XML. Key characteristics: uses XML for all communication, has strict standards and specifications, includes built-in error handling with SOAP faults, supports ACID transactions, requires WSDL for service description, works over multiple protocols (HTTP, SMTP, etc.), and provides WS-Security for advanced security features. REST (Representational State Transfer) is an architectural style that uses HTTP methods and is typically lighter weight. Key differences: SOAP uses XML exclusively while REST can use JSON, XML, HTML; SOAP has strict standards while REST is more flexible; SOAP has built-in security while REST relies on HTTPS; SOAP supports complex operations while REST focuses on simple CRUD operations; SOAP has automatic code generation tools while REST is simpler to implement manually. Choose SOAP for enterprise applications requiring strict security and transactions, REST for web APIs and microservices requiring simplicity and performance."
  },
  {
    "question": "What is WSDL and how is it used in web services?",
    "answer": "WSDL (Web Services Description Language) is an XML-based language used to describe web services, their operations, input/output parameters, and communication protocols. WSDL serves as a contract between service provider and consumer, specifying how to interact with the service. Key components: 1) Types - defines data types used by the service, 2) Message - defines the data elements for operations, 3) PortType - defines operations supported by the service, 4) Binding - specifies protocol and data format for operations, 5) Service - specifies address/location of the service. WSDL enables automatic code generation for client stubs and server skeletons, ensures interoperability between different platforms, provides documentation for service interfaces, and supports design-first approach for web service development. Tools like wsimport can generate Java classes from WSDL, while wsgen can generate WSDL from Java classes. WSDL is essential for SOAP-based web services but less commonly used with REST services."
  },
  {
    "question": "What is JAX-WS and how do you create SOAP web services with it?",
    "answer": "JAX-WS (Java API for XML Web Services) is the Java standard for creating SOAP-based web services. It provides annotations and APIs for developing both web service endpoints and clients. Creating SOAP web services: 1) Define service endpoint interface with @WebService annotation, 2) Implement the interface with @WebService annotation, 3) Use @WebMethod for service operations, @WebParam for parameters, 4) Deploy to application server or use Endpoint.publish() for standalone deployment. Example: @WebService public class CalculatorService { @WebMethod public int add(@WebParam(name=\"a\") int a, @WebParam(name=\"b\") int b) { return a + b; } }. JAX-WS features include automatic WSDL generation, data binding with JAXB, support for various communication patterns (synchronous, asynchronous, one-way), message handlers for custom processing, and WS-Security integration. Modern alternatives include Spring Boot with @WebService or Spring Web Services for easier configuration and testing."
  },
  {
    "question": "What is XML and why is it important in Java enterprise applications?",
    "answer": "XML (eXtensible Markup Language) is a markup language that defines rules for encoding documents in human-readable and machine-readable format. In Java enterprise applications, XML is crucial for: 1) Configuration files - Spring configuration, web.xml, persistence.xml, 2) Data interchange - between systems, web services, APIs, 3) Web services - SOAP messages, WSDL descriptions, 4) Data binding - converting between XML and Java objects, 5) Document processing - reports, content management, 6) Message formats - JMS messages, integration systems. XML benefits include platform independence, self-describing structure, extensibility, validation support with XSD schemas, and wide tool support. Java provides extensive XML support through JAXP (Java API for XML Processing), JAXB (Java Architecture for XML Binding), DOM and SAX parsers, XPath for querying, and XSLT for transformation. While JSON has become popular for REST APIs, XML remains important in enterprise integration, legacy system communication, and complex document processing."
  },
  {
    "question": "What is JAXB and how does it work?",
    "answer": "JAXB (Java Architecture for XML Binding) is a framework that allows mapping between XML schema and Java classes for automatic conversion between XML documents and Java objects. JAXB provides marshalling (Java object to XML) and unmarshalling (XML to Java object) capabilities. Key features: 1) Annotations like @XmlRootElement, @XmlElement, @XmlAttribute for mapping control, 2) Automatic schema generation from Java classes, 3) Code generation from XML schema using xjc tool, 4) Support for complex types, collections, inheritance, 5) Customization through binding files. Example: @XmlRootElement class Person { @XmlElement private String name; @XmlAttribute private int id; }. Usage: JAXBContext context = JAXBContext.newInstance(Person.class); Marshaller marshaller = context.createMarshaller(); marshaller.marshal(person, System.out);. JAXB simplifies XML processing by eliminating manual parsing, provides type safety, supports validation, and integrates well with web services. It's essential for SOAP web services, configuration processing, and data interchange in enterprise applications."
  },
  {
    "question": "What is Apache Maven and how does it manage dependencies?",
    "answer": "Apache Maven is a build automation and project management tool that uses XML-based Project Object Model (POM) files to manage project builds, dependencies, and documentation. Maven manages dependencies through: 1) Central Repository - default repository hosting thousands of Java libraries, 2) Dependency declarations in pom.xml with groupId, artifactId, version coordinates, 3) Transitive dependency resolution - automatically resolves dependencies of dependencies, 4) Scope management - compile, test, runtime, provided scopes control when dependencies are available, 5) Version conflict resolution using nearest-wins strategy, 6) Local repository (~/.m2/repository) caches downloaded dependencies. Benefits include simplified dependency management, standardized project structure (src/main/java, src/test/java), consistent build process across environments, integration with IDEs, and extensive plugin ecosystem. Maven eliminates manual JAR management, ensures reproducible builds, and supports multi-module projects. Modern alternatives include Gradle which offers more flexibility and better performance for large projects."
  },
  {
    "question": "What are Maven scopes and when do you use each one?",
    "answer": "Maven dependency scopes define when dependencies are available during different phases of the build lifecycle: 1) Compile (default) - available in all classpaths, included in final artifact, used for main application dependencies, 2) Test - only available during test compilation and execution, not included in final artifact, used for testing frameworks like JUnit, Mockito, 3) Runtime - not needed for compilation but required for execution, included in runtime and test classpaths, used for JDBC drivers, logging implementations, 4) Provided - available during compilation and test but not included in final artifact, expected to be provided by runtime environment, used for servlet APIs, Java EE APIs, 5) System - similar to provided but explicitly specify JAR location, rarely used and not recommended, 6) Import - only used with dependencyManagement for importing POMs. Choosing correct scope is important for: reducing artifact size, avoiding classpath conflicts, ensuring proper runtime behavior, and optimizing build performance. Most dependencies use compile scope, while testing libraries use test scope and container-provided APIs use provided scope."
  },
  {
    "question": "What is Gradle and how does it compare to Maven?",
    "answer": "Gradle is a build automation tool that uses Groovy or Kotlin DSL instead of XML for build scripts, offering more flexibility and performance than Maven. Key differences: Build scripts - Gradle uses build.gradle with Groovy/Kotlin vs Maven's pom.xml, Performance - Gradle offers incremental builds, build cache, and daemon for faster builds, Flexibility - Gradle allows imperative programming while Maven is declarative, Dependencies - both support similar dependency management but Gradle offers more advanced conflict resolution, Multi-project builds - Gradle provides better support for complex project hierarchies. Gradle advantages: faster builds, more expressive build scripts, better IDE integration, composite builds, rich plugin ecosystem. Maven advantages: wider adoption, more mature ecosystem, simpler learning curve, extensive documentation. Choose Gradle for complex builds requiring customization and performance, Maven for straightforward projects with established conventions. Both support Java ecosystem, central repositories, and similar dependency management concepts."
  },
  {
    "question": "What is Jenkins and how is it used in Java project CI/CD?",
    "answer": "Jenkins is an open-source automation server used for Continuous Integration (CI) and Continuous Deployment (CD) in software development. For Java projects, Jenkins provides: 1) Automated builds triggered by code commits, scheduled intervals, or manual execution, 2) Integration with build tools like Maven, Gradle, Ant, 3) Testing automation with JUnit, TestNG, integration tests, 4) Code quality analysis with SonarQube, Checkstyle, PMD, 5) Deployment automation to various environments, 6) Pipeline as Code using Jenkinsfile for version-controlled build processes. Typical Java CI/CD pipeline: source code checkout → compile → unit tests → package (JAR/WAR) → quality analysis → integration tests → deployment to staging → deployment to production. Jenkins features include extensive plugin ecosystem, distributed builds with master-slave architecture, integration with version control systems (Git, SVN), notification systems, and support for Docker, Kubernetes. Modern alternatives include GitLab CI, GitHub Actions, and cloud-based solutions, but Jenkins remains popular for its flexibility and plugin ecosystem."
  },
  {
    "question": "What is SonarQube and how does it improve Java code quality?",
    "answer": "SonarQube is a platform for continuous code quality analysis that identifies bugs, vulnerabilities, code smells, and technical debt in Java applications. It improves code quality through: 1) Static code analysis detecting potential bugs, security vulnerabilities, maintainability issues, 2) Code coverage measurement from unit and integration tests, 3) Duplication detection for identifying copy-paste code, 4) Complexity metrics like cyclomatic complexity, cognitive complexity, 5) Security hotspot identification for OWASP Top 10 vulnerabilities, 6) Technical debt quantification with remediation effort estimates. SonarQube provides quality gates - pass/fail criteria for builds based on metrics thresholds, integration with CI/CD pipelines, detailed reporting and dashboards, historical trend analysis, and rule customization for team standards. For Java, it analyzes code using rules for best practices, performance, reliability, security, and maintainability. Integration with IDEs (SonarLint), build tools (Maven, Gradle), and CI servers (Jenkins) enables early detection of issues. SonarQube promotes clean code practices, reduces technical debt, and ensures consistent code quality across teams."
  },
  {
    "question": "What is Docker and how is it used with Java applications?",
    "answer": "Docker is a containerization platform that packages applications with their dependencies into lightweight, portable containers. For Java applications, Docker provides: 1) Consistent environments across development, testing, and production, 2) Simplified deployment with container images, 3) Isolation from host system dependencies, 4) Scalability with container orchestration (Kubernetes, Docker Swarm), 5) Efficient resource utilization compared to virtual machines. Java-specific considerations: choosing appropriate base images (OpenJDK, Alpine Linux for smaller size), configuring JVM memory settings for containers, handling application JAR files, managing configuration and secrets. Example Dockerfile: FROM openjdk:11-jre-slim, COPY app.jar /app.jar, EXPOSE 8080, CMD [\"java\", \"-jar\", \"/app.jar\"]. Benefits include eliminated 'works on my machine' problems, simplified CI/CD pipelines, easy scaling and load balancing, version control for environments, and support for microservices architecture. Docker Compose manages multi-container applications (app + database), while Kubernetes orchestrates containers in production environments."
  },
  {
    "question": "What is Kubernetes and how does it orchestrate Java applications?",
    "answer": "Kubernetes is a container orchestration platform that automates deployment, scaling, and management of containerized applications. For Java applications, Kubernetes provides: 1) Automated deployment with Deployments managing ReplicaSets and Pods, 2) Service discovery and load balancing with Services, 3) Auto-scaling based on CPU, memory, or custom metrics, 4) Rolling updates and rollbacks for zero-downtime deployments, 5) Configuration management with ConfigMaps and Secrets, 6) Persistent storage with PersistentVolumes. Key concepts: Pods (smallest deployable units containing containers), Services (expose applications internally/externally), Ingress (HTTP/HTTPS routing), Namespaces (resource isolation). Java-specific considerations: JVM memory settings for container limits, readiness/liveness probes for health checks, graceful shutdown handling, JVM warmup time, and monitoring with tools like Prometheus. Example deployment includes containerized Spring Boot application with HorizontalPodAutoscaler, Service for load balancing, and Ingress for external access. Kubernetes enables microservices architecture, improved resource utilization, high availability, and simplified operations for enterprise Java applications."
  },
  {
    "question": "What is the Twelve-Factor App methodology and how does it apply to Java applications?",
    "answer": "The Twelve-Factor App is a methodology for building software-as-a-service applications that are portable, scalable, and maintainable. For Java applications, the twelve factors are: 1) Codebase - one codebase tracked in version control, many deployments, 2) Dependencies - explicitly declare and isolate dependencies using Maven/Gradle, 3) Config - store configuration in environment variables, not in code, 4) Backing services - treat databases, message queues as attached resources, 5) Build, release, run - strictly separate build and run stages, 6) Processes - execute app as stateless processes, 7) Port binding - export services via port binding (embedded servers), 8) Concurrency - scale out via process model, 9) Disposability - maximize robustness with fast startup and graceful shutdown, 10) Dev/prod parity - keep development, staging, production as similar as possible, 11) Logs - treat logs as event streams to stdout, 12) Admin processes - run admin/management tasks as one-off processes. Java implementations include Spring Boot for embedded servers, externalized configuration, Docker for consistent environments, and cloud-native patterns for scalability and resilience."
  },
  {
    "question": "What are design patterns and why are they important in Java development?",
    "answer": "Design patterns are reusable solutions to commonly occurring problems in software design, providing templates for solving design issues. They're important in Java development because: 1) Code reusability - proven solutions reduce development time, 2) Communication - provide common vocabulary for developers, 3) Best practices - encapsulate expert knowledge and experience, 4) Maintainability - lead to more organized, understandable code, 5) Problem-solving - guide architectural decisions. Pattern categories: Creational (object creation) - Singleton, Factory, Builder, Abstract Factory; Structural (object composition) - Adapter, Decorator, Facade, Proxy; Behavioral (object interaction) - Observer, Strategy, Command, Template Method. Java's object-oriented nature makes it ideal for implementing patterns. Benefits include improved code quality, easier testing through dependency injection and interfaces, reduced coupling, and enhanced flexibility. However, avoid overusing patterns or forcing them where they don't naturally fit. Understanding patterns helps in framework usage (Spring uses many patterns internally), API design, and creating maintainable enterprise applications."
  },
  {
    "question": "What is the Repository pattern and how is it implemented in Java?",
    "answer": "The Repository pattern encapsulates data access logic and provides a uniform interface for accessing domain objects, abstracting underlying data storage mechanisms. It centralizes common data access functionality for better maintainability and decouples business logic from data access infrastructure. Implementation in Java: 1) Define repository interface with CRUD operations: interface UserRepository { User findById(Long id); List<User> findAll(); void save(User user); void delete(User user); }, 2) Create concrete implementation: class JpaUserRepository implements UserRepository using JPA EntityManager, 3) Use dependency injection to inject repository into service classes. Benefits include testability (easy to mock for unit tests), flexibility (can switch between different data sources), separation of concerns, and consistent data access patterns. Spring Data JPA simplifies implementation by providing automatic implementation generation: interface UserRepository extends JpaRepository<User, Long> { List<User> findByLastName(String lastName); }. The pattern works well with Domain-Driven Design and enables clean architecture by keeping business logic separate from data persistence concerns."
  },
  {
    "question": "What is the Service Layer pattern and how does it organize business logic?",
    "answer": "The Service Layer pattern defines application boundaries and encapsulates business logic, coordinating between presentation layer and data access layer. It provides a simplified interface to complex business operations and ensures transaction boundaries. Key characteristics: 1) Business logic encapsulation - contains application's business rules and workflows, 2) Transaction management - defines transaction boundaries for operations, 3) Coordination - orchestrates multiple domain objects and repositories, 4) Interface definition - provides clear API for business operations, 5) Cross-cutting concerns - handles security, logging, validation. Implementation: @Service public class UserService { @Autowired private UserRepository userRepository; @Transactional public User createUser(UserDTO userDTO) { validateUser(userDTO); User user = mapToEntity(userDTO); return userRepository.save(user); } }. Benefits include clear separation of concerns, easier testing, transaction management, and reusable business logic. Service layer should be thin, delegating complex business logic to domain objects. Avoid anemic domain model by keeping business logic in domain objects when appropriate. The pattern is essential in enterprise applications for organizing business logic and maintaining clean architecture."
  },
  {
    "question": "What is the MVC (Model-View-Controller) pattern and how is it implemented in Java web applications?",
    "answer": "MVC is an architectural pattern that separates application logic into three interconnected components: Model (data and business logic), View (presentation layer), Controller (handles input and coordinates between Model and View). In Java web applications: Model represents data using entities, DTOs, business logic in services, and data access through repositories. View renders data to users using JSP, Thymeleaf templates, or JSON for REST APIs. Controller handles HTTP requests using servlets or Spring MVC controllers, processes user input, invokes business logic, and selects appropriate view. Spring MVC implementation: @Controller public class UserController { @Autowired private UserService userService; @GetMapping(\"/users/{id}\") public String getUser(@PathVariable Long id, Model model) { User user = userService.findById(id); model.addAttribute(\"user\", user); return \"user-detail\"; } }. Benefits include separation of concerns, easier testing, parallel development, and maintainability. Modern variations include MVP (Model-View-Presenter) and MVVM (Model-View-ViewModel). REST APIs often use Controller-Service-Repository pattern as MVC variant where JSON responses replace traditional views."
  },
  {
    "question": "What is the Data Access Object (DAO) pattern?",
    "answer": "The DAO (Data Access Object) pattern abstracts and encapsulates all access to a data source, providing a clean separation between business logic and data access logic. It defines a standard interface for accessing persistent data, enabling database independence and easier testing. Components: 1) DAO interface defining data access methods, 2) Concrete DAO implementation for specific data source, 3) Model/Entity objects representing data, 4) Optional DAO Factory for creating DAO instances. Example: interface UserDAO { User findById(Long id); List<User> findAll(); void save(User user); void delete(User user); } implemented by UserDAOImpl using JDBC, JPA, or other persistence technology. Benefits include database independence, centralized data access logic, easier testing with mock DAOs, consistent data access patterns, and separation of concerns. The pattern has largely been superseded by Spring Data repositories and JPA, which provide similar abstraction with less boilerplate code. However, DAO pattern remains useful for complex queries, stored procedure calls, or when working with multiple data sources. Modern applications often use Repository pattern, which is conceptually similar but more domain-focused."
  },
  {
    "question": "What is the Observer pattern and how is it used in Java?",
    "answer": "The Observer pattern defines a one-to-many dependency between objects so that when one object (Subject) changes state, all dependents (Observers) are automatically notified. Java historically provided Observable class and Observer interface, but these are deprecated. Modern implementation: 1) Define Observer interface: interface Observer { void update(String message); }, 2) Create Subject with observer management: class Subject { private List<Observer> observers = new ArrayList<>(); public void addObserver(Observer o) { observers.add(o); } public void notifyObservers(String message) { observers.forEach(o -> o.update(message)); } }. Java provides built-in support through PropertyChangeListener for JavaBeans, event listeners in GUI frameworks (ActionListener, MouseListener), and reactive programming with RxJava or Project Reactor. Benefits include loose coupling between subject and observers, dynamic relationships, broadcast communication, and support for event-driven architectures. Use cases include GUI event handling, model-view architectures, notification systems, and reactive programming. Modern alternatives include reactive streams, CompletableFuture callbacks, and event-driven frameworks like Spring's ApplicationEvent mechanism."
  },
  {
    "question": "What is the Strategy pattern and how does it provide flexibility in Java applications?",
    "answer": "The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable at runtime. It enables selecting algorithms dynamically without altering client code. Components: 1) Strategy interface defining algorithm contract, 2) Concrete strategies implementing different algorithms, 3) Context class using strategy and allowing strategy switching. Example: interface PaymentStrategy { void pay(double amount); } implemented by CreditCardPayment, PayPalPayment, BankTransferPayment. Context: class PaymentContext { private PaymentStrategy strategy; public void setStrategy(PaymentStrategy strategy) { this.strategy = strategy; } public void processPayment(double amount) { strategy.pay(amount); } }. Benefits include eliminating conditional statements (if-else, switch), easy addition of new algorithms without modifying existing code, runtime algorithm selection, improved testability, and adherence to Open-Closed Principle. Java 8+ functional interfaces and lambdas simplify implementation: strategies can be passed as lambda expressions. The pattern is used in Collections.sort() with Comparator, Spring Security with authentication strategies, and validation frameworks. It promotes composition over inheritance and enables flexible, maintainable code architecture."
  },
  {
    "question": "What is the Command pattern and how is it implemented in Java?",
    "answer": "The Command pattern encapsulates requests as objects, allowing parameterization of clients with different requests, queuing operations, and supporting undo functionality. Components: 1) Command interface defining execute() method, 2) Concrete commands implementing specific operations, 3) Receiver objects performing actual work, 4) Invoker calling command execution, 5) Client creating and configuring commands. Example: interface Command { void execute(); void undo(); } implemented by SaveCommand, DeleteCommand. Implementation: class SaveCommand implements Command { private Document document; public void execute() { document.save(); } public void undo() { document.revert(); } }. Invoker: class Button { private Command command; public void setCommand(Command command) { this.command = command; } public void click() { command.execute(); } }. Benefits include decoupling invoker from receiver, queuing and logging requests, supporting undo/redo operations, implementing macros, and enabling transactional behavior. Use cases include GUI buttons and menu items, macro recording, undo/redo functionality, queuing requests, remote procedure calls, and transaction processing. The pattern enables flexible request handling and supports complex operations like batching and rollback in enterprise applications."
  },
  {
    "question": "What is the Template Method pattern and how does it work in Java?",
    "answer": "The Template Method pattern defines the skeleton of an algorithm in a base class, letting subclasses override specific steps without changing the algorithm's overall structure. It promotes code reuse while allowing customization of specific steps. Implementation: 1) Abstract class with template method defining algorithm steps, 2) Abstract methods that subclasses must implement, 3) Hook methods (optional) that subclasses can override, 4) Final template method preventing algorithm structure changes. Example: abstract class DataProcessor { public final void process() { readData(); validateData(); processData(); saveData(); } protected abstract void readData(); protected abstract void processData(); protected void validateData() { /* default implementation */ } }. Subclasses implement readData() and processData() while inheriting the overall process flow. Benefits include code reuse through inheritance, controlled extension points, inversion of control (Hollywood Principle), and consistent algorithm structure. Java examples include Collections.sort() using Comparable.compareTo(), servlet lifecycle methods, and stream processing pipelines. The pattern is useful for frameworks where common workflow exists but specific steps vary. However, favor composition over inheritance when possible, and consider Strategy pattern for runtime algorithm switching."
  },
  {
    "question": "What is the Adapter pattern and when would you use it in Java?",
    "answer": "The Adapter pattern allows incompatible interfaces to work together by creating a wrapper that translates one interface to another. It enables classes with incompatible interfaces to collaborate without modifying their source code. Types: 1) Object Adapter uses composition to wrap adaptee, 2) Class Adapter uses inheritance (requires multiple inheritance, limited in Java). Structure: Target interface (what client expects), Adaptee (existing incompatible interface), Adapter (implements Target and wraps Adaptee). Example: interface MediaPlayer { void play(String filename); } and existing class Mp3Player { void playMp3(String filename); }. Adapter: class Mp3Adapter implements MediaPlayer { private Mp3Player mp3Player; public void play(String filename) { mp3Player.playMp3(filename); } }. Use cases include integrating third-party libraries, legacy code integration, making incompatible APIs work together, creating reusable components. Java examples include InputStreamReader (adapts InputStream to Reader), Arrays.asList() (adapts arrays to List interface), and wrapper classes for primitive types. Benefits include code reuse without modification, integration of disparate systems, and clean interfaces. The pattern is essential for system integration and maintaining backward compatibility."
  },
  {
    "question": "What is the Facade pattern and how does it simplify complex systems?",
    "answer": "The Facade pattern provides a unified, simplified interface to a complex subsystem, hiding its complexity from clients and reducing coupling between clients and subsystem components. It acts as a higher-level interface that makes the subsystem easier to use. Components: 1) Facade class providing simple methods, 2) Complex subsystem classes with detailed functionality, 3) Client interacting only with facade. Example: Computer subsystem with CPU, Memory, HardDrive classes. ComputerFacade: class ComputerFacade { private CPU cpu; private Memory memory; private HardDrive hardDrive; public void startComputer() { cpu.start(); memory.load(); hardDrive.read(); } }. The facade doesn't encapsulate subsystem classes but provides convenient access points. Benefits include simplified interface, reduced coupling between client and subsystem, easier subsystem evolution, and improved usability. Java examples include java.net.URL (hides complex networking), javax.faces.context.FacesContext (JSF), and various API wrappers. Use cases include providing simple interface to complex subsystem, reducing dependencies, layering subsystems, and creating entry points for complex operations. The pattern promotes loose coupling and makes complex systems more accessible to clients."
  },
  {
    "question": "What is the Proxy pattern and what are its different types?",
    "answer": "The Proxy pattern provides a placeholder or surrogate that controls access to another object, allowing additional functionality without changing the original object's interface. Types: 1) Virtual Proxy - delays expensive object creation until needed (lazy initialization), 2) Protection Proxy - controls access based on permissions and security, 3) Remote Proxy - represents object in different address space (RMI, web services), 4) Cache Proxy - provides caching functionality to improve performance. Structure: Subject interface, Real Subject implementing actual functionality, Proxy implementing same interface and controlling access. Example: interface Image { void display(); } with expensive RealImage and lightweight ProxyImage that loads RealImage on first access. Benefits include lazy initialization, access control, caching, logging, and remote access management. Java examples include java.lang.reflect.Proxy for dynamic proxies, RMI stubs for remote objects, lazy loading in ORM frameworks (Hibernate proxies), and security proxies in frameworks. Implementation can be static (compile-time) or dynamic (runtime using reflection). Use proxy when you need to control access, add functionality transparently, or manage resource-intensive objects efficiently. Modern applications use AOP frameworks like Spring AOP for cross-cutting concerns through proxy-based interception."
  },
  {
    "question": "What is Aspect-Oriented Programming (AOP) and how is it implemented in Java?",
    "answer": "AOP (Aspect-Oriented Programming) is a programming paradigm that enables separation of cross-cutting concerns (logging, security, transactions) from business logic by modularizing them into aspects. Key concepts: 1) Aspect - module containing cross-cutting logic, 2) Join Point - points in program execution where aspects can be applied, 3) Pointcut - expressions defining which join points to target, 4) Advice - action taken at join points (before, after, around), 5) Weaving - process of applying aspects to target objects. Spring AOP implementation uses proxy-based approach: @Aspect public class LoggingAspect { @Before(\"execution(* com.example.service.*.*(..))\") public void logBefore(JoinPoint joinPoint) { System.out.println(\"Executing: \" + joinPoint.getSignature().getName()); } }. AspectJ provides more comprehensive AOP with compile-time and load-time weaving. Benefits include separation of concerns, code reusability, cleaner business logic, and centralized cross-cutting functionality. Use cases include logging, security, transaction management, performance monitoring, and exception handling. AOP complements OOP by addressing concerns that span multiple objects and layers in enterprise applications."
  },
  {
    "question": "What is Spring AOP and how does it differ from AspectJ?",
    "answer": "Spring AOP is a proxy-based AOP framework that provides cross-cutting concern implementation through runtime proxies, while AspectJ is a full AOP extension to Java with compile-time and load-time weaving. Key differences: Spring AOP uses JDK dynamic proxies or CGLIB proxies created at runtime, only supports method execution join points, integrates seamlessly with Spring IoC container, and has simpler configuration. AspectJ supports all join points (method calls, field access, constructor execution), uses compile-time weaving with ajc compiler, provides more powerful pointcut expressions, and offers better performance. Spring AOP advantages: easier setup, Spring integration, sufficient for most enterprise needs, no special compiler required. AspectJ advantages: more powerful, better performance, complete AOP solution, supports all join points. Spring can integrate with AspectJ for advanced features while maintaining Spring benefits. Choose Spring AOP for method-level cross-cutting concerns in Spring applications, AspectJ for comprehensive AOP requirements, complex pointcuts, or non-Spring environments. Most enterprise applications find Spring AOP sufficient for common concerns like logging, security, and transaction management."
  },
  {
    "question": "What is JPA (Java Persistence API) and how does it simplify database operations?",
    "answer": "JPA (Java Persistence API) is a Java specification for managing relational data in applications using Object-Relational Mapping (ORM). It provides a POJO-based approach to persistence, abstracting database operations through entity objects and reducing boilerplate JDBC code. Key features: 1) Entity mapping with annotations (@Entity, @Table, @Column), 2) Relationship mapping (@OneToMany, @ManyToOne, @ManyToMany), 3) JPQL (Java Persistence Query Language) for object-oriented queries, 4) Criteria API for type-safe dynamic queries, 5) EntityManager for persistence operations, 6) Transaction management integration. Example: @Entity public class User { @Id @GeneratedValue private Long id; @Column private String name; @OneToMany private List<Order> orders; }. Benefits include database independence, reduced boilerplate code, automatic SQL generation, caching mechanisms, lazy loading, and integration with application servers. Popular implementations include Hibernate (most common), EclipseLink, and OpenJPA. JPA simplifies database operations by providing object-oriented persistence layer, eliminating manual JDBC coding, and enabling database-agnostic applications. Modern Spring Boot applications commonly use Spring Data JPA for even simpler repository-based data access."
  },
  {
    "question": "What are JPA entity relationships and how do you map them?",
    "answer": "JPA entity relationships represent associations between database tables through object references. Four main relationship types: 1) @OneToOne - one entity instance relates to one instance of another, uses @JoinColumn for foreign key or shared primary key mapping, 2) @OneToMany - one entity relates to multiple instances of another, typically mapped with @JoinColumn or @JoinTable, often bidirectional with @ManyToOne on other side, 3) @ManyToOne - multiple instances relate to one instance, uses @JoinColumn for foreign key, most common relationship type, 4) @ManyToMany - multiple instances relate to multiple instances, requires junction table mapped with @JoinTable. Configuration options include fetch type (LAZY/EAGER), cascade operations (PERSIST, MERGE, REMOVE, REFRESH, DETACH, ALL), orphan removal for parent-child relationships, and mapping strategies. Example: @Entity class Order { @ManyToOne @JoinColumn(name = \"customer_id\") private Customer customer; @OneToMany(mappedBy = \"order\", cascade = CascadeType.ALL) private List<OrderItem> items; }. Best practices include using LAZY fetching by default, careful cascade configuration, avoiding N+1 query problems with fetch joins, and proper bidirectional relationship management. Understanding relationships is crucial for effective JPA usage and database design."
  },
  {
    "question": "What is Spring Data JPA and how does it simplify data access?",
    "answer": "Spring Data JPA provides a repository abstraction layer over JPA, dramatically reducing boilerplate code for data access operations. It offers automatic implementation generation for repository interfaces, eliminating need for manual DAO implementations. Key features: 1) Repository interfaces (CrudRepository, JpaRepository) providing basic CRUD operations, 2) Query methods derived from method names (findByLastName, findByAgeGreaterThan), 3) Custom queries with @Query annotation using JPQL or native SQL, 4) Pagination and sorting support with Pageable, 5) Specifications for dynamic queries, 6) Auditing capabilities with @CreatedDate, @LastModifiedDate. Example: interface UserRepository extends JpaRepository<User, Long> { List<User> findByLastNameAndAgeGreaterThan(String lastName, int age); @Query(\"SELECT u FROM User u WHERE u.email = ?1\") User findByEmail(String email); }. Benefits include minimal code requirements, type-safe queries, automatic implementation generation, consistent API across different data stores, pagination support, and Spring ecosystem integration. Spring Data JPA supports advanced features like entity graphs for fetch optimization, batch operations, and custom repository implementations. It's the preferred approach for data access in modern Spring applications, significantly reducing development time while maintaining flexibility for complex scenarios."
  },
  {
    "question": "What is caching in Java applications and what are the different caching strategies?",
    "answer": "Caching in Java applications involves storing frequently accessed data in memory to improve performance by reducing expensive operations like database queries, web service calls, or complex calculations. Caching strategies include: 1) Cache-aside (Lazy Loading) - application manages cache explicitly, loads data on cache miss, 2) Write-through - data written to cache and database simultaneously, ensures consistency, 3) Write-behind (Write-back) - data written to cache immediately, database updated asynchronously, 4) Refresh-ahead - proactively refreshes cache entries before expiration. Cache levels: L1 (application-level caching), L2 (shared/distributed caching), browser caching, CDN caching. Java caching solutions include: Ehcache (embedded cache), Redis (distributed cache), Hazelcast (in-memory data grid), Caffeine (high-performance local cache), Spring Cache abstraction (@Cacheable, @CacheEvict, @CachePut annotations). Considerations include cache eviction policies (LRU, LFU, TTL), cache coherence in distributed systems, memory usage, and cache warming strategies. Effective caching can dramatically improve application performance but requires careful design to avoid stale data and memory issues."
  },
  {
    "question": "What is Redis and how is it used with Java applications?",
    "answer": "Redis (Remote Dictionary Server) is an in-memory data structure store used as database, cache, message broker, and session store. It supports various data types including strings, hashes, lists, sets, sorted sets, bitmaps, and hyperloglogs. Java integration uses Jedis, Lettuce, or Spring Data Redis clients. Key features: 1) High performance in-memory storage, 2) Persistence options (RDB snapshots, AOF logging), 3) Replication and clustering for scalability, 4) Pub/Sub messaging, 5) Lua scripting support, 6) Atomic operations and transactions. Spring Boot integration: @Configuration @EnableCaching public class RedisConfig { @Bean public RedisTemplate<String, Object> redisTemplate() { RedisTemplate<String, Object> template = new RedisTemplate<>(); template.setConnectionFactory(connectionFactory()); return template; } }. Use cases include session storage, application caching, real-time analytics, message queuing, and leaderboards. Benefits include exceptional performance, rich data types, high availability, and horizontal scaling. Redis is ideal for scenarios requiring fast data access, session management in distributed applications, and real-time features. Modern microservices architectures commonly use Redis for cross-service caching and session sharing."
  },
  {
    "question": "What is Apache Kafka and how is it used for messaging in Java applications?",
    "answer": "Apache Kafka is a distributed streaming platform used for building real-time data pipelines and streaming applications. It provides high-throughput, fault-tolerant, publish-subscribe messaging system. Key concepts: 1) Topics - categories for organizing messages, 2) Partitions - topics split across multiple brokers for scalability, 3) Producers - publish messages to topics, 4) Consumers - subscribe to topics and process messages, 5) Consumer Groups - enable parallel processing and load balancing. Java integration uses Kafka client libraries: Producer: Properties props = new Properties(); props.put(\"bootstrap.servers\", \"localhost:9092\"); Producer<String, String> producer = new KafkaProducer<>(props); producer.send(new ProducerRecord<>(\"my-topic\", \"key\", \"value\"));. Consumer: KafkaConsumer<String, String> consumer = new KafkaConsumer<>(props); consumer.subscribe(Arrays.asList(\"my-topic\"));. Features include horizontal scalability, fault tolerance through replication, high throughput, message ordering within partitions, and integration with stream processing frameworks. Use cases include event sourcing, microservices communication, real-time analytics, log aggregation, and data integration. Spring Kafka provides additional abstractions with @KafkaListener annotations and template-based messaging, simplifying integration in Spring applications."
  },
  {
    "question": "What is Apache ActiveMQ and how does it implement JMS?",
    "answer": "Apache ActiveMQ is an open-source message broker implementing Java Message Service (JMS) specification, providing reliable, asynchronous communication between distributed applications. It supports both point-to-point (queues) and publish-subscribe (topics) messaging models. Key features: 1) Full JMS 2.0 compliance with support for various message types, 2) Multiple transport protocols (TCP, SSL, HTTP, WebSocket), 3) Message persistence with KahaDB or JDBC, 4) Clustering and high availability, 5) Web-based administration console, 6) Integration with application servers and Spring Framework. JMS implementation: ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\"); Connection connection = connectionFactory.createConnection(); Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); Destination destination = session.createQueue(\"test-queue\"); MessageProducer producer = session.createProducer(destination);. ActiveMQ features include message filtering with selectors, dead letter queues for failed messages, advisory messages for monitoring, and virtual destinations for advanced routing. Benefits include enterprise-grade reliability, extensive configuration options, monitoring capabilities, and proven scalability. Modern alternatives include Apache Kafka for high-throughput scenarios and cloud-based messaging services, but ActiveMQ remains popular for traditional enterprise messaging requirements."
  },
  {
    "question": "What is RabbitMQ and how does it differ from other messaging systems?",
    "answer": "RabbitMQ is a message broker implementing Advanced Message Queuing Protocol (AMQP), providing reliable messaging between applications. Key concepts: 1) Exchanges - route messages to queues based on routing rules, 2) Queues - store messages until consumed, 3) Bindings - connect exchanges to queues with routing keys, 4) Producers - send messages to exchanges, 5) Consumers - receive messages from queues. Exchange types: Direct (exact routing key match), Topic (pattern-based routing), Fanout (broadcast to all queues), Headers (attribute-based routing). Java integration uses RabbitMQ Java client or Spring AMQP: ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\"localhost\"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel();. Differences from other systems: RabbitMQ emphasizes flexible routing through exchanges vs. Kafka's simpler topic-based approach, provides stronger message delivery guarantees, supports various messaging patterns through exchange types, and offers built-in clustering and high availability. Benefits include advanced routing capabilities, message acknowledgments, clustering support, management UI, and extensive plugin ecosystem. Use RabbitMQ for complex routing requirements, traditional messaging patterns, and scenarios requiring strong delivery guarantees. Choose Kafka for high-throughput streaming and event sourcing use cases."
  },
  {
    "question": "What is microservices architecture and how does it relate to Java development?",
    "answer": "Microservices architecture decomposes applications into small, independent services that communicate over well-defined APIs. Each service is responsible for specific business capability, can be developed and deployed independently, and typically owned by a small team. Java ecosystem provides excellent support through: Spring Boot for rapid service development with embedded servers, Spring Cloud for distributed system patterns (service discovery, circuit breakers, configuration management), containerization with Docker, orchestration with Kubernetes. Key principles: 1) Business capability alignment - services organized around business functions, 2) Decentralized governance - teams choose appropriate technologies, 3) Failure isolation - service failures don't cascade, 4) Data decentralization - each service manages its own data. Benefits include independent deployment, technology diversity, fault isolation, scalability, and team autonomy. Challenges include distributed system complexity, data consistency, network latency, service discovery, and operational overhead. Java microservices patterns include API Gateway for routing, Circuit Breaker for fault tolerance, Event Sourcing for data consistency, and CQRS for read/write separation. Success requires proper tooling, monitoring, and DevOps practices for managing distributed systems complexity."
  },
  {
    "question": "What is Spring Cloud and what distributed system patterns does it provide?",
    "answer": "Spring Cloud provides tools and patterns for building distributed systems and microservices on top of Spring Boot. It addresses common challenges in distributed systems through proven patterns and implementations. Key components: 1) Service Discovery (Eureka, Consul, Zookeeper) - services register and discover each other dynamically, 2) Configuration Management (Config Server) - externalized configuration with environment-specific properties, 3) Circuit Breaker (Hystrix, Resilience4j) - fault tolerance and graceful degradation, 4) API Gateway (Spring Cloud Gateway, Zuul) - single entry point with routing, filtering, security, 5) Load Balancing (Ribbon, Spring Cloud LoadBalancer) - client-side load balancing, 6) Distributed Tracing (Sleuth, Zipkin) - request tracing across services. Additional features include distributed configuration refresh with Spring Cloud Bus, security with OAuth2 and JWT, stream processing with Spring Cloud Stream, and contract testing with Spring Cloud Contract. Benefits include simplified microservices development, battle-tested patterns, Spring ecosystem integration, and comprehensive distributed system toolkit. Spring Cloud abstracts infrastructure complexity while providing production-ready solutions for service discovery, configuration management, fault tolerance, and observability. It enables teams to focus on business logic while handling distributed system challenges through established patterns and best practices."
  },
  {
    "question": "What is the Circuit Breaker pattern and how is it implemented in Java microservices?",
    "answer": "Circuit Breaker pattern prevents cascading failures in distributed systems by monitoring service calls and 'opening' the circuit when failure threshold is reached, allowing systems to fail fast and recover gracefully. Three states: 1) Closed - normal operation, requests pass through, failures counted, 2) Open - requests fail immediately without calling service, system given time to recover, 3) Half-Open - limited requests allowed to test service recovery, transitions to Closed if successful or Open if failures continue. Java implementations include Netflix Hystrix (maintenance mode), Resilience4j (modern alternative), and Spring Cloud Circuit Breaker (abstraction layer). Resilience4j example: @Component public class UserService { private final CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults(\"userService\"); public User getUser(Long id) { Supplier<User> decoratedSupplier = CircuitBreaker.decorateSupplier(circuitBreaker, () -> userRepository.findById(id)); return decoratedSupplier.get(); } }. Configuration includes failure rate threshold, minimum request volume, wait duration, and permitted calls in half-open state. Benefits include preventing cascade failures, faster failure response, system stability, and graceful degradation. Circuit breaker is essential for microservices resilience, typically combined with retry, timeout, and fallback mechanisms for comprehensive fault tolerance."
  },
  {
    "question": "What is API Gateway pattern and why is it used in microservices architecture?",
    "answer": "API Gateway pattern provides a single entry point for all client requests in microservices architecture, acting as reverse proxy that routes requests to appropriate services while handling cross-cutting concerns. Key functions: 1) Request routing based on URL patterns, headers, or other criteria, 2) Authentication and authorization centralized across services, 3) Rate limiting and throttling to prevent abuse, 4) Request/response transformation and protocol translation, 5) Load balancing across service instances, 6) Monitoring, logging, and analytics collection, 7) Circuit breaking and fault tolerance. Benefits include simplified client interaction (single endpoint instead of multiple service URLs), centralized security and monitoring, reduced client-service coupling, protocol adaptation (HTTP to WebSocket), and consistent API versioning. Popular Java solutions include Spring Cloud Gateway (reactive, built on WebFlux), Netflix Zuul (servlet-based, older), Kong (Lua-based with Java plugins), and cloud providers' managed gateways. Implementation considerations include avoiding single point of failure through high availability deployment, minimizing latency through efficient routing, and keeping gateway lightweight to prevent bottlenecks. API Gateway is crucial for microservices architecture, providing unified access point while enabling service autonomy and independent evolution."
  },
  {
    "question": "What is Service Discovery and how is it implemented in Java microservices?",
    "answer": "Service Discovery enables services to find and communicate with each other dynamically in distributed systems without hard-coded network locations. It's essential for microservices where service instances are created and destroyed dynamically. Two patterns: 1) Client-side discovery - clients query service registry and perform load balancing, 2) Server-side discovery - load balancer queries registry and routes requests. Components include Service Registry (maintains service locations), Service Registration (services register themselves), Health Checking (monitors service health). Java implementations: Netflix Eureka - service registry server with Spring Cloud integration: @EnableEurekaServer for server, @EnableEurekaClient for clients, automatic registration with spring-cloud-starter-netflix-eureka-client. Consul - distributed service registry with health checking, key-value store, DNS interface. Spring Cloud provides abstractions: @LoadBalanced RestTemplate or WebClient for service-to-service calls using service names instead of URLs. Example: @Autowired @LoadBalanced private RestTemplate restTemplate; public User getUser(Long id) { return restTemplate.getForObject(\"http://user-service/users/\" + id, User.class); }. Benefits include dynamic service location, automatic failover, load distribution, and simplified service communication. Service discovery is fundamental for microservices scalability and resilience."
  },
  {
    "question": "What is distributed tracing and how is it implemented in Java applications?",
    "answer": "Distributed tracing tracks requests across multiple services in distributed systems, providing visibility into request flow, performance bottlenecks, and error propagation. It creates a trace (complete request journey) composed of spans (individual service operations) with unique identifiers propagated across service boundaries. Key concepts: 1) Trace ID - unique identifier for entire request, 2) Span ID - unique identifier for individual operation, 3) Parent-child relationships between spans, 4) Baggage - key-value pairs propagated across services, 5) Sampling - controlling trace collection volume. Java implementations include Spring Cloud Sleuth (automatic instrumentation), Jaeger (CNCF project), Zipkin (Twitter origin), and OpenTelemetry (vendor-neutral standard). Spring Cloud Sleuth integration: adds dependencies spring-cloud-starter-sleuth and spring-cloud-sleuth-zipkin, automatically instruments HTTP requests, database calls, message handling. Custom spans: @Autowired private Tracer tracer; public void businessOperation() { Span span = tracer.nextSpan().name(\"business-operation\").start(); try { // business logic } finally { span.end(); } }. Benefits include request flow visualization, performance analysis, error correlation across services, and debugging distributed systems. Essential for microservices observability, helping teams understand system behavior and optimize performance."
  },
  {
    "question": "What are the main challenges in microservices architecture and how are they addressed?",
    "answer": "Microservices architecture introduces several challenges that must be carefully addressed: 1) Distributed System Complexity - network latency, partial failures, eventual consistency. Solutions: circuit breakers, retries, timeouts, eventual consistency patterns, 2) Data Management - distributed transactions, data consistency across services. Solutions: Event Sourcing, CQRS, Saga pattern, eventual consistency, 3) Service Discovery - dynamic service locations, load balancing. Solutions: service registries (Eureka, Consul), client-side/server-side discovery, 4) Configuration Management - environment-specific configuration across services. Solutions: externalized configuration (Spring Cloud Config), feature flags, 5) Security - authentication/authorization across services. Solutions: OAuth2, JWT tokens, API gateways, service mesh, 6) Monitoring and Debugging - visibility across distributed system. Solutions: distributed tracing, centralized logging, metrics collection, health checks, 7) Testing - integration testing across services. Solutions: contract testing, service virtualization, test containers, 8) Deployment Complexity - coordinating deployments across services. Solutions: CI/CD pipelines, containerization, infrastructure as code. Success requires investment in tooling, monitoring, automation, and team skills in distributed systems. Many organizations find success with gradual migration from monoliths rather than complete rewrite."
  },
  {
    "question": "How do you create RESTful web services with JAX-RS annotations?",
    "answer": "JAX-RS uses annotations to map Java methods to HTTP operations. @Path defines the URI, @GET/@POST/@PUT/@DELETE map to HTTP verbs, @Produces/@Consumes set media types, and @PathParam/@QueryParam/@HeaderParam bind request data. Example: @Path(\"/users\") public class UserResource { @GET @Path(\"/{id}\") @Produces(MediaType.APPLICATION_JSON) public User getUser(@PathParam(\"id\") Long id) { return userService.findById(id); } }."
  },
  {
    "question": "What role does the Application subclass play in a JAX-RS application?",
    "answer": "A class extending javax.ws.rs.core.Application configures the JAX-RS runtime by returning a set of resource classes and providers. Register it with @ApplicationPath(\"/api\") to set the base URI."
  },
  {
    "question": "How do you handle JSON serialization in JAX-RS?",
    "answer": "Most JAX-RS implementations integrate with JSON-B or Jackson. Add the provider (e.g., JacksonFeature) to the Application or rely on auto-discovery so that Java objects are automatically converted to and from JSON."
  },
  {
    "question": "What is Spring Framework and why is it popular in Java development?",
    "answer": "Spring is a comprehensive framework providing dependency injection, aspect-oriented programming, transaction management, MVC web layer, data access abstractions, and integrations with numerous technologies. It reduces boilerplate, promotes loose coupling, and offers a large ecosystem."
  },
  {
    "question": "Explain Inversion of Control (IoC) in Spring.",
    "answer": "In Spring IoC, objects do not create or locate their dependencies; the container instantiates beans and injects their dependencies at runtime via constructors, setters, or field injection, promoting loose coupling and testability."
  },
  {
    "question": "What is the difference between @Component, @Service, @Repository, and @Controller in Spring?",
    "answer": "@Component is a generic stereotype for beans. @Service marks service-layer beans, @Repository marks data-access beans and adds exception translation, and @Controller designates MVC controllers. All are specializations of @Component for semantic clarity."
  },
  {
    "question": "How does Spring Boot simplify application configuration?",
    "answer": "Spring Boot provides opinionated auto-configuration, embedded servers, and starter dependencies that eliminate XML and minimize manual setup. A single @SpringBootApplication annotation enables component scanning, auto-configuration, and property support."
  },
  {
    "question": "What is Spring Boot’s ‘starter’ concept?",
    "answer": "Starters are Maven/Gradle BOMs that bundle common dependencies for a specific feature (e.g., spring-boot-starter-web). Including a starter pulls in everything needed, reducing dependency management complexity."
  },
  {
    "question": "How do you create REST endpoints in Spring Boot?",
    "answer": "Use @RestController to mark the class and @RequestMapping or HTTP-verb shortcuts (@GetMapping, @PostMapping, etc.) to map methods. Example: @GetMapping(\"/users/{id}\") public User get(@PathVariable Long id) { return svc.find(id); }."
  },
  {
    "question": "What is Spring Data JPA and its benefit?",
    "answer": "Spring Data JPA generates repository implementations at runtime, allowing developers to define interfaces such as interface UserRepository extends JpaRepository<User,Long>. It provides CRUD methods, query derivation, pagination, and auditing with minimal code."
  },
  {
    "question": "Describe the JPA entity lifecycle states.",
    "answer": "Entities transition through New (transient), Managed (persistent), Detached, and Removed. New objects are not in persistence context; persisting moves them to Managed. Managed entities are synchronized to DB on flush. Detach removes them from context; Remove marks for deletion."
  },
  {
    "question": "How does Hibernate implement lazy loading?",
    "answer": "Hibernate uses proxy objects and byte-code enhancement. Associations marked FetchType.LAZY are fetched only when accessed, triggering an additional SQL query if the session is open."
  },
  {
    "question": "What is the N+1 select problem in Hibernate and how can you solve it?",
    "answer": "Fetching a parent list lazily may trigger one query for parents and N queries for children. Solutions include JOIN FETCH in JPQL, @BatchSize, entity graphs, or FetchMode.SUBSELECT."
  },
  {
    "question": "Explain first-level and second-level caches in Hibernate.",
    "answer": "First-level cache is the session-scoped persistence context; every entity retrieved is stored there until session ends. Second-level cache is optional, shared across sessions, and backed by providers like EHCache or Infinispan to reduce DB hits for read-mostly data."
  },
  {
    "question": "What is Maven and how does it differ from Ant?",
    "answer": "Maven is a build automation and dependency-management tool using declarative POM files, standardized lifecycle phases, and a central repository. Ant is procedural, relies on verbose XML scripts, and lacks built-in dependency management."
  },
  {
    "question": "Describe the standard Maven project directory structure.",
    "answer": "Key folders: src/main/java (source), src/main/resources (non-code resources), src/test/java (tests), src/test/resources, and pom.xml at root. Compiled classes go to target/."
  },
  {
    "question": "How does Maven handle transitive dependencies?",
    "answer": "When project A depends on B which depends on C, Maven automatically includes C. Conflicts are resolved by nearest-definition wins or by explicit <dependencyManagement> versions."
  },
  {
    "question": "Why might you choose Gradle over Maven?",
    "answer": "Gradle offers a flexible Groovy/Kotlin DSL, incremental builds, daemon for speed, and fine-grained task configuration. It integrates strongly with Android and supports Maven/Ivy repositories."
  },
  {
    "question": "How do you run unit tests during a Maven build?",
    "answer": "Tests under src/test/java are executed in the test phase via the Surefire plugin. mvn test runs unit tests; mvn verify executes all tests and integration-test phases."
  },
  {
    "question": "What is JUnit 5’s Jupiter API?",
    "answer": "JUnit 5 splits into Platform, Vintage, and Jupiter. Jupiter provides new annotations (@Test, @DisplayName, @Nested, @ParameterizedTest), dynamic tests, and improved extension model replacing JUnit 4 runners."
  },
  {
    "question": "Explain mocking and when to use Mockito.",
    "answer": "Mocking replaces real dependencies with programmable fakes to isolate the unit under test. Mockito allows creating mocks, stubbing behavior (when(...).thenReturn(...)), and verifying interactions without hitting external systems."
  },
  {
    "question": "What is the Arrange-Act-Assert pattern in testing?",
    "answer": "Arrange: set up data and mocks; Act: invoke the method under test; Assert: verify outcomes. This structure improves readability and separates test concerns."
  },
  {
    "question": "How do you test Spring components with @SpringBootTest?",
    "answer": "@SpringBootTest loads the full application context for integration tests. Combine with @AutoConfigureMockMvc to test controllers via MockMvc without starting a real server."
  },
  {
    "question": "Describe Log4j2’s logging levels.",
    "answer": "Order from most to least severe: FATAL, ERROR, WARN, INFO, DEBUG, TRACE. Messages at a level are logged if that level or lower is enabled in configuration."
  },
  {
    "question": "What is SLF4J and why use it?",
    "answer": "SLF4J is a façade allowing code to log via a consistent API while binding at runtime to underlying implementations like Log4j2 or Logback, decoupling application code from logging framework choice."
  },
  {
    "question": "How do you externalize configuration in Spring Boot?",
    "answer": "Spring Boot reads properties from application.properties or application.yml, environment variables, command-line args, and externalized config files. @ConfigurationProperties maps groups of properties to typed beans."
  },
  {
    "question": "What is Spring Actuator?",
    "answer": "Spring Boot Actuator exposes production-ready endpoints (health, metrics, env, beans) via HTTP or JMX, enabling monitoring and management of applications with minimal setup."
  },
  {
    "question": "Explain the concept of microservices.",
    "answer": "Microservices architecture decomposes an application into small, independently deployable services communicating over lightweight protocols (often HTTP/REST or messaging). Each service owns its data and is developed, deployed, and scaled independently."
  },
  {
    "question": "What is Spring Cloud and how does it aid microservices?",
    "answer": "Spring Cloud builds on Spring Boot to provide distributed-system patterns: service discovery (Eureka/Consul), client-side load balancing (Ribbon), configuration server, circuit breakers (Resilience4j), API gateway (Spring Cloud Gateway), and distributed tracing (Sleuth)."
  },
  {
    "question": "How does Netflix Eureka enable service discovery?",
    "answer": "Eureka Server maintains a registry of service instances. Clients register on startup and renew leases periodically. Other services query Eureka to discover instances, enabling load balancing and resilience without hard-coded URLs."
  },
  {
    "question": "What problem does a circuit breaker solve and how is it implemented in Java?",
    "answer": "Circuit breakers prevent cascading failures by stopping calls to a failing service after a threshold of errors, allowing time for recovery. Libraries like Resilience4j or Hystrix wrap method calls, trip open on failures, and provide fallbacks."
  },
  {
    "question": "What is Docker and why use it for Java applications?",
    "answer": "Docker packages applications and dependencies into containers ensuring consistent runtime environments across development, testing, and production. It simplifies deployment, scalability, and isolation, reducing ‘works on my machine’ issues."
  },
  {
    "question": "Describe a basic Dockerfile for a Spring Boot jar.",
    "answer": "FROM eclipse-temurin:17-jre-alpine\nCOPY target/app.jar /app.jar\nEXPOSE 8080\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]"
  },
  {
    "question": "What is Kubernetes and how does it manage containerized Java apps?",
    "answer": "Kubernetes is an orchestration platform that automates deployment, scaling, and management of containers. It provides abstractions like Pods, Services, Deployments, and ConfigMaps to run Java containers reliably across clusters."
  },
  {
    "question": "Explain blue-green deployment strategy.",
    "answer": "Blue-green deployment runs two production environments: blue (current) and green (new). Traffic shifts to green after testing, enabling zero-downtime releases and easy rollback by switching traffic back to blue."
  },
  {
    "question": "What is Continuous Integration/Continuous Deployment (CI/CD)?",
    "answer": "CI/CD automates building, testing, and deploying software. CI merges code changes frequently, triggering automated builds and tests. CD automates delivery to environments, ensuring rapid, reliable releases with tools like Jenkins, GitHub Actions, or GitLab CI."
  },
  {
    "question": "How do you secure REST APIs with JWT in Spring?",
    "answer": "Issue a signed JSON Web Token after authentication. Clients include it in Authorization: Bearer <token> header. A filter validates signature and extracts user details on each request, setting authentication in SecurityContext."
  },
  {
    "question": "What is Spring Security’s filter chain?",
    "answer": "Spring Security registers a chain of servlet filters (e.g., SecurityContextPersistenceFilter, UsernamePasswordAuthenticationFilter, AuthorizationFilter). Each filter processes security aspects like authentication, CSRF, and authorization before reaching the servlet."
  },
  {
    "question": "Explain OAuth 2.0 roles: Resource Owner, Client, Authorization Server, Resource Server.",
    "answer": "Resource Owner owns data (user), Client requests access (application), Authorization Server issues tokens after user consent, Resource Server hosts protected resources and validates tokens."
  },
  {
    "question": "What is Hibernate Validator and Bean Validation (JSR 380)?",
    "answer": "Bean Validation defines annotations (@NotNull, @Size, @Email) to declare constraints on fields. Hibernate Validator is the reference implementation integrated with Spring, automatically validating request bodies and JPA entities."
  },
  {
    "question": "How does Swagger/OpenAPI help in API development?",
    "answer": "Swagger (OpenAPI specification) describes REST APIs in a machine-readable format. Tools like springdoc-openapi generate docs from code, provide interactive UI (Swagger UI), and enable client code generation."
  },
  {
    "question": "What is the difference between synchronous and asynchronous communication in microservices?",
    "answer": "Synchronous communication (HTTP/REST) waits for response, leading to tighter coupling and potential cascading latency. Asynchronous messaging (Kafka, RabbitMQ) decouples services, improves resilience and scalability but adds complexity in eventual consistency."
  },
  {
    "question": "Describe the Saga pattern for distributed transactions.",
    "answer": "Saga breaks a transaction into a series of local steps with compensating actions. Two coordination types: choreography (events trigger next step) and orchestration (central orchestrator). It maintains data consistency without 2-phase commit."
  },
  {
    "question": "What is gRPC and how does it differ from REST?",
    "answer": "gRPC is a high-performance RPC framework using Protocol Buffers for IDL and data serialization over HTTP/2, supporting bi-directional streaming and strong typing. REST is resource-oriented, text-based (JSON), over HTTP/1.1, human-readable but less efficient."
  },
  {
    "question": "What is the purpose of a message broker like Apache Kafka in microservices?",
    "answer": "Kafka enables high-throughput, fault-tolerant event streaming between services, decoupling producers and consumers, ensuring durability via replicated commit logs, and supporting replayable streams for event sourcing."
  },
  {
    "question": "Explain idempotency in REST APIs.",
    "answer": "An idempotent operation can be performed multiple times with the same effect as once. HTTP methods like GET, PUT, DELETE should be idempotent. Ensuring idempotency avoids unintended side effects from retries in unreliable networks."
  },
  {
    "question": "What are HATEOAS principles in REST?",
    "answer": "Hypermedia As The Engine Of Application State dictates that responses include links guiding clients on valid next actions, improving discoverability and decoupling client from hard-coded URI structures."
  },
  {
    "question": "How does Spring’s RestTemplate differ from WebClient?",
    "answer": "RestTemplate is synchronous/blocking, suited for traditional servlet apps. WebClient (from Spring WebFlux) supports non-blocking, reactive HTTP calls, streaming, and better fits reactive stacks and high-concurrency requirements."
  },
  {
    "question": "What is reactive programming and how is Project Reactor used in Java?",
    "answer": "Reactive programming is asynchronous, non-blocking, event-driven style dealing with data streams. Project Reactor provides Flux (0-N elements) and Mono (0-1 element) types with back-pressure support, composing async sequences with operators like map, flatMap, and zip."
  },
  {
    "question": "Explain the differences between Monolith and Microservices architectures.",
    "answer": "Monolith packages all features in one deployable unit, simplifying development and testing but complicating scaling and deployments. Microservices split functionality into independent services, enabling separate scaling but adding network latency and operational complexity."
  },
  {
    "question": "What is Spring Batch and typical use cases?",
    "answer": "Spring Batch provides reusable functions for batch processing – reading, processing, writing large datasets, checkpointing, transaction management, and job scheduling. Use cases include ETL, report generation, data migration."
  },
  {
    "question": "How can you schedule tasks in Spring?",
    "answer": "Enable scheduling with @EnableScheduling and annotate methods with @Scheduled(fixedRate=5000) or use cron expressions. For clustered environments, consider Quartz or Spring Batch with database-backed job repositories."
  },
  {
    "question": "What is the purpose of a Content Delivery Network (CDN) in web applications?",
    "answer": "A CDN caches static assets geographically closer to users, reducing latency, offloading traffic from origin servers, and improving resilience against traffic spikes or DDoS attacks."
  },
  {
    "question": "Explain the Same-Origin Policy and how CORS overcomes its limitations.",
    "answer": "Same-Origin Policy restricts scripts from interacting with resources from different origins for security. Cross-Origin Resource Sharing (CORS) allows servers to specify allowed origins via response headers (Access-Control-Allow-Origin), enabling safe cross-domain requests."
  },
  {
    "question": "What is CSRF and how does Spring Security protect against it?",
    "answer": "Cross-Site Request Forgery tricks authenticated users into performing unintended actions. Spring Security generates a unique token stored in session and verifies it on state-changing requests, blocking requests without valid tokens."
  },
  {
    "question": "Describe the OAuth 2.0 Authorization Code flow.",
    "answer": "Client redirects user to Authorization Server for consent, receives an authorization code, exchanges it (with client secret) for access token at token endpoint, then uses token to access Resource Server. Refresh tokens extend sessions without user interaction."
  },
  {
    "question": "What is OpenID Connect and how does it relate to OAuth 2.0?",
    "answer": "OpenID Connect is an identity layer built on OAuth 2.0. It adds ID tokens (JWTs) containing user identity claims and a UserInfo endpoint, enabling single sign-on while OAuth focuses on delegated authorization."
  },
  {
    "question": "What is the Twelve-Factor App methodology?",
    "answer": "It outlines best practices for cloud-native applications: codebase, dependencies, config, backing services, build-release-run, processes, port binding, concurrency, disposability, dev/prod parity, logs, and admin processes."
  },
  {
    "question": "What are packages in Java and what are their main purposes?",
    "answer": "Packages in Java are namespaces that organize related classes and interfaces, similar to folders in a file system. Main purposes include: 1) Avoiding name conflicts by providing unique namespaces, 2) Controlling access through protected and default access levels, 3) Organizing code logically for better maintainability, 4) Providing a hierarchical structure for large applications, 5) Enabling modular development where teams can work on different packages independently. Common built-in packages include java.lang (fundamental classes), java.util (collections and utilities), java.io (input/output), and java.net (networking). Custom packages are created using the package keyword and follow reverse domain naming conventions like com.company.project."
  },
  {
    "question": "What are the different access modifiers in Java and their scope?",
    "answer": "Java has four access modifiers controlling visibility: 1) private - accessible only within the same class, most restrictive, used for internal implementation details, 2) default (package-private) - accessible within the same package, no explicit keyword needed, provides package-level encapsulation, 3) protected - accessible within the same package and by subclasses in other packages, enables inheritance while maintaining some encapsulation, 4) public - accessible from anywhere, least restrictive, used for public APIs. Access levels from most to least restrictive: private → default → protected → public. Choose the most restrictive access level that still allows necessary functionality, following the principle of least privilege."
  },
  {
    "question": "What is inheritance in Java and how is it implemented?",
    "answer": "Inheritance is an OOP mechanism where a new class (subclass/child) acquires properties and methods from an existing class (superclass/parent). Implemented using the extends keyword: class Child extends Parent. Key features: 1) Code reusability - inherit fields and methods from parent, 2) Method overriding - child can provide specific implementation of parent methods, 3) IS-A relationship - child is a specialized version of parent, 4) Single inheritance - Java classes can extend only one parent class, 5) Hierarchical structure - creates class hierarchies. All Java classes implicitly inherit from Object class. Benefits include reduced code duplication, easier maintenance, and support for polymorphism. Use inheritance when there's a clear IS-A relationship between classes."
  },
  {
    "question": "What is method overriding in Java and what are its rules?",
    "answer": "Method overriding allows a subclass to provide a specific implementation of a method already defined in its superclass. Rules for overriding: 1) Method signature must be identical (name, parameters, return type), 2) Access modifier cannot be more restrictive than parent method, 3) Cannot override static, final, or private methods, 4) Must throw same or subclass exceptions, or no exceptions, 5) Use @Override annotation for compile-time checking. Runtime polymorphism is achieved through method overriding - the actual method called depends on object type, not reference type. Overriding enables dynamic method dispatch where JVM determines which method to call based on the actual object at runtime, supporting polymorphic behavior in inheritance hierarchies."
  },
  {
    "question": "What is the difference between method overloading and method overriding?",
    "answer": "Method overloading and overriding are different mechanisms: Overloading - multiple methods with same name but different parameters in the same class, resolved at compile-time (static polymorphism), return type can be different, access modifiers can vary, enables multiple ways to call a method. Example: method(int), method(String), method(int, String). Overriding - subclass provides specific implementation of parent class method, resolved at runtime (dynamic polymorphism), exact same signature required, enables runtime behavior changes. Overloading provides convenience and flexibility in method usage, while overriding enables inheritance-based polymorphism. Both contribute to Java's polymorphic capabilities but work at different times - compile-time vs runtime."
  },
  {
    "question": "What is polymorphism in Java and what are its types?",
    "answer": "Polymorphism allows objects of different classes to be treated as objects of a common base class while maintaining their specific behaviors. Types: 1) Compile-time polymorphism (static) - method overloading and operator overloading, resolved during compilation, 2) Runtime polymorphism (dynamic) - method overriding with inheritance, resolved during execution based on actual object type. Runtime polymorphism works through dynamic method dispatch where JVM calls the overridden method of the actual object, not the reference type. Benefits include code flexibility, extensibility, and maintainability. Polymorphism enables writing code that works with base class references but can handle any subclass object, supporting the open-closed principle where code is open for extension but closed for modification."
  },
  {
    "question": "What is the super keyword in Java and how is it used?",
    "answer": "The super keyword refers to the immediate parent class object and provides access to parent class members. Uses: 1) super() - calls parent class constructor, must be first statement in child constructor, 2) super.method() - calls parent class method, useful when overriding methods to extend rather than replace functionality, 3) super.field - accesses parent class field when child class has same-named field. Examples: super() calls default parent constructor, super(params) calls parameterized parent constructor, super.toString() calls parent's toString method. The super keyword is essential for proper inheritance implementation, ensuring parent class initialization and enabling method extension rather than complete replacement. It maintains the inheritance chain and allows leveraging parent class functionality."
  },
  {
    "question": "What is the this keyword in Java and its various uses?",
    "answer": "The this keyword is a reference to the current object instance within a class. Uses: 1) this.field - distinguishes instance variables from parameters or local variables with same names, 2) this.method() - calls another method of current object (optional but sometimes used for clarity), 3) this() - calls another constructor in the same class (constructor chaining), must be first statement, 4) Passing current object as parameter: method(this), 5) Returning current object for method chaining: return this. The this keyword resolves naming conflicts, enables constructor chaining for code reuse, and supports fluent interfaces. It's implicit in most method calls but becomes necessary when there's ambiguity or when you need to explicitly reference the current instance."
  },
  {
    "question": "What is constructor chaining in Java?",
    "answer": "Constructor chaining is the process of calling one constructor from another constructor within the same class or from a parent class. Types: 1) Within same class using this() - calls another constructor in same class, useful for avoiding code duplication, must be first statement, 2) Parent class using super() - calls parent constructor, ensures proper inheritance initialization, also must be first statement. Benefits include code reuse, maintaining initialization logic in one place, and ensuring proper object initialization hierarchy. Example: public Employee(String name) { this(name, 0); } calls another constructor with default salary. Constructor chaining helps create multiple initialization paths while maintaining consistency and avoiding duplicate initialization code."
  },
  {
    "question": "What is an abstract class in Java and when should you use it?",
    "answer": "An abstract class is a class declared with abstract keyword that cannot be instantiated and may contain abstract methods (methods without implementation). Characteristics: 1) Cannot create objects directly, 2) May contain abstract methods that must be implemented by subclasses, 3) Can have concrete methods with implementation, 4) Can have constructors, fields, and static methods, 5) Subclasses must implement all abstract methods or be abstract themselves. Use when: you want to share code among related classes, need to define common interface with some default behavior, want to provide common fields or methods to subclasses, need to force certain methods to be implemented. Abstract classes provide partial implementation and serve as templates for subclasses, enabling code reuse while enforcing certain contracts."
  },
  {
    "question": "What is the difference between abstract classes and interfaces?",
    "answer": "Abstract classes and interfaces both define contracts but differ significantly: Abstract classes can have concrete methods, constructors, instance variables, and any access modifiers; support single inheritance; use extends keyword; can have static and final methods. Interfaces (pre-Java 8) only had abstract methods and constants; support multiple inheritance; use implements keyword; methods are implicitly public abstract. Java 8+ interfaces can have default and static methods, Java 9+ added private methods. Use abstract classes when classes share common code and have IS-A relationship. Use interfaces when classes need common behavior but aren't necessarily related (CAN-DO relationship), or when multiple inheritance is needed. Interfaces provide better flexibility and are preferred for defining contracts in modern Java development."
  },
  {
    "question": "What are interfaces in Java and why are they important?",
    "answer": "Interfaces define contracts that classes must follow, containing method signatures that implementing classes must provide. Characteristics: 1) All methods implicitly public abstract (pre-Java 8), 2) All variables implicitly public static final, 3) Classes implement interfaces using implements keyword, 4) Support multiple inheritance - class can implement multiple interfaces, 5) Cannot be instantiated but can be used as reference types. Importance: enable multiple inheritance of behavior, provide abstraction and loose coupling, support polymorphism, define clear contracts between classes, enable design patterns like Strategy and Observer. Modern interfaces (Java 8+) can have default and static methods, making them more powerful while maintaining backward compatibility. Interfaces are fundamental to Java's design philosophy and enable flexible, maintainable code architectures."
  },
  {
    "question": "What are default methods in interfaces and why were they introduced?",
    "answer": "Default methods in interfaces (Java 8+) provide method implementations directly in interfaces using the default keyword. Purpose: 1) Enable interface evolution without breaking existing implementations, 2) Support functional programming features, 3) Allow multiple inheritance of behavior, 4) Reduce code duplication across implementations. Example: default void commonMethod() { /* implementation */ }. Benefits include backward compatibility when adding new methods to interfaces, reduced boilerplate code in implementing classes, and support for mixin-like behavior. Conflict resolution rules: class methods override interface defaults, more specific interface defaults win, explicit override required for ambiguity. Default methods revolutionized interface design by allowing concrete implementations while maintaining the interface contract, enabling evolution of APIs without breaking changes."
  },
  {
    "question": "What are static methods in interfaces and how do they differ from default methods?",
    "answer": "Static methods in interfaces (Java 8+) belong to the interface itself, not to implementing classes. Characteristics: 1) Cannot be inherited or overridden by implementing classes, 2) Called using InterfaceName.methodName() syntax, 3) Cannot be called on implementing class instances, 4) Useful for utility methods related to the interface. Differences from default methods: static methods aren't inherited, cannot be overridden, belong to interface not instances, no conflict resolution needed since they're not inherited. Use cases include utility functions, factory methods, helper methods for default method implementations. Example: interface Comparator has static method naturalOrder(). Static interface methods provide namespace organization and logical grouping of related functionality without separate utility classes."
  },
  {
    "question": "What is encapsulation in Java and how is it achieved?",
    "answer": "Encapsulation is the OOP principle of bundling data (fields) and methods that operate on that data within a single unit (class) while hiding internal implementation details. Achieved through: 1) Private fields - hide internal state from external access, 2) Public methods (getters/setters) - controlled access to private data, 3) Access modifiers - control visibility of class members, 4) Method-based interaction - clients interact through methods, not direct field access. Benefits include data security, code maintainability, implementation flexibility, and reduced coupling. Encapsulation enables information hiding where internal representation can change without affecting external code. Well-encapsulated classes have clear interfaces, validate data through methods, and maintain object invariants. It's fundamental to creating robust, maintainable object-oriented systems."
  },
  {
    "question": "What are getter and setter methods and what are their best practices?",
    "answer": "Getter and setter methods provide controlled access to private fields, enabling encapsulation. Getter methods retrieve field values, setter methods modify field values with validation opportunities. Best practices: 1) Use meaningful names (getName(), setName()), 2) Keep getters simple without side effects, 3) Validate input in setters, 4) Return defensive copies for mutable objects, 5) Consider immutability instead of setters when possible, 6) Don't provide setters for fields that shouldn't be modified, 7) Use appropriate return types (boolean methods start with 'is' or 'has'). Modern alternatives include records (Java 14+) for simple data holders, builder pattern for complex construction, and property-based frameworks. While getters/setters are common, avoid creating them unnecessarily - only provide access methods that are actually needed for the class's public interface."
  },
  {
    "question": "What is the final keyword in Java and its different uses?",
    "answer": "The final keyword indicates that something cannot be changed or overridden. Uses: 1) final variables - value cannot be reassigned after initialization, creates constants for primitives and immutable references for objects, 2) final methods - cannot be overridden by subclasses, ensures method behavior remains unchanged, 3) final classes - cannot be extended (e.g., String, Integer), prevents inheritance, 4) final parameters - method parameters cannot be reassigned within method. Benefits include immutability, security, optimization opportunities for JVM, and design clarity. final variables must be initialized either at declaration or in constructor. For objects, final makes the reference immutable but not the object itself. Use final to communicate intent, improve security, enable optimizations, and prevent unintended modifications or inheritance."
  },
  {
    "question": "What is the static keyword in Java and its various applications?",
    "answer": "The static keyword indicates that a member belongs to the class itself rather than to any instance. Applications: 1) static variables - shared among all instances, class-level data, initialized once when class loads, 2) static methods - called without creating instances, cannot access instance variables, utility methods, 3) static blocks - execute when class loads, used for static initialization, 4) static nested classes - belong to outer class, can access outer class static members. Characteristics: loaded when class first used, shared memory location, cannot access instance members directly, accessed using ClassName.member syntax. Common uses include constants (static final), utility methods (Math.max()), counters, and shared resources. static members exist independently of instances and are useful for class-level functionality that doesn't require object state."
  },
  {
    "question": "What are static blocks in Java and when are they executed?",
    "answer": "Static blocks (also called static initializers) are code blocks that execute when a class is first loaded by JVM, before any instance creation or static method calls. Syntax: static { /* initialization code */ }. Execution rules: 1) Execute in order they appear in class, 2) Execute only once per class loading, 3) Execute before any static method calls or instance creation, 4) Cannot access instance variables or methods, 5) Can throw exceptions but must handle checked exceptions. Use cases include: complex static variable initialization, loading configuration files, registering drivers, initializing static collections with complex logic. Multiple static blocks are allowed and execute in source order. Static blocks provide a way to perform one-time class-level initialization that's more complex than simple variable assignment."
  },
  {
    "question": "What is a nested class in Java and what are its types?",
    "answer": "Nested classes are classes defined within other classes, providing logical grouping and encapsulation. Types: 1) Static nested classes - declared with static keyword, can access outer class static members only, instantiated without outer class instance, 2) Inner classes (non-static) - have access to all outer class members including private, require outer class instance to exist, 3) Local classes - defined within methods, have access to final/effectively final local variables, 4) Anonymous classes - unnamed classes for immediate use, often for interfaces or abstract classes. Benefits include logical grouping, encapsulation, access to private members, and code organization. Use static nested classes for utility classes, non-static inner classes when inner class needs outer instance, local classes for method-specific functionality, and anonymous classes for simple implementations."
  },
  {
    "question": "What are anonymous classes in Java and when are they useful?",
    "answer": "Anonymous classes are unnamed classes that extend a class or implement an interface, defined and instantiated in a single expression. Characteristics: 1) No explicit class name, 2) Created at point of use, 3) Can access final or effectively final variables from enclosing scope, 4) Cannot have constructors (use instance initializers), 5) Cannot be static. Common uses: event handling in GUI applications, implementing interfaces on-the-fly, providing implementations for abstract classes, callback mechanisms. Example: new ActionListener() { public void actionPerformed(ActionEvent e) { /* implementation */ } }. Benefits include reduced code verbosity for simple implementations and keeping implementation close to usage. However, lambda expressions (Java 8+) are preferred for functional interfaces as they're more concise and readable. Anonymous classes are still useful for complex implementations requiring multiple methods."
  },
  {
    "question": "What are lambda expressions in Java and how do they relate to functional interfaces?",
    "answer": "Lambda expressions (Java 8+) provide a concise way to represent anonymous functions, enabling functional programming style. Syntax: (parameters) -> expression or (parameters) -> { statements }. They can only be used with functional interfaces (interfaces with single abstract method). Examples: x -> x * 2, (x, y) -> x + y, () -> System.out.println(\"Hello\"). Benefits include concise code, improved readability, better support for parallel processing, and functional programming patterns. Lambda expressions work through target typing - compiler infers the functional interface type from context. They capture variables from enclosing scope (closure) but variables must be final or effectively final. Common with Stream API, event handling, and callback scenarios. Lambda expressions enable writing more expressive, functional-style code while maintaining Java's strong typing."
  },
  {
    "question": "What are functional interfaces in Java and can you provide examples?",
    "answer": "Functional interfaces have exactly one abstract method and can be used with lambda expressions. Annotated with @FunctionalInterface (optional but recommended). Built-in examples: 1) Predicate<T> - boolean test(T t), used for filtering, 2) Function<T,R> - R apply(T t), transforms input to output, 3) Consumer<T> - void accept(T t), performs action without return, 4) Supplier<T> - T get(), supplies values without input, 5) Comparator<T> - int compare(T o1, T o2), comparison logic, 6) Runnable - void run(), executable code. Can have default and static methods alongside the single abstract method. Custom functional interfaces can be created: @FunctionalInterface interface Calculator { int calculate(int a, int b); }. Functional interfaces enable lambda expressions, method references, and functional programming patterns, making code more expressive and supporting Stream API operations."
  },
  {
    "question": "What are method references in Java and what are their types?",
    "answer": "Method references (Java 8+) provide shorthand notation for lambda expressions that simply call an existing method. Types: 1) Static method reference - ClassName::methodName (e.g., Math::max), 2) Instance method reference of particular object - instance::methodName (e.g., System.out::println), 3) Instance method reference of arbitrary object - ClassName::methodName (e.g., String::length), 4) Constructor reference - ClassName::new (e.g., ArrayList::new). Method references make code more readable when lambda expression only calls a single method. They work with functional interfaces just like lambda expressions. Examples: list.stream().filter(String::isEmpty), list.stream().map(Object::toString), list.sort(String::compareToIgnoreCase). Method references promote code reuse and readability by referencing existing methods rather than writing new lambda expressions."
  },
  {
    "question": "What is the Stream API in Java and what are its key characteristics?",
    "answer": "Stream API (Java 8+) provides functional approach to processing collections of data using declarative style. Key characteristics: 1) Lazy evaluation - operations only execute when terminal operation called, 2) Functional programming - immutable, side-effect free operations, 3) Pipeline processing - chain operations together, 4) Parallel processing support - easy parallel execution, 5) Not data structures - provide view of data source. Two operation types: intermediate (return streams, lazy) and terminal (return results, trigger execution). Benefits include more readable code, easier parallel processing, functional programming support, and optimized processing through lazy evaluation. Streams support filtering, mapping, reducing, and collecting operations. They enable processing large datasets efficiently and writing more expressive, maintainable code for data manipulation tasks."
  },
  {
    "question": "What are intermediate and terminal operations in Java Streams?",
    "answer": "Stream operations are categorized by their behavior and return types: Intermediate operations transform streams and return new streams, enabling method chaining. They're lazy (not executed until terminal operation). Examples: filter() - selects elements, map() - transforms elements, sorted() - orders elements, distinct() - removes duplicates, limit() - truncates stream, skip() - skips elements. Terminal operations produce results and trigger stream pipeline execution. Examples: collect() - accumulates to collections, forEach() - performs action on elements, reduce() - combines elements, count() - counts elements, findFirst()/findAny() - retrieves elements, anyMatch()/allMatch()/noneMatch() - tests conditions. Pipeline: source.stream().filter().map().collect(). Lazy evaluation means intermediate operations are optimized and only necessary elements are processed, improving performance."
  },
  {
    "question": "What is the difference between map() and flatMap() in Java Streams?",
    "answer": "map() and flatMap() both transform stream elements but handle nested structures differently: map() applies function to each element producing one-to-one transformation, creates Stream<R> from Stream<T>. Example: Stream.of(\"hello\", \"world\").map(String::toUpperCase) produces Stream<String> with [\"HELLO\", \"WORLD\"]. flatMap() applies function that returns streams and flattens results into single stream, handles one-to-many transformations. Example: Stream.of([\"hello\", \"world\"], [\"java\", \"streams\"]).flatMap(Arrays::stream) produces Stream<String> with [\"hello\", \"world\", \"java\", \"streams\"]. Use map() for simple transformations, flatMap() when transformation function returns collections/streams or when dealing with nested structures. flatMap() is essential for avoiding Stream<Stream<T>> scenarios and processing hierarchical data structures effectively."
  },
  {
    "question": "How do you perform parallel processing with Java Streams?",
    "answer": "Java Streams support parallel processing to utilize multiple CPU cores through parallelStream() or parallel() methods. Creation: collection.parallelStream() or stream.parallel(). Parallel streams use ForkJoinPool.commonPool() by default for thread management, automatically distributing operations across available threads. Example: list.parallelStream().filter(condition).map(transformation).collect(Collectors.toList()). Benefits include potential performance improvement for CPU-intensive operations on large datasets. Considerations: overhead of thread management, not always faster (especially for small datasets or I/O operations), ordering may not be preserved unless using ordered operations, operations must be stateless and side-effect free. Best practices: use for computational tasks, avoid for I/O operations, test performance gains, ensure thread safety. Parallel streams excel at CPU-intensive transformations on large datasets but should be used judiciously."
  },
  {
    "question": "What is the Optional class in Java and how does it help with null handling?",
    "answer": "Optional<T> is a container class that may or may not contain a value, designed to handle potentially null values safely and expressively. Benefits: eliminates NullPointerException risks, makes null-handling explicit, encourages better API design, provides functional programming style for null checks. Creation: Optional.of(value) - throws if null, Optional.ofNullable(value) - handles null, Optional.empty() - empty optional. Usage methods: isPresent() - checks if value exists, ifPresent(consumer) - executes if present, orElse(defaultValue) - returns default if empty, orElseGet(supplier) - lazy default computation, orElseThrow() - throws exception if empty. Functional operations: map(), flatMap(), filter() for transformations. Use Optional for return types where null is possible, not for fields or parameters. It promotes explicit null handling and reduces null-related bugs."
  },
  {
    "question": "What are the collect() method and Collectors in Java Streams?",
    "answer": "The collect() method is terminal operation that accumulates stream elements into collections or other results using Collector implementations. Common collectors from Collectors utility class: toList(), toSet(), toMap() - convert to collections, joining() - concatenate strings, groupingBy() - group elements by classifier, partitioningBy() - split into two groups, counting() - count elements, summingInt()/averagingInt() - mathematical operations, maxBy()/minBy() - find extremes. Examples: stream.collect(Collectors.toList()), stream.collect(Collectors.groupingBy(Employee::getDepartment)), stream.collect(Collectors.joining(\", \")). Custom collectors can be created using Collector.of() for specialized accumulation. Collectors support parallel collection and can be combined for complex transformations. The collect() method is essential for converting stream results back to usable data structures while maintaining functional programming principles."
  },
  {
    "question": "What is the difference between Collection and Collections in Java?",
    "answer": "Collection and Collections serve different purposes: Collection is the root interface of the collections framework, defining basic operations like add(), remove(), size(), iterator(). It's implemented by List, Set, Queue interfaces and their concrete classes like ArrayList, HashSet. Collection represents the contract for collection classes. Collections is a utility class providing static methods for collection operations: sort(), reverse(), shuffle(), binarySearch(), max(), min(), synchronizedXXX() (thread-safe wrappers), unmodifiableXXX() (read-only views), emptyXXX() (empty collections), singletonXXX() (single-element collections). Collections cannot be instantiated (private constructor). Use Collection interface for declaring collection variables, Collections utility class for performing operations on collections. This design separates interface definition from utility operations, following separation of concerns principle."
  },
  {
    "question": "What are generics in Java and why were they introduced?",
    "answer": "Generics (Java 5+) allow classes, interfaces, and methods to work with different types while providing compile-time type safety. Syntax uses angle brackets: List<String>, Map<K,V>. Benefits: 1) Compile-time type checking - eliminates ClassCastException at runtime, 2) Elimination of type casting - no need for explicit casts, 3) Generic algorithms - single implementation works with different types, 4) Better code readability and maintainability. Type parameters use conventions: T (Type), E (Element), K (Key), V (Value), N (Number). Generics work through type erasure - generic information removed at runtime for backward compatibility. Limitations include cannot instantiate with primitive types (use wrapper classes), cannot create arrays of generic types, cannot use instanceof with generic types. Generics revolutionized Java by providing type safety without runtime overhead."
  },
  {
    "question": "What is type erasure in Java generics and what are its implications?",
    "answer": "Type erasure is the process where generic type information is removed during compilation, replacing type parameters with their bounds or Object. At runtime, List<String> and List<Integer> are both just List. Implications: 1) Cannot create arrays of generic types - new List<String>[10] is illegal, 2) Cannot use instanceof with parameterized types - obj instanceof List<String> won't compile, 3) Cannot catch generic exception types, 4) Generic type information unavailable at runtime through reflection, 5) Method overloading restrictions - cannot have methods differing only in generic parameters. Workarounds include using Class<T> parameters for type information, wildcard types for flexibility, and @SuppressWarnings for unavoidable raw type usage. Type erasure maintains backward compatibility with pre-generic Java code but limits some generic programming patterns. Understanding erasure is crucial for effective generic programming."
  },
  {
    "question": "What are bounded type parameters in Java generics?",
    "answer": "Bounded type parameters restrict the types that can be used as generic arguments using extends and super keywords. Upper bounds use extends: <T extends Number> means T must be Number or its subtype, enabling access to Number methods. Multiple bounds possible: <T extends Number & Comparable<T>>. Lower bounds use super in wildcards: <? super Integer> means unknown type that's Integer or its supertype. Examples: class NumberList<T extends Number> allows only numeric types, method <T extends Comparable<T>> enables sorting. Benefits include access to bound class methods, type safety with constraints, and expressing relationships between type parameters. Bounded parameters are essential for creating generic classes and methods that need to call specific methods on type parameters or maintain type relationships. They provide flexibility while maintaining type safety."
  },
  {
    "question": "What are wildcard types in Java generics (?, ? extends, ? super)?",
    "answer": "Wildcards represent unknown types in generics, providing flexibility when exact type isn't known. Three types: 1) Unbounded wildcard (?) - represents any type, useful when you don't need type-specific operations, read-only operations, 2) Upper bounded wildcard (? extends T) - unknown type that's T or subtype of T, used for reading/consuming data (producer scenario), 3) Lower bounded wildcard (? super T) - unknown type that's T or supertype of T, used for writing/producing data (consumer scenario). PECS principle: Producer Extends, Consumer Super - use extends when reading from structure, super when writing to structure. Examples: List<?> numbers, List<? extends Number> readOnlyNumbers, List<? super Integer> writeableIntegers. Wildcards enable flexible APIs that work with collections of related types while maintaining type safety."
  },
  {
    "question": "What are generic methods in Java and how do you define them?",
    "answer": "Generic methods introduce their own type parameters, independent of the class's generic parameters. Defined by placing type parameter declaration before return type: <T> returnType methodName(parameters). Examples: public <T> T swap(T a, T b), public <T extends Comparable<T>> T max(T a, T b). Generic methods can be static or non-static, can have bounded type parameters, and can declare multiple type parameters. Benefits: enable generic behavior in non-generic classes, provide method-specific type parameters different from class parameters, support utility methods with type safety. Type inference allows calling without explicit type specification: String result = swap(\"hello\", \"world\"); The compiler infers types from arguments. Generic methods are essential for creating flexible, reusable utility methods while maintaining type safety and avoiding code duplication."
  },
  {
    "question": "What is the diamond operator in Java generics?",
    "answer": "The diamond operator (<>) was introduced in Java 7 to reduce verbosity in generic instantiation through type inference. Instead of repeating type parameters: List<String> list = new ArrayList<String>(), you can write: List<String> list = new ArrayList<>(); The compiler infers the generic type from the left side (target type inference). Benefits include cleaner, more readable code, reduced redundancy, and maintained type safety. Works with constructors, method calls, and assignment contexts. Limitations: only works when type can be inferred from context, doesn't work with anonymous classes (prior to Java 9), sometimes requires explicit types for complex scenarios. The diamond operator significantly improved generic code readability while preserving all type safety benefits, making generic programming more accessible and less verbose."
  },
  {
    "question": "What are raw types in Java generics and why should they be avoided?",
    "answer": "Raw types are generic classes used without type parameters, treating them as they existed before generics. Example: List instead of List<String>. Raw types exist for backward compatibility with pre-Java 5 code. Problems with raw types: 1) Loss of type safety - can add wrong type elements, 2) Require explicit casting - potential ClassCastException at runtime, 3) Compiler warnings - 'unchecked' warnings, 4) Cannot benefit from generic features, 5) Mixing raw and parameterized types causes issues. Should be avoided because: defeats purpose of generics, error-prone code, potential runtime exceptions, poor code maintainability. Modern code should always use parameterized types: List<String> instead of List. Use @SuppressWarnings(\"rawtypes\") only when dealing with legacy code that cannot be updated. Raw types compromise type safety and should be eliminated in new development."
  },
  {
    "question": "What are annotations in Java and how are they used?",
    "answer": "Annotations are metadata that provide information about program elements without affecting program semantics. They don't directly impact execution but can be processed by compilers, development tools, or at runtime through reflection. Syntax: @AnnotationName or @AnnotationName(parameters). Built-in annotations include @Override (method overriding), @Deprecated (discouraged usage), @SuppressWarnings (suppress compiler warnings), @FunctionalInterface (single abstract method). Annotations can target classes, methods, fields, parameters, and other program elements. Benefits include reduced boilerplate code, improved code documentation, framework configuration, compile-time checking, and runtime processing capabilities. Modern Java frameworks heavily use annotations for configuration (Spring's @Component, @Autowired), validation (@NotNull, @Valid), and mapping (JPA's @Entity, @Table). Annotations enable declarative programming style and are essential for framework-based development."
  },
  {
    "question": "How do you create custom annotations in Java?",
    "answer": "Custom annotations are created using @interface keyword and can have elements (methods) with optional default values. Basic syntax: @interface MyAnnotation { String value(); int priority() default 1; }. Meta-annotations control annotation behavior: @Retention specifies lifetime (SOURCE, CLASS, RUNTIME), @Target specifies where annotation can be applied (TYPE, METHOD, FIELD, etc.), @Documented includes in JavaDoc, @Inherited allows inheritance by subclasses, @Repeatable allows multiple applications. Example: @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @interface TestMethod { String description() default \"\"; }. Process annotations at runtime using reflection: method.isAnnotationPresent(TestMethod.class), method.getAnnotation(TestMethod.class). Custom annotations enable creating domain-specific metadata, framework integration, and declarative programming patterns. They're essential for building frameworks and APIs that require metadata-driven behavior."
  },
  {
    "question": "What are meta-annotations in Java?",
    "answer": "Meta-annotations are annotations applied to other annotations to control their behavior and characteristics. Key meta-annotations: 1) @Retention - specifies how long annotation is retained: SOURCE (compile-time only), CLASS (in bytecode but not runtime), RUNTIME (available at runtime via reflection), 2) @Target - specifies where annotation can be applied: TYPE (classes), METHOD, FIELD, PARAMETER, CONSTRUCTOR, etc., 3) @Documented - includes annotation in JavaDoc documentation, 4) @Inherited - allows annotation to be inherited by subclasses, 5) @Repeatable - enables multiple applications of same annotation. Examples: @Retention(RetentionPolicy.RUNTIME) for runtime processing, @Target({ElementType.METHOD, ElementType.TYPE}) for methods and classes. Meta-annotations provide essential configuration for custom annotations, controlling their lifecycle, usage locations, and behavior. They enable creating well-defined, properly constrained annotations that integrate correctly with Java's annotation processing mechanisms."
  },
  {
    "question": "What is reflection in Java and what are its main uses?",
    "answer": "Reflection is the ability to inspect and manipulate classes, methods, fields, and other program elements at runtime. Main uses: 1) Framework development - dependency injection, ORM mapping, serialization, 2) Testing - accessing private members, mock creation, 3) Development tools - IDEs, debuggers, code analysis, 4) Dynamic loading and instantiation, 5) Annotation processing at runtime. Key classes: Class (represents classes), Method (represents methods), Field (represents fields), Constructor (represents constructors). Operations include getting class information, invoking methods dynamically, accessing/modifying fields, creating instances. Example: Class<?> clazz = obj.getClass(); Method method = clazz.getMethod(\"methodName\"); method.invoke(obj). Benefits include runtime flexibility, framework capabilities, and dynamic behavior. Drawbacks include performance overhead, security risks, and complexity. Reflection is powerful but should be used judiciously due to performance and security implications."
  },
  {
    "question": "What are the performance implications of using reflection in Java?",
    "answer": "Reflection has significant performance implications compared to direct method calls: 1) Method invocation overhead - reflective calls are 10-100x slower than direct calls due to method lookup, security checks, and boxing/unboxing, 2) JVM optimization limitations - JIT compiler cannot optimize reflective calls as effectively, 3) Security checks - additional permission checks for accessing private members, 4) Object creation - creating Method, Field objects requires allocation, 5) Exception handling overhead - reflective operations may throw checked exceptions. Performance tips: cache Class, Method, Field objects instead of looking up repeatedly, use MethodHandle (Java 7+) for better performance than Method.invoke(), consider alternatives like code generation or interfaces, profile reflective code to identify bottlenecks, use reflection judiciously in performance-critical paths. Despite overhead, reflection is essential for frameworks and should be optimized rather than avoided entirely. Modern JVMs optimize reflection better than earlier versions."
  },
  {
    "question": "What are the security concerns when using reflection in Java?",
    "answer": "Reflection poses several security risks that must be carefully managed: 1) Access control bypass - can access private fields and methods, potentially exposing sensitive data or breaking encapsulation, 2) Security manager restrictions - may need configuration to allow reflective access, 3) Injection attacks - using reflection with user-provided class names or method names can enable code injection, 4) Privilege escalation - accessing restricted APIs or system properties, 5) Breaking immutability - modifying final fields through reflection. Mitigation strategies: validate all inputs when using reflection dynamically, implement proper security policies and permissions, avoid reflection with untrusted data, use SecurityManager restrictions, sanitize class and method names from external sources, consider alternatives like interfaces or dependency injection. Modern Java (9+) modules and strong encapsulation provide better security controls. Reflection should be used with careful consideration of security implications, especially in applications handling untrusted input or running in security-sensitive environments."
  },
  {
    "question": "What is exception chaining in Java and how do you implement it?",
    "answer": "Exception chaining is the ability to associate one exception with another exception, creating a chain of exceptions that shows the complete path of error propagation. This is done using the 'cause' parameter in exception constructors or the initCause() method. Exception chaining helps in debugging by preserving the original exception information while wrapping it in a more appropriate exception for the current context. Example: throw new ServiceException(\"Service failed\", originalException). The getCause() method can be used to retrieve the underlying cause. This technique is useful when you want to translate low-level exceptions into higher-level ones while maintaining the original error context."
  },
  {
    "question": "What are custom exceptions in Java and when should you create them?",
    "answer": "Custom exceptions are user-defined exception classes that extend either Exception (for checked exceptions) or RuntimeException (for unchecked exceptions). Create custom exceptions when: 1) You need domain-specific error handling, 2) Built-in exceptions don't adequately describe the error condition, 3) You want to provide additional context or methods, 4) You need to distinguish between different types of errors in your application. Example: class InsufficientFundsException extends Exception { private double deficit; public InsufficientFundsException(String message, double deficit) { super(message); this.deficit = deficit; } }. Custom exceptions improve code readability, enable specific error handling strategies, and provide better debugging information."
  },
  {
    "question": "What is the difference between throw and throws in Java?",
    "answer": "The 'throw' keyword is used to explicitly throw an exception from within a method or block of code, followed by an instance of an exception object. The 'throws' keyword is used in method declarations to specify that the method might throw certain checked exceptions. Key differences: throw is used for actual exception throwing (throw new IllegalArgumentException()), throws is used for exception declaration (public void method() throws IOException), throw is followed by an exception instance, throws is followed by exception class names, throw is used inside method body, throws is used in method signature. You can throw only one exception at a time with throw, but can declare multiple exceptions with throws."
  },
  {
    "question": "What happens when an exception is not caught in Java?",
    "answer": "When an exception is not caught, it propagates up the call stack until it either finds a matching catch block or reaches the main method. If no handler is found: 1) The thread terminates abnormally, 2) The JVM prints the exception stack trace to the error stream, 3) For the main thread, the entire program terminates, 4) For other threads, only that thread terminates while the program continues. The default exception handler (UncaughtExceptionHandler) can be set to customize this behavior. Uncaught checked exceptions prevent compilation, while uncaught runtime exceptions cause runtime termination. This mechanism ensures that errors don't go unnoticed and provides debugging information through stack traces."
  },
  {
    "question": "What is the try-with-resources statement in Java?",
    "answer": "Try-with-resources is a feature introduced in Java 7 that automatically manages resources that implement AutoCloseable or Closeable interfaces. Syntax: try (ResourceType resource = new ResourceType()) { // use resource }. Benefits include: automatic resource cleanup, elimination of explicit finally blocks for resource management, proper handling of exceptions during resource closing, cleaner and more readable code. If exceptions occur in both try block and during resource closing, the original exception is preserved and closing exceptions are suppressed (accessible via getSuppressed()). Multiple resources can be declared: try (FileReader fr = new FileReader(\"file.txt\"); BufferedReader br = new BufferedReader(fr)). This feature significantly reduces boilerplate code and prevents resource leaks."
  },
  {
    "question": "What is the File class in Java and what are its main operations?",
    "answer": "The File class represents file and directory pathnames in a platform-independent way. It provides methods to interact with the file system without actually reading or writing file contents. Main operations include: 1) File information: exists(), isFile(), isDirectory(), canRead(), canWrite(), length(), lastModified(), 2) File operations: createNewFile(), delete(), renameTo(), 3) Directory operations: mkdir(), mkdirs(), list(), listFiles(), 4) Path operations: getName(), getParent(), getAbsolutePath(), getCanonicalPath(). Example: File file = new File(\"document.txt\"); if (file.exists()) { System.out.println(\"Size: \" + file.length()); }. The File class is essential for file system operations and metadata access in Java applications."
  },
  {
    "question": "How do you read and write files in Java using byte streams?",
    "answer": "Byte streams handle raw binary data using InputStream and OutputStream classes. For reading: use FileInputStream with read() methods. For writing: use FileOutputStream with write() methods. Example: FileInputStream fis = new FileInputStream(\"input.dat\"); FileOutputStream fos = new FileOutputStream(\"output.dat\"); byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = fis.read(buffer)) != -1) { fos.write(buffer, 0, bytesRead); }. Always close streams in finally blocks or use try-with-resources. Byte streams are suitable for binary files like images, videos, executables. BufferedInputStream and BufferedOutputStream provide buffering for better performance. These streams work with raw bytes and don't perform character encoding/decoding."
  },
  {
    "question": "How do you read and write files in Java using character streams?",
    "answer": "Character streams handle text data using Reader and Writer classes, automatically managing character encoding. For reading: use FileReader or InputStreamReader. For writing: use FileWriter or OutputStreamWriter. Example: FileReader fr = new FileReader(\"input.txt\"); FileWriter fw = new FileWriter(\"output.txt\"); int character; while ((character = fr.read()) != -1) { fw.write(character); }. BufferedReader and BufferedWriter provide buffering and additional methods like readLine(). Character streams are ideal for text files as they handle character encoding automatically. Use InputStreamReader/OutputStreamWriter when you need to specify character encoding explicitly: new InputStreamReader(new FileInputStream(\"file.txt\"), \"UTF-8\")."
  },
  {
    "question": "What is the difference between BufferedReader and Scanner for file reading?",
    "answer": "BufferedReader and Scanner serve different purposes for file reading: BufferedReader is optimized for efficient text reading, provides readLine() method, has lower memory overhead, faster for large files, works with any Reader, suitable for line-by-line processing. Scanner provides parsing capabilities, can tokenize input using delimiters, has methods like nextInt(), nextDouble(), hasNext(), more convenient for formatted input, higher overhead due to parsing features. Use BufferedReader for: simple text reading, large files, performance-critical applications. Use Scanner for: parsing structured data, reading different data types, when convenience is more important than performance. Example: BufferedReader br = new BufferedReader(new FileReader(\"file.txt\")); vs Scanner scanner = new Scanner(new File(\"file.txt\"))."
  },
  {
    "question": "What is serialization in Java and how does it work?",
    "answer": "Serialization is the process of converting Java objects into a byte stream for storage or transmission. The object must implement the Serializable interface. Process: 1) Object → byte stream (marshalling), 2) Byte stream → Object (unmarshalling). Use ObjectOutputStream.writeObject() for serialization and ObjectInputStream.readObject() for deserialization. Example: ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"data.ser\")); oos.writeObject(myObject); Features include: automatic handling of object graphs, preservation of object state, transient keyword excludes fields, serialVersionUID maintains version compatibility. Serialization is useful for caching, deep copying, network communication, and persistence. However, it has security implications and performance overhead."
  },
  {
    "question": "What is the purpose of serialVersionUID in Java serialization?",
    "answer": "serialVersionUID is a unique identifier for each Serializable class used during deserialization to verify version compatibility. When deserializing, the JVM compares the serialVersionUID of the serialized object with the current class definition. If they don't match, InvalidClassException is thrown. Purpose: 1) Version control for serialized objects, 2) Backward compatibility assurance, 3) Prevention of deserialization errors when class structure changes. Best practice: explicitly declare as static final long field rather than relying on automatically generated values. Example: private static final long serialVersionUID = 1L; This ensures consistent behavior across different JVM implementations and compiler versions, and prevents issues when class definitions are modified."
  },
  {
    "question": "What fields are not serialized in Java serialization?",
    "answer": "Several types of fields are not serialized in Java: 1) transient fields - explicitly marked to exclude from serialization, 2) static fields - belong to class, not instance, 3) Fields in non-serializable parent classes - unless parent implements Serializable. The transient keyword is most commonly used: transient String temporaryData; Use cases for transient: sensitive data (passwords), derived/calculated fields, cache data, non-serializable objects. During deserialization, transient fields are initialized to default values (null for objects, 0 for numbers, false for boolean). If you need custom serialization logic, implement writeObject() and readObject() methods to handle transient fields specially. This selective serialization helps reduce object size and prevents serialization of unnecessary or sensitive data."
  },
  {
    "question": "What is externalization in Java and how does it differ from serialization?",
    "answer": "Externalization is a customized form of serialization where the programmer has complete control over the serialization process by implementing the Externalizable interface. Key differences: Externalization requires explicit implementation of writeExternal() and readExternal() methods, provides full control over what gets serialized, typically more efficient and produces smaller output, requires more programming effort. Serialization uses automatic process, handles all non-transient fields automatically, easier to implement but less control, larger serialized output. Example: public void writeExternal(ObjectOutput out) throws IOException { out.writeUTF(name); out.writeInt(age); } Use externalization when: you need optimal performance, want minimal serialized size, need custom serialization logic, or have complex object structures requiring specific handling."
  },
  {
    "question": "What is the Collections Framework in Java?",
    "answer": "The Collections Framework is a unified architecture for representing and manipulating collections of objects. It provides: 1) Interfaces - define abstract data types (Collection, List, Set, Map, Queue), 2) Implementations - concrete classes (ArrayList, HashMap, TreeSet), 3) Algorithms - static methods for operations (sorting, searching), 4) Utilities - helper classes and methods. Key interfaces: Collection (root interface), List (ordered, allows duplicates), Set (no duplicates), Map (key-value pairs), Queue (FIFO operations). Benefits include: reduced programming effort, increased performance through optimized implementations, interoperability between APIs, reduced effort to learn new APIs. The framework promotes code reuse and provides high-performance implementations of useful data structures and algorithms."
  },
  {
    "question": "What is the difference between Collection and Collections in Java?",
    "answer": "Collection is the root interface of the Collections Framework, defining basic operations for groups of objects like add(), remove(), size(), iterator(). It's implemented by List, Set, Queue interfaces. Collections is a utility class providing static methods for collection operations: sort(), reverse(), shuffle(), binarySearch(), synchronizedXXX(), unmodifiableXXX(), emptyXXX(). Key differences: Collection is an interface for defining collection contracts, Collections is a utility class for performing operations. Collection represents the abstract concept of a collection, Collections provides concrete algorithms and utilities. You implement Collection interface in your classes, you call Collections static methods on collection instances. Example: Collection<String> list vs Collections.sort(list). This separation follows good design principles by separating interface definition from utility operations."
  },
  {
    "question": "What are the main differences between ArrayList and LinkedList?",
    "answer": "ArrayList and LinkedList are both List implementations but have different internal structures and performance characteristics: ArrayList uses dynamic array (resizable array), provides O(1) random access via get(index), O(1) amortized insertion at end, O(n) insertion/deletion in middle due to shifting, better memory locality for iteration, lower memory overhead per element. LinkedList uses doubly-linked list, provides O(n) random access, O(1) insertion/deletion at known positions, O(1) insertion/deletion at ends, higher memory overhead due to node pointers. Use ArrayList for: frequent random access, iteration-heavy operations, memory-constrained environments. Use LinkedList for: frequent insertions/deletions in middle, implementing queue/deque, when order of operations matters more than random access. ArrayList is generally preferred due to better cache performance and lower memory usage."
  },
  {
    "question": "What is the difference between HashMap and Hashtable?",
    "answer": "HashMap and Hashtable are both hash-based Map implementations but have several key differences: HashMap is not synchronized (not thread-safe), allows one null key and multiple null values, faster performance due to no synchronization overhead, introduced in Java 1.2 as part of Collections Framework, uses fail-fast iterators. Hashtable is synchronized (thread-safe), doesn't allow null keys or values, slower due to synchronization, legacy class from Java 1.0, uses fail-safe enumerators. HashMap is preferred for single-threaded applications or when external synchronization is provided. For thread-safety, use ConcurrentHashMap instead of Hashtable as it provides better performance through segment-based locking. Hashtable is largely considered legacy and should be avoided in new code development."
  },
  {
    "question": "What is ConcurrentHashMap and how does it achieve thread safety?",
    "answer": "ConcurrentHashMap is a thread-safe Map implementation that provides better concurrency than synchronized maps. Thread safety mechanisms: Java 7 and earlier used segment-based locking (dividing map into segments with separate locks), Java 8+ uses node-based locking with CAS operations and synchronized blocks on individual nodes. Key features: 1) Lock-free reads - get operations don't require locks, 2) Limited concurrent writes - multiple threads can write to different parts simultaneously, 3) Fail-safe iterators - don't throw ConcurrentModificationException, 4) Atomic operations - putIfAbsent(), replace(), compute() methods, 5) Scalable performance - performance scales with thread count. ConcurrentHashMap provides much better throughput than Hashtable or Collections.synchronizedMap() in multi-threaded environments while maintaining thread safety guarantees."
  },
  {
    "question": "What is the difference between HashSet and TreeSet?",
    "answer": "HashSet and TreeSet are both Set implementations but use different data structures and have different characteristics: HashSet uses hash table for storage, provides O(1) average time complexity for basic operations (add, remove, contains), doesn't maintain any order of elements, allows null values, based on equals() and hashCode(). TreeSet uses red-black tree (balanced BST), provides O(log n) time complexity for basic operations, maintains sorted order of elements (natural or custom comparator), doesn't allow null values, elements must be Comparable or use custom Comparator. Use HashSet when: you need fast access without caring about order, maximum performance for basic operations. Use TreeSet when: you need sorted collection, range operations (subSet, headSet, tailSet), navigational methods (first, last, higher, lower)."
  },
  {
    "question": "What is LinkedHashSet and when would you use it?",
    "answer": "LinkedHashSet combines features of HashSet and LinkedList, maintaining insertion order while providing HashSet's performance. It uses hash table for storage with additional doubly-linked list to track insertion order. Characteristics: O(1) performance for basic operations like HashSet, maintains predictable insertion order unlike HashSet, slightly higher memory overhead due to maintaining links, allows null values, provides ordered iteration. Use LinkedHashSet when: you need unique elements (Set behavior), predictable iteration order is important, you want better performance than TreeSet for basic operations, maintaining insertion order for user interfaces or caching scenarios. Example use cases: maintaining order of user selections, LRU cache implementation, preserving order of configuration items. It's the middle ground between HashSet (fast but unordered) and TreeSet (ordered but slower)."
  },
  {
    "question": "What is PriorityQueue and how does it work?",
    "answer": "PriorityQueue is a heap-based implementation of Queue interface where elements are ordered by their priority, not insertion order. It uses binary heap data structure (implemented as array) for efficient insertion and removal of highest-priority elements. Key characteristics: head element is always the smallest (highest priority) based on natural ordering or custom Comparator, not thread-safe, doesn't allow null elements, provides O(log n) time for insertion and removal, O(1) for peek operations. Common methods: offer()/add() to insert, poll()/remove() to remove head, peek()/element() to view head without removal. Use cases: task scheduling systems, implementing Dijkstra's algorithm, finding top K elements, managing events by priority. Example: PriorityQueue<Task> taskQueue = new PriorityQueue<>(Comparator.comparing(Task::getPriority)); The queue automatically maintains heap property for efficient priority-based operations."
  },
  {
    "question": "What is the difference between Iterator and ListIterator?",
    "answer": "Iterator and ListIterator are both used for traversing collections, but ListIterator provides additional functionality: Iterator provides basic traversal with hasNext(), next(), remove() methods, works with any Collection, supports forward-only traversal, can remove elements during iteration. ListIterator extends Iterator and adds: bidirectional traversal with hasPrevious(), previous() methods, positional access with nextIndex(), previousIndex(), modification capabilities with set() and add() methods, only works with List collections. ListIterator advantages: can traverse list in both directions, can modify list during iteration (add/set elements), provides index information during iteration. Use Iterator for: simple forward traversal of any collection, basic iteration needs. Use ListIterator for: bidirectional traversal of lists, modifying lists during iteration, when you need positional information. Example: ListIterator<String> listIter = list.listIterator(); while(listIter.hasNext()) { listIter.add(\"prefix_\" + listIter.next()); }"
  },
  {
    "question": "What is the fail-fast behavior in Java collections?",
    "answer": "Fail-fast behavior means that iterators immediately throw ConcurrentModificationException when they detect that the collection has been modified during iteration (except through iterator's own methods). Mechanism: collections maintain a modification count (modCount) that's incremented with each structural modification, iterators store expected modCount and check it on each operation. Fail-fast collections include: ArrayList, HashMap, HashSet, TreeMap, TreeSet and their iterators. Purpose: early detection of concurrent modifications, preventing unpredictable behavior, helping identify threading issues. Example: List<String> list = new ArrayList<>(); for(String item : list) { list.add(\"new\"); // throws ConcurrentModificationException } To avoid: use iterator's remove() method, use concurrent collections, synchronize access, or create copy for iteration. Fail-fast behavior helps catch bugs early but requires careful handling in concurrent environments."
  },
  {
    "question": "What are concurrent collections in Java and when should you use them?",
    "answer": "Concurrent collections are thread-safe collection implementations designed for concurrent access without external synchronization. Key implementations: ConcurrentHashMap (thread-safe Map), CopyOnWriteArrayList (thread-safe List), ConcurrentLinkedQueue (thread-safe Queue), BlockingQueue implementations (ArrayBlockingQueue, LinkedBlockingQueue). Features: 1) Thread-safe operations without external synchronization, 2) Better performance than synchronized collections, 3) Fail-safe iterators (don't throw ConcurrentModificationException), 4) Lock-free or reduced locking for better scalability. Use when: multiple threads access collections concurrently, you need thread safety with good performance, avoiding explicit synchronization, building concurrent applications. Benefits over synchronized collections: better scalability, reduced contention, weakly consistent iteration. Choose based on access patterns: ConcurrentHashMap for read-heavy maps, CopyOnWriteArrayList for read-heavy lists with infrequent writes, BlockingQueue for producer-consumer scenarios."
  },
  {
    "question": "What is the difference between Comparable and Comparator interfaces?",
    "answer": "Comparable and Comparator are both used for object comparison and sorting but serve different purposes: Comparable is implemented by the class whose objects need to be sorted, provides natural ordering through compareTo() method, allows only one sorting sequence per class, compares 'this' object with another object, part of java.lang package. Comparator is a separate interface for custom comparison logic, can be implemented externally without modifying original class, allows multiple sorting strategies for same class, compares two objects passed as parameters, part of java.util package. Use Comparable for: natural ordering that makes sense for the class (String alphabetical, Integer numerical), single primary sorting criteria. Use Comparator for: multiple sorting strategies, custom sorting criteria, sorting objects you can't modify, complex sorting logic. Example: class Person implements Comparable<Person> vs Comparator<Person> ageComparator = Comparator.comparing(Person::getAge)."
  },
  {
    "question": "How do you sort collections in Java?",
    "answer": "Java provides several ways to sort collections: 1) Collections.sort(list) - sorts List of Comparable objects using natural ordering, 2) Collections.sort(list, comparator) - sorts using custom Comparator, 3) list.sort(comparator) - instance method on List (Java 8+), 4) Stream API - list.stream().sorted().collect(Collectors.toList()). For custom sorting: use Comparator with lambda expressions or method references: list.sort((a, b) -> a.getName().compareTo(b.getName())), list.sort(Comparator.comparing(Person::getName)), list.sort(Comparator.comparing(Person::getAge).thenComparing(Person::getName)). Sorting arrays: Arrays.sort(array) or Arrays.sort(array, comparator). For reverse order: Collections.reverseOrder() or Comparator.reverseOrder(). Modern approach prefers method references and chained comparators for readable, maintainable sorting code. All sorting methods use stable, efficient algorithms (typically merge sort or quicksort variants)."
  },
  {
    "question": "What is the difference between peek() and poll() methods in Queue?",
    "answer": "peek() and poll() are Queue methods for accessing the head element but behave differently: peek() retrieves but does not remove the head element, returns null if queue is empty, doesn't modify the queue state, useful for inspection without consumption. poll() retrieves and removes the head element, returns null if queue is empty, modifies the queue by removing the element, used for consuming queue elements. Similar pairs: element() vs remove() - throw exceptions instead of returning null when queue is empty. Example: Queue<String> queue = new LinkedList<>(); queue.offer(\"first\"); String head = queue.peek(); // returns \"first\", queue still contains it String removed = queue.poll(); // returns \"first\", queue is now empty. Use peek() when: checking what's next without consuming, validating queue contents, implementing algorithms that need to look ahead. Use poll() when: consuming queue elements, implementing standard queue operations, processing elements one by one."
  },
  {
    "question": "What is the difference between offer() and add() methods in Queue?",
    "answer": "offer() and add() both insert elements into a Queue but handle capacity restrictions differently: offer() attempts to insert element and returns boolean indicating success/failure, returns false if element cannot be added due to capacity restrictions, preferred method for capacity-restricted queues, graceful handling of insertion failures. add() attempts to insert element and throws exception if it fails, throws IllegalStateException if element cannot be added due to capacity restrictions, inherited from Collection interface, more aggressive error handling. For unbounded queues (like LinkedList), both methods behave identically and always succeed. For bounded queues (like ArrayBlockingQueue), offer() provides better control flow. Example: Queue<String> boundedQueue = new ArrayBlockingQueue<>(2); boolean success = boundedQueue.offer(\"item\"); // returns false if full boundedQueue.add(\"item\"); // throws exception if full. Use offer() for: bounded queues, when you want to handle insertion failures gracefully. Use add() for: unbounded queues, when insertion failure should be treated as exceptional condition."
  },
  {
    "question": "What is Deque interface and its common implementations?",
    "answer": "Deque (Double Ended Queue) extends Queue interface and supports insertion and removal of elements from both ends. It can function as both queue (FIFO) and stack (LIFO). Key methods: addFirst()/offerFirst(), addLast()/offerLast() for insertion, removeFirst()/pollFirst(), removeLast()/pollLast() for removal, peekFirst(), peekLast() for inspection, push()/pop() for stack operations. Common implementations: ArrayDeque - resizable array implementation, preferred choice for deque operations, no capacity restrictions, not thread-safe, better performance than LinkedList. LinkedList - doubly-linked list, implements both List and Deque, allows null elements, higher memory overhead. Use cases: implementing undo functionality, sliding window algorithms, breadth-first search, palindrome checking. ArrayDeque advantages: better performance, no null elements allowed, more memory efficient. LinkedList advantages: implements List interface, allows null elements. Choose ArrayDeque for pure deque operations, LinkedList when you also need List functionality."
  },
  {
    "question": "What are BlockingQueue implementations and their use cases?",
    "answer": "BlockingQueue extends Queue interface with blocking operations for thread-safe producer-consumer scenarios. Key blocking methods: put() - blocks if queue is full, take() - blocks if queue is empty, offer(timeout) - waits up to timeout, poll(timeout) - waits up to timeout. Common implementations: ArrayBlockingQueue - bounded queue backed by array, fairness option for thread ordering, fixed capacity. LinkedBlockingQueue - optionally bounded queue backed by linked nodes, higher throughput than ArrayBlockingQueue. PriorityBlockingQueue - unbounded priority queue, elements ordered by priority. SynchronousQueue - no storage capacity, direct handoff between threads. DelayQueue - elements become available after delay period. Use cases: producer-consumer patterns, thread pools (ThreadPoolExecutor uses BlockingQueue), pipeline processing, rate limiting. Benefits: automatic synchronization, blocking behavior eliminates busy waiting, various capacity and ordering options. Choose based on: bounded vs unbounded, FIFO vs priority ordering, performance requirements."
  },
  {
    "question": "What is the difference between HashMap and TreeMap?",
    "answer": "HashMap and TreeMap are both Map implementations but use different data structures and provide different characteristics: HashMap uses hash table, provides O(1) average time complexity for basic operations, no ordering of keys, allows one null key and multiple null values, based on equals() and hashCode() methods, not thread-safe. TreeMap uses red-black tree (balanced BST), provides O(log n) time complexity for basic operations, maintains sorted order of keys (natural or custom), doesn't allow null keys but allows null values, keys must be Comparable or use custom Comparator, not thread-safe. HashMap advantages: faster for basic operations, suitable when ordering isn't needed. TreeMap advantages: sorted key iteration, navigational methods (firstKey, lastKey, subMap), range operations. Use HashMap for: general-purpose mapping, performance-critical applications, when key ordering is not required. Use TreeMap for: sorted key requirements, range queries, when you need navigational operations on keys."
  },
  {
    "question": "What is WeakHashMap and when would you use it?",
    "answer": "WeakHashMap is a Map implementation that uses weak references for keys, allowing keys to be garbage collected when no strong references exist elsewhere. When a key is garbage collected, its entry is automatically removed from the map. Key characteristics: keys are weakly referenced, values are strongly referenced, automatic cleanup of entries, not thread-safe, null keys and values allowed. Use cases: implementing caches where entries should expire when keys are no longer used, preventing memory leaks in scenarios like observer patterns, associating metadata with objects temporarily, creating mappings that shouldn't prevent garbage collection. Important considerations: if values reference keys, it prevents garbage collection (memory leak), entries may disappear unexpectedly during garbage collection, not suitable when you need guaranteed key retention. Example use case: caching expensive computations associated with objects, where cache entries should be removed when objects are no longer referenced elsewhere in the application."
  },
  {
    "question": "What are EnumSet and EnumMap in Java?",
    "answer": "EnumSet and EnumMap are specialized collections designed specifically for enum types, providing high performance and type safety: EnumSet is a Set implementation for enum types, uses bit vector for internal representation, extremely efficient (faster than HashSet), provides static factory methods (allOf, noneOf, of, range), maintains natural order of enum constants, cannot contain null elements. EnumMap is a Map implementation for enum keys, uses array internally (enum ordinal as index), very fast key operations, maintains natural order of enum keys, allows null values but not null keys, all keys must be from single enum type. Benefits: superior performance compared to general-purpose collections, compact memory usage, type safety at compile time, natural ordering maintained. Use EnumSet for: sets of enum constants, bit field replacement, flag combinations. Use EnumMap for: mappings with enum keys, sparse arrays indexed by enums, configuration mappings. Example: EnumSet<Day> weekend = EnumSet.of(SATURDAY, SUNDAY); EnumMap<Status, String> statusMessages = new EnumMap<>(Status.class);"
  },
  {
    "question": "What is the difference between Arrays.asList() and Collections.singletonList()?",
    "answer": "Arrays.asList() and Collections.singletonList() both create lists but serve different purposes: Arrays.asList() creates a fixed-size list backed by the original array, can contain multiple elements, allows modification of existing elements via set(), changes reflect in both list and original array, throws UnsupportedOperationException for add/remove operations, can contain null elements. Collections.singletonList() creates an immutable list containing exactly one element, optimized for single-element use case, completely immutable (no modifications allowed), throws UnsupportedOperationException for all modification attempts, more memory efficient than other single-element lists, allows null element. Use Arrays.asList() for: converting arrays to lists, when you need list view of array data, when limited modification is acceptable. Use Collections.singletonList() for: returning single-element lists from methods, immutable single-element collections, memory-efficient single-element scenarios. Example: List<String> arrayList = Arrays.asList(\"a\", \"b\", \"c\"); List<String> singleList = Collections.singletonList(\"single\");"
  },
  {
    "question": "What are the performance characteristics of different Collection implementations?",
    "answer": "Different collection implementations have varying performance for different operations: ArrayList - O(1) random access, O(1) amortized add at end, O(n) insert/delete in middle, good iteration performance. LinkedList - O(n) random access, O(1) insert/delete at known positions, O(1) add at ends, higher memory per element. HashMap - O(1) average for get/put, O(n) worst case with poor hash function, iteration depends on capacity. TreeMap - O(log n) for get/put, sorted iteration, navigational operations. HashSet - O(1) average for add/contains/remove, based on HashMap. TreeSet - O(log n) for add/contains/remove, sorted iteration. Vector - similar to ArrayList but synchronized, performance penalty. ArrayDeque - O(1) for operations at both ends, preferred over LinkedList for deque operations. ConcurrentHashMap - O(1) average with better concurrency than synchronized HashMap. Choose based on: access patterns (random vs sequential), modification patterns (frequent inserts vs stable), concurrency requirements, memory constraints, ordering requirements."
  },
  {
    "question": "What is the diamond operator (<>) in Java generics?",
    "answer": "The diamond operator (<>) was introduced in Java 7 to reduce verbosity in generic instantiation through type inference. Instead of repeating generic type parameters on both sides: List<String> list = new ArrayList<String>(), you can write: List<String> list = new ArrayList<>(); The compiler infers the generic type from the left side (target type inference). Key features: eliminates redundant type specification, maintains compile-time type safety, works with constructors and method calls, reduces code clutter. Limitations: only works when type can be inferred from context, doesn't work with anonymous classes in Java 7 (fixed in Java 9), sometimes requires explicit types for complex scenarios. Benefits: cleaner, more readable code, less typing required, reduced chance of type mismatches, easier maintenance. Example: Map<String, List<Integer>> map = new HashMap<>(); instead of Map<String, List<Integer>> map = new HashMap<String, List<Integer>>(); The diamond operator significantly improves generic code readability while preserving type safety."
  },
  {
    "question": "What are raw types in Java generics and why should they be avoided?",
    "answer": "Raw types are generic classes or interfaces used without type parameters, essentially treating them as they existed before generics were introduced. Example: List instead of List<String>. Problems with raw types: loss of compile-time type safety, potential ClassCastException at runtime, compiler generates unchecked warnings, cannot benefit from generic type checking, mixing raw and parameterized types causes issues. Why avoid them: defeats the purpose of generics, error-prone code requiring explicit casts, no compile-time verification of type correctness, potential runtime failures, poor code maintainability. They exist solely for backward compatibility with pre-Java 5 code. Modern code should always use parameterized types: List<String> instead of List, Map<String, Integer> instead of Map. Use @SuppressWarnings(\"rawtypes\") only when dealing with legacy code that cannot be updated. Raw types compromise the type safety that generics were designed to provide and should be eliminated in new development."
  },
  {
    "question": "What are bounded type parameters in Java generics?",
    "answer": "Bounded type parameters restrict the types that can be used as generic arguments using extends and super keywords. Upper bounds use extends: <T extends Number> restricts T to Number or its subtypes, enables calling Number methods on T, multiple bounds possible with &: <T extends Number & Comparable<T>>. Lower bounds use super in wildcards: <? super Integer> restricts to Integer or its supertypes, used in consumer scenarios. Examples: class NumberList<T extends Number> - only accepts numeric types, method <T extends Comparable<T>> void sort(List<T> list) - enables sorting. Benefits: access to bound class methods and fields, type safety with meaningful constraints, expressing relationships between type parameters, enabling generic algorithms that need specific capabilities. Use cases: mathematical operations requiring Number methods, sorting requiring Comparable, collections that need specific type capabilities. Bounded parameters are essential for creating flexible yet type-safe generic classes and methods that can call specific methods on their type parameters."
  },
  {
    "question": "What are wildcard types (?, ? extends, ? super) in Java generics?",
    "answer": "Wildcards represent unknown types in generics, providing flexibility when exact type isn't known or needed. Three types: Unbounded wildcard (?) - represents any type, useful for operations that don't depend on type parameter, read-only scenarios where you only use Object methods. Upper bounded wildcard (? extends T) - unknown type that is T or subtype of T, used for reading/consuming from collections (covariance), follows 'producer extends' principle. Lower bounded wildcard (? super T) - unknown type that is T or supertype of T, used for writing/adding to collections (contravariance), follows 'consumer super' principle. PECS rule: Producer Extends, Consumer Super - use extends when reading from structure, super when writing to structure. Examples: List<?> anyList, List<? extends Number> numbers (can read Numbers), List<? super Integer> integers (can add Integers). Wildcards enable writing flexible APIs that work with families of related types while maintaining type safety."
  },
  {
    "question": "What are generic methods in Java and how do you define them?",
    "answer": "Generic methods introduce their own type parameters, independent of the class's generic parameters, enabling method-level generics. Syntax: place type parameter declaration before return type: <T> returnType methodName(parameters). The type parameter can be used in return type, parameter types, and method body. Examples: public <T> void swap(T[] array, int i, int j), public <T extends Comparable<T>> T max(T a, T b), public <K, V> Map<K, V> createMap(). Benefits: generic behavior in non-generic classes, method-specific type parameters different from class parameters, type safety without requiring generic classes, flexible utility methods. Type inference allows calling without explicit type specification: String max = max(\"hello\", \"world\"); Generic methods can be static or instance methods, can have multiple type parameters, can use bounded type parameters. They're essential for creating reusable, type-safe utility methods and enable generic programming even in non-generic classes. Collections utility methods extensively use generic methods for type-safe operations."
  },
  {
    "question": "What is type erasure in Java generics and what are its implications?",
    "answer": "Type erasure is the process where generic type information is removed during compilation, with type parameters replaced by their bounds or Object for backward compatibility. At runtime, List<String> and List<Integer> are both just List. Implications: cannot create arrays of generic types (new List<String>[10] illegal), cannot use instanceof with parameterized types (obj instanceof List<String> won't compile), cannot catch or throw generic exception types, generic type information unavailable at runtime reflection, method overloading restrictions with generic parameters. Bridge methods are generated to maintain polymorphism after erasure. Workarounds: use Class<T> parameters for runtime type information, wildcards for flexibility, @SuppressWarnings for unavoidable raw type usage, reflection with parameterized types for limited runtime type access. Type erasure enables backward compatibility with pre-generic Java code but limits some generic programming patterns. Understanding erasure is crucial for effective generic programming and avoiding common pitfalls in generic code design."
  },
  {
    "question": "What is the purpose of the equals() and hashCode() contract in Java?",
    "answer": "The equals() and hashCode() contract ensures consistent behavior in hash-based collections and object comparison. The contract states: 1) If two objects are equal according to equals(), they must have the same hashCode(), 2) If two objects have the same hashCode(), they may or may not be equal (hash collision is allowed), 3) hashCode() must be consistent during object lifetime, 4) equals() must be reflexive (x.equals(x) = true), symmetric (x.equals(y) = y.equals(x)), transitive, and consistent. Violating this contract causes incorrect behavior in HashMap, HashSet, and other hash-based collections - equal objects might be stored in different buckets, leading to duplicates in sets or inability to retrieve values from maps. Best practices: always override both methods together, use same fields in both methods, consider using Objects.equals() and Objects.hash() utility methods, make methods consistent with business logic. The contract is fundamental to proper collection behavior and object identity in Java."
  },
  {
    "question": "What happens if you override equals() but not hashCode() or vice versa?",
    "answer": "Overriding only one of equals() or hashCode() violates their contract and causes problems in hash-based collections: If you override equals() but not hashCode(): objects that are equal according to equals() may have different hash codes, violating the fundamental contract, hash-based collections like HashMap and HashSet will malfunction, equal objects might be stored in different buckets, leading to duplicates in HashSet or inability to find objects in HashMap. If you override hashCode() but not equals(): objects with same hash code might be considered unequal by equals(), causes performance degradation due to hash collisions, collections work correctly but with poor performance, multiple unequal objects clustering in same hash bucket. Example problems: Set<Person> set; set contains duplicate Person objects even though they should be equal, Map<Person, String> map cannot retrieve values for logically equal Person keys. Solution: always override both methods together, ensure they use the same significant fields, maintain the contract throughout object lifecycle. Modern IDEs can generate both methods automatically to maintain proper contract."
  },
  {
    "question": "What is the difference between == and equals() method in Java?",
    "answer": "The == operator and equals() method serve different purposes in Java: == operator: for primitives, compares actual values (5 == 5 is true), for objects, compares references/memory addresses (checks if two references point to same object), cannot be overridden, fast operation. equals() method: compares object contents for logical equality, can be overridden to define custom equality logic, inherited from Object class with default reference comparison, should be used for meaningful object comparison. Key differences: == checks identity (same object), equals() checks equality (same content), == is not polymorphic, equals() can be customized, String comparison: String s1 = \"hello\"; String s2 = \"hello\"; (s1 == s2 might be true due to string interning), String s1 = new String(\"hello\"); String s2 = new String(\"hello\"); (s1 == s2 is false, s1.equals(s2) is true). Best practice: use == for primitives and reference identity checks, use equals() for object content comparison, always check for null before calling equals(): Objects.equals(a, b) is safer than a.equals(b)."
  },
  {
    "question": "What is string interning in Java and how does it work?",
    "answer": "String interning is the process of storing only one copy of each distinct string value in the string pool (a special memory area in heap). When creating string literals, JVM checks the string pool first - if the string exists, it returns reference to existing string; otherwise, creates new string and adds to pool. Process: compile-time literals automatically interned, runtime strings can be interned using intern() method, pool is implemented as hash table for fast lookup, garbage collection can clean up unused interned strings (Java 7+). Benefits: memory savings by avoiding duplicate strings, faster string comparison using == for interned strings, reduced memory allocation overhead. Drawbacks: intern() method has performance overhead, overuse can lead to memory leaks (pre-Java 7), not suitable for dynamically generated strings. Example: String s1 = \"hello\"; String s2 = \"hello\"; (s1 == s2 is true), String s3 = new String(\"hello\").intern(); (s1 == s3 is true). Use interning judiciously for string literals and frequently used constant strings, avoid for dynamic strings."
  },
  {
    "question": "What is the difference between String, StringBuffer, and StringBuilder?",
    "answer": "String, StringBuffer, and StringBuilder differ in mutability and thread safety: String is immutable - any modification creates new object, thread-safe due to immutability, inefficient for multiple concatenations (O(n²) complexity), stored in string pool for literals, best for unchanging text. StringBuffer is mutable with synchronized methods, thread-safe for concurrent access, efficient for string modifications, higher overhead due to synchronization, good for multi-threaded string building. StringBuilder is mutable without synchronization, not thread-safe, fastest for string modifications in single-threaded environment, most efficient for multiple concatenations, preferred for string building operations. Performance comparison for multiple operations: StringBuilder > StringBuffer > String. Use String for: few operations, immutable text, thread-safe scenarios without modification. Use StringBuilder for: frequent string modifications, single-threaded environments, performance-critical string operations. Use StringBuffer for: string building in multi-threaded environment, when thread safety is required. Modern Java optimizes string concatenation with + operator using StringBuilder internally, but explicit StringBuilder is still preferred for loops and complex operations."
  },
  {
    "question": "What is the difference between throw and throws in Java exception handling?",
    "answer": "The 'throw' keyword is used to explicitly throw an exception from within a method or block, followed by an instance of an exception object. The 'throws' keyword is used in method declarations to specify that the method might throw certain checked exceptions. Key differences: throw is used for actual exception throwing (throw new IllegalArgumentException()), throws is used for exception declaration (public void method() throws IOException), throw is followed by an exception instance, throws is followed by exception class names, throw is used inside method body, throws is used in method signature. You can throw only one exception at a time with throw, but can declare multiple exceptions with throws."
  },
  {
    "question": "What is exception chaining in Java and how do you implement it?",
    "answer": "Exception chaining is the ability to associate one exception with another exception, creating a chain of exceptions that shows the complete path of error propagation. This is implemented using the 'cause' parameter in exception constructors or the initCause() method. Exception chaining helps in debugging by preserving the original exception information while wrapping it in a more appropriate exception for the current context. Example: throw new ServiceException(\"Service failed\", originalException). The getCause() method retrieves the underlying cause. This technique is useful when translating low-level exceptions into higher-level ones while maintaining the original error context, enabling better debugging and error tracking throughout the application layers."
  },
  {
    "question": "What are custom exceptions in Java and when should you create them?",
    "answer": "Custom exceptions are user-defined exception classes that extend either Exception (for checked exceptions) or RuntimeException (for unchecked exceptions). Create custom exceptions when: 1) You need domain-specific error handling, 2) Built-in exceptions don't adequately describe the error condition, 3) You want to provide additional context or methods, 4) You need to distinguish between different types of errors in your application. Example: class InsufficientFundsException extends Exception { private double deficit; public InsufficientFundsException(String message, double deficit) { super(message); this.deficit = deficit; } }. Custom exceptions improve code readability, enable specific error handling strategies, provide better debugging information, and allow for more precise exception handling in different layers of the application."
  },
  {
    "question": "What happens when an exception is not caught in Java?",
    "answer": "When an exception is not caught, it propagates up the call stack until it either finds a matching catch block or reaches the main method. If no handler is found: 1) The thread terminates abnormally, 2) The JVM prints the exception stack trace to the error stream, 3) For the main thread, the entire program terminates, 4) For other threads, only that thread terminates while the program continues. The default exception handler (UncaughtExceptionHandler) can be set to customize this behavior. Uncaught checked exceptions prevent compilation, while uncaught runtime exceptions cause runtime termination. This mechanism ensures that errors don't go unnoticed and provides debugging information through stack traces, helping developers identify and fix issues."
  },
  {
    "question": "What is the try-with-resources statement in Java?",
    "answer": "Try-with-resources is a feature introduced in Java 7 that automatically manages resources implementing AutoCloseable or Closeable interfaces. Syntax: try (ResourceType resource = new ResourceType()) { // use resource }. Benefits include: automatic resource cleanup, elimination of explicit finally blocks for resource management, proper handling of exceptions during resource closing, cleaner and more readable code. If exceptions occur in both try block and during resource closing, the original exception is preserved and closing exceptions are suppressed (accessible via getSuppressed()). Multiple resources can be declared: try (FileReader fr = new FileReader(\"file.txt\"); BufferedReader br = new BufferedReader(fr)). This feature significantly reduces boilerplate code, prevents resource leaks, and ensures proper resource management even when exceptions occur."
  },
  {
    "question": "How do you handle multiple exceptions in a single catch block?",
    "answer": "Java 7 introduced multi-catch feature allowing multiple exception types in a single catch block using the pipe (|) operator. Syntax: catch (ExceptionType1 | ExceptionType2 | ExceptionType3 e). Example: try { // risky code } catch (IOException | SQLException | ClassNotFoundException e) { // handle all three exceptions with same logic }. Key points: 1) Use pipe (|) to separate exception types, 2) Single variable name for caught exception, 3) Variable type is the common superclass of all specified exceptions, 4) Reduces code duplication when handling logic is same, 5) More specific exceptions should be caught before general ones in separate catch blocks. This approach makes code cleaner, reduces boilerplate, and centralizes similar exception handling logic."
  },
  {
    "question": "What is the performance impact of exception handling in Java?",
    "answer": "Exception handling has minimal performance impact when exceptions are not thrown, but significant overhead when they are thrown. Performance aspects: 1) Try-catch blocks with no exceptions: negligible overhead, JVM optimizes well, 2) When exceptions are thrown: expensive due to stack trace creation, control flow changes, JVM optimization prevention, 3) Exception creation cost: object allocation, stack trace capture, reflection for stack trace, 4) Catching and handling: relatively inexpensive compared to throwing. Best practices: avoid exceptions for normal control flow, use exceptions for exceptional conditions only, consider boolean returns for expected failure cases, cache frequently used exceptions, override fillInStackTrace() for performance-critical custom exceptions. The key is using exceptions appropriately for error conditions rather than normal program flow control."
  },
  {
    "question": "When does the finally block not execute in Java?",
    "answer": "The finally block is designed to always execute, but there are rare scenarios where it doesn't: 1) System.exit() - terminates JVM immediately, preventing finally execution, 2) Fatal JVM errors - OutOfMemoryError, StackOverflowError may prevent execution, 3) Thread termination - if thread is killed abruptly, 4) Infinite loop or deadlock - code never reaches finally block, 5) Power failure or system crash - external factors. Example: try { System.exit(0); } finally { // This won't execute }. Under normal circumstances including exceptions being thrown and caught, finally always executes. These scenarios are exceptional and indicate serious system problems. The finally block is reliable for resource cleanup in typical application scenarios, making it essential for proper resource management."
  },
  {
    "question": "What is the File class in Java and what operations can you perform?",
    "answer": "The File class represents file and directory pathnames in a platform-independent way, providing methods to interact with the file system without reading/writing file contents. Main operations: 1) File information: exists(), isFile(), isDirectory(), canRead(), canWrite(), length(), lastModified(), 2) File operations: createNewFile(), delete(), renameTo(), 3) Directory operations: mkdir(), mkdirs(), list(), listFiles(), 4) Path operations: getName(), getParent(), getAbsolutePath(), getCanonicalPath(). Example: File file = new File(\"document.txt\"); if (file.exists()) { System.out.println(\"Size: \" + file.length()); }. The File class is essential for file system metadata access, path manipulation, and basic file/directory operations in Java applications before performing actual I/O operations."
  },
  {
    "question": "How do you read and write files using byte streams in Java?",
    "answer": "Byte streams handle raw binary data using InputStream and OutputStream classes for reading and writing respectively. Reading: use FileInputStream with read() methods. Writing: use FileOutputStream with write() methods. Example: try (FileInputStream fis = new FileInputStream(\"input.dat\"); FileOutputStream fos = new FileOutputStream(\"output.dat\")) { byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = fis.read(buffer)) != -1) { fos.write(buffer, 0, bytesRead); } }. Byte streams are suitable for binary files like images, videos, executables. BufferedInputStream and BufferedOutputStream provide buffering for better performance. Always use try-with-resources for automatic resource management. These streams work with raw bytes without character encoding/decoding, making them ideal for binary data processing."
  },
  {
    "question": "How do you read and write files using character streams in Java?",
    "answer": "Character streams handle text data using Reader and Writer classes, automatically managing character encoding. Reading: use FileReader or InputStreamReader. Writing: use FileWriter or OutputStreamWriter. Example: try (FileReader fr = new FileReader(\"input.txt\"); FileWriter fw = new FileWriter(\"output.txt\")) { int character; while ((character = fr.read()) != -1) { fw.write(character); } }. BufferedReader and BufferedWriter provide buffering and additional methods like readLine(). Character streams are ideal for text files as they handle character encoding automatically. Use InputStreamReader/OutputStreamWriter when specifying character encoding explicitly: new InputStreamReader(new FileInputStream(\"file.txt\"), \"UTF-8\"). This approach ensures proper handling of different character encodings and text-based data processing."
  },
  {
    "question": "What is the difference between BufferedReader and Scanner for file reading?",
    "answer": "BufferedReader and Scanner serve different purposes for file reading: BufferedReader is optimized for efficient text reading, provides readLine() method, has lower memory overhead, faster for large files, works with any Reader, suitable for line-by-line processing. Scanner provides parsing capabilities for different data types, can tokenize input using delimiters, has methods like nextInt(), nextDouble(), hasNext(), more convenient for formatted input, higher overhead due to parsing features. Use BufferedReader for: simple text reading, large files, performance-critical applications, line-by-line processing. Use Scanner for: parsing structured data, reading different data types, convenience over performance. Example: BufferedReader br = new BufferedReader(new FileReader(\"file.txt\")); vs Scanner scanner = new Scanner(new File(\"file.txt\")). Choose based on your specific needs: performance vs. convenience."
  },
  {
    "question": "What is serialization in Java and how does it work?",
    "answer": "Serialization is the process of converting Java objects into a byte stream for storage or transmission. The object must implement the Serializable interface. Process involves: 1) Object → byte stream (marshalling) using ObjectOutputStream.writeObject(), 2) Byte stream → Object (unmarshalling) using ObjectInputStream.readObject(). Example: try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"data.ser\"))) { oos.writeObject(myObject); }. Features include: automatic handling of object graphs, preservation of object state, transient keyword excludes fields, serialVersionUID maintains version compatibility, custom serialization with writeObject()/readObject() methods. Serialization is useful for caching, deep copying, network communication, persistence, and distributed computing. However, it has security implications and performance overhead, requiring careful consideration in production applications."
  },
  {
    "question": "What is the purpose of serialVersionUID in Java serialization?",
    "answer": "serialVersionUID is a unique identifier for each Serializable class used during deserialization to verify version compatibility between serialized objects and current class definitions. When deserializing, the JVM compares the serialVersionUID of the serialized object with the current class. If they don't match, InvalidClassException is thrown. Purpose: 1) Version control for serialized objects, 2) Backward compatibility assurance, 3) Prevention of deserialization errors when class structure changes, 4) Control over class evolution. Best practice: explicitly declare as static final long field rather than relying on automatically generated values. Example: private static final long serialVersionUID = 1L; This ensures consistent behavior across different JVM implementations, compiler versions, and prevents issues when class definitions are modified. Proper serialVersionUID management is crucial for maintaining compatibility in distributed systems and long-term data storage."
  },
  {
    "question": "What fields are not serialized in Java serialization by default?",
    "answer": "Several types of fields are excluded from Java serialization by default: 1) transient fields - explicitly marked to exclude from serialization using transient keyword, 2) static fields - belong to class, not instance, so not serialized, 3) Fields in non-serializable parent classes - unless parent implements Serializable. The transient keyword is most commonly used: transient String temporaryData; Use cases for transient: sensitive data (passwords), derived/calculated fields, cache data, non-serializable objects, temporary state. During deserialization, transient fields are initialized to default values (null for objects, 0 for numbers, false for boolean). Custom serialization logic can be implemented using writeObject() and readObject() methods to handle transient fields specially. This selective serialization helps reduce object size, prevents serialization of unnecessary data, and maintains data security by excluding sensitive information."
  },
  {
    "question": "What is externalization in Java and how does it differ from serialization?",
    "answer": "Externalization is a customized form of serialization where the programmer has complete control over the serialization process by implementing the Externalizable interface. Key differences: Externalization requires explicit implementation of writeExternal() and readExternal() methods, provides full control over what gets serialized, typically more efficient and produces smaller output, requires more programming effort, no automatic handling. Serialization uses automatic process, handles all non-transient fields automatically, easier to implement but less control, larger serialized output, built-in versioning support. Example: public void writeExternal(ObjectOutput out) throws IOException { out.writeUTF(name); out.writeInt(age); }. Use externalization when: you need optimal performance, want minimal serialized size, need custom serialization logic, have complex object structures requiring specific handling. The trade-off is between convenience (serialization) and control/performance (externalization)."
  },
  {
    "question": "What is the Collections Framework in Java and what does it provide?",
    "answer": "The Collections Framework is a unified architecture for representing and manipulating collections of objects, introduced in Java 1.2. It provides: 1) Interfaces - define abstract data types (Collection, List, Set, Map, Queue, Deque), 2) Implementations - concrete classes (ArrayList, HashMap, TreeSet, LinkedList), 3) Algorithms - static methods in Collections class for operations (sorting, searching, shuffling), 4) Utilities - helper classes and methods for collection operations. Key interfaces: Collection (root interface), List (ordered with duplicates), Set (no duplicates), Map (key-value pairs), Queue (FIFO operations). Benefits include: reduced programming effort through reusable data structures, increased performance with optimized implementations, interoperability between APIs, consistent programming model, reduced learning curve. The framework promotes code reuse, provides high-performance implementations, and establishes standard collection operations across Java applications."
  },
  {
    "question": "What are the main differences between ArrayList and LinkedList?",
    "answer": "ArrayList and LinkedList are both List implementations but have different internal structures and performance characteristics: ArrayList uses dynamic array (resizable array), provides O(1) random access via get(index), O(1) amortized insertion at end, O(n) insertion/deletion in middle due to element shifting, better memory locality for iteration, lower memory overhead per element, cache-friendly. LinkedList uses doubly-linked list, provides O(n) random access requiring traversal, O(1) insertion/deletion at known positions with iterator, O(1) insertion/deletion at ends, higher memory overhead due to node pointers, pointer-chasing affects cache performance. Use ArrayList for: frequent random access, iteration-heavy operations, memory-constrained environments, general-purpose lists. Use LinkedList for: frequent insertions/deletions in middle, implementing queue/deque operations, when insertion/deletion performance matters more than random access. ArrayList is generally preferred due to better cache performance and lower memory usage."
  },
  {
    "question": "What is the difference between HashMap and Hashtable in Java?",
    "answer": "HashMap and Hashtable are both hash-based Map implementations but have several key differences: HashMap is not synchronized (not thread-safe), allows one null key and multiple null values, faster performance due to no synchronization overhead, introduced in Java 1.2 as part of Collections Framework, uses fail-fast iterators, part of modern collection design. Hashtable is synchronized (thread-safe), doesn't allow null keys or values, slower due to synchronization overhead on all methods, legacy class from Java 1.0, uses fail-safe enumerators, considered outdated. HashMap is preferred for single-threaded applications or when external synchronization is provided. For thread-safety, use ConcurrentHashMap instead of Hashtable as it provides better performance through advanced locking strategies. Hashtable is largely considered legacy and should be avoided in new code development in favor of more modern alternatives."
  },
  {
    "question": "What is ConcurrentHashMap and how does it achieve thread safety?",
    "answer": "ConcurrentHashMap is a thread-safe Map implementation providing better concurrency than synchronized maps through sophisticated locking strategies. Thread safety mechanisms: Java 7 and earlier used segment-based locking (dividing map into segments with separate locks), Java 8+ uses node-based locking with CAS operations and synchronized blocks on individual nodes/buckets. Key features: 1) Lock-free reads - get operations don't require locks in most cases, 2) Limited concurrent writes - multiple threads can write to different parts simultaneously, 3) Fail-safe iterators - don't throw ConcurrentModificationException, 4) Atomic operations - putIfAbsent(), replace(), compute() methods, 5) Scalable performance - performance scales with thread count, 6) Memory consistency - proper visibility guarantees. ConcurrentHashMap provides much better throughput than Hashtable or Collections.synchronizedMap() in multi-threaded environments while maintaining thread safety guarantees and supporting high concurrency levels."
  },
  {
    "question": "What is the difference between HashSet and TreeSet?",
    "answer": "HashSet and TreeSet are both Set implementations but use different data structures with distinct characteristics: HashSet uses hash table for storage, provides O(1) average time complexity for basic operations (add, remove, contains), doesn't maintain any order of elements, allows null values, based on equals() and hashCode() methods, iteration order is unpredictable. TreeSet uses red-black tree (balanced BST), provides O(log n) time complexity for basic operations, maintains sorted order of elements using natural ordering or custom Comparator, doesn't allow null values, elements must be Comparable or use custom Comparator, provides navigational methods. Use HashSet when: you need fast access without caring about order, maximum performance for basic operations, general-purpose set operations. Use TreeSet when: you need sorted collection, range operations (subSet, headSet, tailSet), navigational methods (first, last, higher, lower), maintaining order is important for business logic."
  },
  {
    "question": "What is LinkedHashSet and when would you use it?",
    "answer": "LinkedHashSet combines features of HashSet and LinkedList, maintaining insertion order while providing HashSet's performance characteristics. It uses hash table for storage with additional doubly-linked list to track insertion order. Characteristics: O(1) performance for basic operations like HashSet, maintains predictable insertion order unlike HashSet, slightly higher memory overhead due to maintaining links between elements, allows null values, provides ordered iteration. Use LinkedHashSet when: you need unique elements (Set behavior), predictable iteration order is important, you want better performance than TreeSet for basic operations, maintaining insertion order for user interfaces or caching scenarios is required. Example use cases: maintaining order of user selections, LRU cache implementation, preserving order of configuration items, scenarios where both uniqueness and order matter. It's the middle ground between HashSet (fast but unordered) and TreeSet (ordered but slower), offering the best of both worlds for specific use cases."
  },
  {
    "question": "What is PriorityQueue and how does it work internally?",
    "answer": "PriorityQueue is a heap-based implementation of Queue interface where elements are ordered by their priority rather than insertion order. It uses binary heap data structure (implemented as resizable array) for efficient insertion and removal of highest-priority elements. Key characteristics: head element is always the smallest (highest priority) based on natural ordering or custom Comparator, not thread-safe, doesn't allow null elements, provides O(log n) time for insertion (offer/add) and removal (poll/remove), O(1) for peek operations, automatically maintains heap property. Common methods: offer()/add() to insert, poll()/remove() to remove head, peek()/element() to view head without removal. Use cases: task scheduling systems, implementing algorithms like Dijkstra's shortest path, finding top K elements, managing events by priority, implementing priority-based workflows. Example: PriorityQueue<Task> taskQueue = new PriorityQueue<>(Comparator.comparing(Task::getPriority)); The queue automatically maintains heap property for efficient priority-based operations."
  },
  {
    "question": "What is the difference between Iterator and ListIterator?",
    "answer": "Iterator and ListIterator are both used for traversing collections, but ListIterator provides additional functionality specifically for Lists: Iterator provides basic traversal with hasNext(), next(), remove() methods, works with any Collection, supports forward-only traversal, can remove elements during iteration, universal collection traversal. ListIterator extends Iterator and adds: bidirectional traversal with hasPrevious(), previous() methods, positional access with nextIndex(), previousIndex(), modification capabilities with set() and add() methods, only works with List collections, can modify list structure during iteration. ListIterator advantages: can traverse list in both directions, can modify list during iteration (add/set elements), provides index information during iteration, more powerful for list manipulation. Use Iterator for: simple forward traversal of any collection, basic iteration needs, read-only operations. Use ListIterator for: bidirectional traversal of lists, modifying lists during iteration, when you need positional information, complex list processing scenarios."
  },
  {
    "question": "What is fail-fast behavior in Java collections and how does it work?",
    "answer": "Fail-fast behavior means that iterators immediately throw ConcurrentModificationException when they detect that the collection has been modified during iteration, except through the iterator's own methods. Mechanism: collections maintain a modification count (modCount) that's incremented with each structural modification (add, remove), iterators store expected modCount at creation and check it on each operation. Fail-fast collections include: ArrayList, HashMap, HashSet, TreeMap, TreeSet and their iterators. Purpose: early detection of concurrent modifications, preventing unpredictable behavior, helping identify threading issues and programming errors. Example: List<String> list = new ArrayList<>(); Iterator<String> it = list.iterator(); list.add(\"item\"); it.next(); // throws ConcurrentModificationException. To avoid: use iterator's remove() method, use concurrent collections (ConcurrentHashMap), synchronize access, or create copy for iteration. Fail-fast behavior helps catch bugs early but requires careful handling in concurrent environments."
  },
  {
    "question": "What are concurrent collections and when should you use them?",
    "answer": "Concurrent collections are thread-safe collection implementations designed for concurrent access without external synchronization, providing better performance than synchronized collections. Key implementations: ConcurrentHashMap (thread-safe Map), CopyOnWriteArrayList (thread-safe List for read-heavy scenarios), ConcurrentLinkedQueue (thread-safe Queue), BlockingQueue implementations (ArrayBlockingQueue, LinkedBlockingQueue). Features: 1) Thread-safe operations without external synchronization, 2) Better performance than synchronized collections through advanced locking, 3) Fail-safe iterators - don't throw ConcurrentModificationException, 4) Lock-free or reduced locking for better scalability, 5) Atomic operations for common use cases. Use when: multiple threads access collections concurrently, you need thread safety with good performance, avoiding explicit synchronization complexity, building concurrent applications. Benefits over synchronized collections: better scalability, reduced contention, weakly consistent iteration, designed for concurrency. Choose based on access patterns: ConcurrentHashMap for concurrent maps, CopyOnWriteArrayList for read-heavy lists, BlockingQueue for producer-consumer scenarios."
  },
  {
    "question": "What is the difference between Comparable and Comparator interfaces?",
    "answer": "Comparable and Comparator are both used for object comparison and sorting but serve different purposes: Comparable is implemented by the class whose objects need to be sorted, provides natural ordering through compareTo() method, allows only one sorting sequence per class, compares 'this' object with parameter object, part of java.lang package, defines default/natural ordering. Comparator is a separate functional interface for custom comparison logic, can be implemented externally without modifying original class, allows multiple sorting strategies for same class, compares two objects passed as parameters, part of java.util package, defines custom ordering. Use Comparable for: natural ordering that makes sense for the class (String alphabetical, Integer numerical), single primary sorting criteria, when class has obvious default ordering. Use Comparator for: multiple sorting strategies, custom sorting criteria, sorting objects you can't modify, complex sorting logic, lambda expressions. Example: class Person implements Comparable<Person> vs Comparator<Person> ageComparator = Comparator.comparing(Person::getAge)."
  },
  {
    "question": "How do you sort collections in Java using different approaches?",
    "answer": "Java provides several ways to sort collections with increasing sophistication: 1) Collections.sort(list) - sorts List of Comparable objects using natural ordering, 2) Collections.sort(list, comparator) - sorts using custom Comparator, 3) list.sort(comparator) - instance method on List (Java 8+), 4) Stream API - list.stream().sorted().collect(Collectors.toList()) for functional approach. For custom sorting: use Comparator with lambda expressions or method references: list.sort((a, b) -> a.getName().compareTo(b.getName())), list.sort(Comparator.comparing(Person::getName)), list.sort(Comparator.comparing(Person::getAge).thenComparing(Person::getName)) for chained comparison. Sorting arrays: Arrays.sort(array) or Arrays.sort(array, comparator). For reverse order: Collections.reverseOrder() or Comparator.reverseOrder(). Modern approach prefers method references and chained comparators for readable, maintainable sorting code. All sorting methods use stable, efficient algorithms (typically merge sort or quicksort variants)."
  },
  {
    "question": "What is the difference between peek() and poll() methods in Queue interface?",
    "answer": "peek() and poll() are Queue methods for accessing the head element but behave differently regarding element removal: peek() retrieves but does not remove the head element, returns null if queue is empty, doesn't modify the queue state, useful for inspection without consumption, non-destructive operation. poll() retrieves and removes the head element, returns null if queue is empty, modifies the queue by removing the element, used for consuming queue elements, destructive operation. Similar method pairs: element() vs remove() - throw exceptions instead of returning null when queue is empty (NoSuchElementException). Example: Queue<String> queue = new LinkedList<>(); queue.offer(\"first\"); String head = queue.peek(); // returns \"first\", queue still contains it, String removed = queue.poll(); // returns \"first\", queue is now empty. Use peek() when: checking what's next without consuming, validating queue contents, implementing algorithms that need to look ahead. Use poll() when: consuming queue elements, implementing standard queue operations, processing elements sequentially."
  },
  {
    "question": "What is the difference between offer() and add() methods in Queue interface?",
    "answer": "offer() and add() both insert elements into a Queue but handle capacity restrictions differently: offer() attempts to insert element and returns boolean indicating success/failure, returns false if element cannot be added due to capacity restrictions, preferred method for capacity-restricted queues, graceful handling of insertion failures, follows Queue interface contract. add() attempts to insert element and throws exception if it fails, throws IllegalStateException if element cannot be added due to capacity restrictions, inherited from Collection interface, more aggressive error handling, exception-based failure notification. For unbounded queues (like LinkedList), both methods behave identically and always succeed. For bounded queues (like ArrayBlockingQueue), offer() provides better control flow. Example: Queue<String> boundedQueue = new ArrayBlockingQueue<>(2); boolean success = boundedQueue.offer(\"item\"); // returns false if full, boundedQueue.add(\"item\"); // throws exception if full. Use offer() for: bounded queues, when you want to handle insertion failures gracefully. Use add() for: unbounded queues, when insertion failure should be treated as exceptional condition."
  },
  {
    "question": "What is Deque interface and its common implementations?",
    "answer": "Deque (Double Ended Queue) extends Queue interface and supports insertion and removal of elements from both ends, functioning as both queue (FIFO) and stack (LIFO). Key methods: addFirst()/offerFirst(), addLast()/offerLast() for insertion, removeFirst()/pollFirst(), removeLast()/pollLast() for removal, peekFirst(), peekLast() for inspection, push()/pop() for stack operations. Common implementations: ArrayDeque - resizable array implementation, preferred choice for deque operations, no capacity restrictions, not thread-safe, better performance than LinkedList for deque operations. LinkedList - doubly-linked list implementation, implements both List and Deque interfaces, allows null elements, higher memory overhead due to node pointers. Use cases: implementing undo functionality, sliding window algorithms, breadth-first search, palindrome checking, browser history. ArrayDeque advantages: better performance, no null elements allowed, more memory efficient. LinkedList advantages: implements List interface, allows null elements, better for frequent insertions in middle. Choose ArrayDeque for pure deque operations, LinkedList when you also need List functionality."
  },
  {
    "question": "What are BlockingQueue implementations and their specific use cases?",
    "answer": "BlockingQueue extends Queue interface with blocking operations for thread-safe producer-consumer scenarios. Key blocking methods: put() - blocks if queue is full, take() - blocks if queue is empty, offer(timeout) - waits up to timeout period, poll(timeout) - waits up to timeout period for elements. Common implementations: ArrayBlockingQueue - bounded queue backed by array, fairness option for thread ordering, fixed capacity, good for controlling memory usage. LinkedBlockingQueue - optionally bounded queue backed by linked nodes, higher throughput than ArrayBlockingQueue, better for high-concurrency scenarios. PriorityBlockingQueue - unbounded priority queue, elements ordered by priority, good for task scheduling. SynchronousQueue - no storage capacity, direct handoff between threads, zero-capacity queue. DelayQueue - elements become available after delay period, good for timed events. Use cases: producer-consumer patterns, thread pools (ThreadPoolExecutor uses BlockingQueue), pipeline processing, rate limiting, work distribution. Benefits: automatic synchronization, blocking behavior eliminates busy waiting, various capacity and ordering options for different scenarios."
  },
  {
    "question": "What is the difference between HashMap and TreeMap?",
    "answer": "HashMap and TreeMap are both Map implementations but use different data structures providing different characteristics: HashMap uses hash table, provides O(1) average time complexity for basic operations (get, put, remove), no ordering of keys, allows one null key and multiple null values, based on equals() and hashCode() methods, not thread-safe, iteration order unpredictable. TreeMap uses red-black tree (balanced BST), provides O(log n) time complexity for basic operations, maintains sorted order of keys using natural ordering or custom Comparator, doesn't allow null keys but allows null values, keys must be Comparable or use custom Comparator, not thread-safe, ordered iteration. HashMap advantages: faster for basic operations, suitable when ordering isn't needed, general-purpose mapping. TreeMap advantages: sorted key iteration, navigational methods (firstKey, lastKey, subMap), range operations, maintains key order. Use HashMap for: general-purpose mapping, performance-critical applications, when key ordering is not required. Use TreeMap for: sorted key requirements, range queries, when you need navigational operations on keys, maintaining sorted order for business logic."
  },
  {
    "question": "What is WeakHashMap and when would you use it?",
    "answer": "WeakHashMap is a Map implementation that uses weak references for keys, allowing keys to be garbage collected when no strong references exist elsewhere in the application. When a key is garbage collected, its corresponding entry is automatically removed from the map. Key characteristics: keys are weakly referenced, values are strongly referenced, automatic cleanup of entries when keys become unreachable, not thread-safe, null keys and values allowed. Use cases: implementing caches where entries should expire when keys are no longer used, preventing memory leaks in scenarios like observer patterns, associating metadata with objects temporarily, creating mappings that shouldn't prevent garbage collection of keys. Important considerations: if values reference keys, it prevents garbage collection creating memory leaks, entries may disappear unexpectedly during garbage collection, not suitable when you need guaranteed key retention, requires careful design to avoid unintended key loss. Example use case: caching expensive computations associated with objects, where cache entries should be removed when objects are no longer referenced elsewhere in the application, maintaining weak associations between objects."
  },
  {
    "question": "What are EnumSet and EnumMap and why are they optimized for enums?",
    "answer": "EnumSet and EnumMap are specialized collections designed specifically for enum types, providing high performance and type safety through internal optimizations: EnumSet is a Set implementation for enum types, uses bit vector for internal representation making it extremely efficient (faster than HashSet), provides static factory methods (allOf, noneOf, of, range), maintains natural order of enum constants, cannot contain null elements, compact memory usage. EnumMap is a Map implementation for enum keys, uses array internally with enum ordinal as index making key operations very fast, maintains natural order of enum keys, allows null values but not null keys, all keys must be from single enum type, memory efficient. Benefits: superior performance compared to general-purpose collections due to bit manipulation and array access, compact memory usage, type safety at compile time, natural ordering maintained automatically. Use EnumSet for: sets of enum constants, bit field replacement, flag combinations, performance-critical enum operations. Use EnumMap for: mappings with enum keys, sparse arrays indexed by enums, configuration mappings, state machines. Example: EnumSet<Day> weekend = EnumSet.of(SATURDAY, SUNDAY); EnumMap<Status, String> statusMessages = new EnumMap<>(Status.class);"
  },
  {
    "question": "What is the difference between Arrays.asList() and Collections.singletonList()?",
    "answer": "Arrays.asList() and Collections.singletonList() both create lists but serve different purposes with distinct characteristics: Arrays.asList() creates a fixed-size list backed by the original array, can contain multiple elements from array parameter, allows modification of existing elements via set() method, changes reflect in both list and original array, throws UnsupportedOperationException for add/remove operations, can contain null elements, mutable content but fixed size. Collections.singletonList() creates an immutable list containing exactly one element, optimized for single-element use case, completely immutable (no modifications allowed), throws UnsupportedOperationException for all modification attempts, more memory efficient than other single-element lists, allows null element, both size and content immutable. Use Arrays.asList() for: converting arrays to lists, when you need list view of array data, when limited modification (set operations) is acceptable, working with existing arrays. Use Collections.singletonList() for: returning single-element lists from methods, immutable single-element collections, memory-efficient single-element scenarios, API methods requiring single-item lists. Example: List<String> arrayList = Arrays.asList(\"a\", \"b\", \"c\"); List<String> singleList = Collections.singletonList(\"single\");"
  },
  {
    "question": "What are the performance characteristics of different Collection implementations?",
    "answer": "Different collection implementations have varying performance characteristics optimized for different use cases: ArrayList - O(1) random access via index, O(1) amortized add at end, O(n) insert/delete in middle due to shifting, good iteration performance, cache-friendly. LinkedList - O(n) random access requiring traversal, O(1) insert/delete at known positions with iterator reference, O(1) add at ends, higher memory per element due to node overhead. HashMap - O(1) average for get/put operations, O(n) worst case with poor hash function or high collision rate, iteration depends on capacity + size. TreeMap - O(log n) for get/put operations, sorted iteration, navigational operations, red-black tree guarantees. HashSet - O(1) average for add/contains/remove, based on HashMap performance characteristics. TreeSet - O(log n) for add/contains/remove, sorted iteration, navigational methods. Vector - similar to ArrayList but synchronized, performance penalty due to synchronization overhead. ArrayDeque - O(1) for operations at both ends, preferred over LinkedList for deque operations, better cache performance. ConcurrentHashMap - O(1) average with better concurrency than synchronized HashMap, segment or node-level locking. Choose based on: access patterns (random vs sequential), modification patterns (frequent inserts vs stable), concurrency requirements, memory constraints, ordering requirements."
  },
  {
    "question": "What is the diamond operator (<>) in Java generics and how does it work?",
    "answer": "The diamond operator (<>) was introduced in Java 7 to reduce verbosity in generic instantiation through type inference, eliminating the need to repeat generic type parameters on both sides of assignment. Instead of: List<String> list = new ArrayList<String>(), you can write: List<String> list = new ArrayList<>(); The compiler infers the generic type from the left side through target type inference. Key features: eliminates redundant type specification, maintains compile-time type safety, works with constructors and method calls, reduces code clutter and improves readability. Limitations: only works when type can be inferred from context, doesn't work with anonymous classes in Java 7 (fixed in Java 9), sometimes requires explicit types for complex generic scenarios involving wildcards or bounded types. Benefits: cleaner, more readable code, less typing required, reduced chance of type mismatches between declaration and instantiation, easier maintenance when changing generic types. Example: Map<String, List<Integer>> map = new HashMap<>(); instead of Map<String, List<Integer>> map = new HashMap<String, List<Integer>>(); The diamond operator significantly improves generic code readability while preserving all type safety benefits."
  },
  {
    "question": "What are raw types in Java generics and why should they be avoided?",
    "answer": "Raw types are generic classes or interfaces used without type parameters, essentially treating them as they existed before generics were introduced in Java 5. Example: List instead of List<String>. Problems with raw types: loss of compile-time type safety allowing incorrect types to be added, potential ClassCastException at runtime when retrieving elements, compiler generates unchecked warnings indicating potential issues, cannot benefit from generic type checking and IDE support, mixing raw and parameterized types causes complex type system issues. Why avoid them: defeats the primary purpose of generics (type safety), creates error-prone code requiring explicit casts, no compile-time verification of type correctness, potential runtime failures that could be prevented at compile time, poor code maintainability and readability. Raw types exist solely for backward compatibility with pre-Java 5 code. Modern code should always use parameterized types: List<String> instead of List, Map<String, Integer> instead of Map. Use @SuppressWarnings(\"rawtypes\") only when dealing with legacy code that cannot be updated. Raw types compromise the type safety that generics were designed to provide and should be eliminated in new development for robust, maintainable code."
  },
  {
    "question": "What are bounded type parameters in Java generics and how do you use them?",
    "answer": "Bounded type parameters restrict the types that can be used as generic arguments using extends and super keywords, providing both flexibility and type safety. Upper bounds use extends: <T extends Number> restricts T to Number or its subtypes, enables calling Number methods on T instances, multiple bounds possible with &: <T extends Number & Comparable<T>> requiring T to extend Number AND implement Comparable. Lower bounds use super in wildcards: <? super Integer> restricts to Integer or its supertypes, used in consumer scenarios following PECS principle. Examples: class NumberContainer<T extends Number> - only accepts numeric types, method <T extends Comparable<T>> void sort(List<T> list) - enables sorting by requiring comparability. Benefits: access to bound class methods and fields without casting, type safety with meaningful constraints, expressing relationships between type parameters, enabling generic algorithms that need specific capabilities like arithmetic or comparison. Use cases: mathematical operations requiring Number methods, sorting requiring Comparable interface, collections that need specific type capabilities, creating type-safe APIs with constrained flexibility. Bounded parameters are essential for creating flexible yet type-safe generic classes and methods that can leverage specific capabilities of their type parameters while maintaining compile-time type checking."
  },
  {
    "question": "What are wildcard types (?, ? extends, ? super) in Java generics and when do you use each?",
    "answer": "Wildcards represent unknown types in generics, providing flexibility when exact type isn't known or when working with type hierarchies. Three types serve different purposes: Unbounded wildcard (?) - represents any type, useful for operations that don't depend on type parameter, read-only scenarios where you only use Object methods, maximum flexibility with minimal type information. Upper bounded wildcard (? extends T) - unknown type that is T or subtype of T, used for reading/consuming from collections (covariance), follows 'producer extends' principle, allows safe extraction but restricts insertion. Lower bounded wildcard (? super T) - unknown type that is T or supertype of T, used for writing/adding to collections (contravariance), follows 'consumer super' principle, allows safe insertion but restricts extraction. PECS rule: Producer Extends, Consumer Super - use extends when reading from structure, super when writing to structure. Examples: List<?> anyList - can hold any type, List<? extends Number> numbers - can read Numbers safely, List<? super Integer> integers - can add Integers safely. Wildcards enable writing flexible APIs that work with families of related types while maintaining type safety, essential for creating reusable generic methods and classes that work with inheritance hierarchies."
  },
  {
    "question": "What are generic methods in Java and how do they differ from generic classes?",
    "answer": "Generic methods introduce their own type parameters independent of the class's generic parameters, enabling method-level generics for specific operations. Syntax: place type parameter declaration before return type: <T> returnType methodName(parameters). The type parameter can be used in return type, parameter types, and method body. Examples: public <T> void swap(T[] array, int i, int j), public <T extends Comparable<T>> T max(T a, T b), public <K, V> Map<K, V> createMap(). Differences from generic classes: scope is limited to the method, can exist in non-generic classes, can have different type parameters than class, resolved independently at each method call. Benefits: generic behavior in non-generic classes, method-specific type parameters different from class parameters, type safety without requiring generic classes, flexible utility methods with compile-time type checking. Type inference allows calling without explicit type specification: String max = max(\"hello\", \"world\"); Generic methods can be static or instance methods, can have multiple type parameters, can use bounded type parameters for constraints. They're essential for creating reusable, type-safe utility methods and enable generic programming patterns even in non-generic classes, commonly used in utility classes like Collections for type-safe operations."
  },
  {
    "question": "What is type erasure in Java generics and what are its implications for developers?",
    "answer": "Type erasure is the process where generic type information is removed during compilation, with type parameters replaced by their bounds or Object for backward compatibility with pre-generic Java code. At runtime, List<String> and List<Integer> are both just List, losing generic type information. Implications for developers: cannot create arrays of generic types (new List<String>[10] illegal due to heap pollution), cannot use instanceof with parameterized types (obj instanceof List<String> won't compile), cannot catch or throw generic exception types in catch blocks, generic type information unavailable at runtime through reflection, method overloading restrictions with generic parameters that erase to same type. Bridge methods are generated to maintain polymorphism after erasure. Workarounds include: using Class<T> parameters for runtime type information, wildcards for flexibility, @SuppressWarnings for unavoidable raw type usage, reflection with ParameterizedType for limited runtime type access. Type erasure enables backward compatibility with pre-generic Java code but limits some generic programming patterns. Understanding erasure is crucial for effective generic programming, avoiding common pitfalls like generic array creation, and designing APIs that work correctly with the type system's limitations while maintaining type safety at compile time."
  },
  {
    "question": "What is the purpose of the equals() and hashCode() contract in Java?",
    "answer": "The equals() and hashCode() contract ensures consistent behavior in hash-based collections and object comparison, fundamental to Java's object identity system. The contract states: 1) If two objects are equal according to equals(), they must have the same hashCode() value, 2) If two objects have the same hashCode(), they may or may not be equal (hash collision is allowed), 3) hashCode() must be consistent during object lifetime (same value for same object), 4) equals() must be reflexive (x.equals(x) = true), symmetric (x.equals(y) = y.equals(x)), transitive, and consistent. Violating this contract causes incorrect behavior in HashMap, HashSet, and other hash-based collections - equal objects might be stored in different buckets, leading to duplicates in sets or inability to retrieve values from maps. Best practices: always override both methods together, use same fields in both methods for consistency, consider using Objects.equals() and Objects.hash() utility methods, make methods consistent with business logic, ensure immutable fields are used when possible. The contract is fundamental to proper collection behavior, object identity in Java, and enables efficient hash-based data structures to function correctly."
  },
  {
    "question": "What happens if you override equals() but not hashCode() or vice versa?",
    "answer": "Overriding only one of equals() or hashCode() violates their fundamental contract and causes serious problems in hash-based collections: If you override equals() but not hashCode(): objects that are equal according to equals() may have different hash codes, violating the fundamental contract requirement, hash-based collections like HashMap and HashSet will malfunction, equal objects might be stored in different hash buckets, leading to duplicate entries in HashSet or inability to find logically equal objects in HashMap. If you override hashCode() but not equals(): objects with same hash code might be considered unequal by equals(), causes performance degradation due to unnecessary hash collisions, collections work correctly but with poor performance, multiple unequal objects clustering in same hash bucket reducing efficiency. Example problems: Set<Person> set may contain duplicate Person objects even though they should be logically equal, Map<Person, String> map cannot retrieve values for logically equal Person keys. Solution: always override both methods together using same significant fields, ensure they maintain the contract throughout object lifecycle, use IDE-generated implementations or utility methods like Objects.equals() and Objects.hash(). Modern IDEs can generate both methods automatically to maintain proper contract, preventing these common but serious bugs."
  },
  {
    "question": "What is the difference between == operator and equals() method in Java?",
    "answer": "The == operator and equals() method serve different purposes in Java's object comparison system: == operator: for primitives, compares actual values (5 == 5 is true), for objects, compares references/memory addresses checking if two references point to same object instance, cannot be overridden as it's language-level operator, very fast operation with no method call overhead. equals() method: compares object contents for logical equality, can be overridden to define custom equality logic based on object state, inherited from Object class with default reference comparison behavior, should be used for meaningful object content comparison, polymorphic method call. Key differences: == checks identity (same object instance), equals() checks equality (same logical content), == is not polymorphic, equals() can be customized for business logic, String comparison example: String s1 = \"hello\"; String s2 = \"hello\"; (s1 == s2 might be true due to string interning), String s1 = new String(\"hello\"); String s2 = new String(\"hello\"); (s1 == s2 is false, s1.equals(s2) is true). Best practice: use == for primitives and reference identity checks, use equals() for object content comparison, always check for null before calling equals(): Objects.equals(a, b) is safer than a.equals(b) to avoid NullPointerException."
  },
  {
    "question": "What is string interning in Java and how does it affect memory and performance?",
    "answer": "String interning is the process of storing only one copy of each distinct string value in the string pool (a special memory area in heap), reducing memory usage and enabling reference equality checks. When creating string literals, JVM checks the string pool first - if the string exists, it returns reference to existing string; otherwise, creates new string and adds to pool. Process: compile-time literals automatically interned, runtime strings can be interned using intern() method, pool implemented as hash table for fast lookup, garbage collection can clean up unused interned strings (Java 7+). Benefits: memory savings by avoiding duplicate strings especially for frequently used values, faster string comparison using == for interned strings instead of equals(), reduced memory allocation overhead for common strings. Drawbacks: intern() method has performance overhead due to pool lookup and potential creation, overuse can lead to memory leaks in older Java versions, not suitable for dynamically generated strings that won't be reused, pool lookup cost may outweigh benefits for infrequently used strings. Example: String s1 = \"hello\"; String s2 = \"hello\"; (s1 == s2 is true), String s3 = new String(\"hello\").intern(); (s1 == s3 is true). Use interning judiciously for string literals, constants, and frequently used strings, avoid for dynamic strings with short lifecycles."
  },
  {
    "question": "What is the difference between String, StringBuffer, and StringBuilder in terms of performance and thread safety?",
    "answer": "String, StringBuffer, and StringBuilder differ significantly in mutability, thread safety, and performance characteristics: String is immutable - any modification creates new object instance, thread-safe due to immutability, inefficient for multiple concatenations due to O(n²) complexity creating many intermediate objects, stored in string pool for literals, best for unchanging text and when few operations are performed. StringBuffer is mutable with synchronized methods on all operations, thread-safe for concurrent access by multiple threads, efficient for string modifications with O(n) complexity, higher overhead due to synchronization locks on every method call, good for multi-threaded string building scenarios. StringBuilder is mutable without synchronization, not thread-safe but fastest for string modifications in single-threaded environment, most efficient for multiple concatenations with O(n) complexity, lowest overhead with no synchronization cost, preferred for string building operations in single-threaded code. Performance comparison for multiple operations: StringBuilder > StringBuffer >> String. Use String for: few operations, immutable text, thread-safe scenarios without modification. Use StringBuilder for: frequent string modifications, single-threaded environments, performance-critical string operations. Use StringBuffer for: string building in multi-threaded environment when thread safety is required. Modern Java optimizes string concatenation with + operator using StringBuilder internally, but explicit StringBuilder is still preferred for loops and complex operations."
  }
]
